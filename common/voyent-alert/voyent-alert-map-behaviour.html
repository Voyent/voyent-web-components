<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">
<link rel="import" href="../imports/resize-observer.html">

<script>
    var Voyent = Voyent || {};
    var singletonInfoWindow; // Single copy of our user details info window, to ensure only one is open at a time
    /**
     * Provides common functionality required by map-based `voyent-alert-*` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        /**
         * Fires when the alert template is successfully saved. Does not include any data.
         * @event voyent-alert-template-saved
         */

        /**
         * Fires when the user cancels creating a new template.
         * @event voyent-alert-template-cancel
         */

        /**
         * Fires when a new alert zone is added to the template. This could be in the form of a completely new stack or
         * adding to an existing stack. Includes an `id` property which identifies the zone, a `zone` property that
         * contains the associated data and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-added
         */

        /**
         * Fired when an alert zone is removed from the template. Includes an `id` property which identifies
         * the zone and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-removed
         */

        /**
         * Fires when the selected alert zone changes. Includes an `id` property which identifies the zone, a `zone`
         * property that contains the associated data and an `isFallbackZone` property indicating whether the zone is
         * the fallback zone. If no zone is selected then the `id` and `zone` values will be null.
         * @event voyent-alert-zone-selected
         */

        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the alert template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String, observer: '_realmChanged' },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: { type: Number, observer: '_mapSizePropertyChanged' },
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: { type: Number, observer: '_mapSizePropertyChanged' },
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             * @default -1
             */
            autoheight: { type: Number, value: -1, notify: true, observer: '_mapSizePropertyChanged' },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             * @default '.'
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' },
            /**
             * The subdirectory where our badge files are stored
             */
            badgedir: { type: String, value: '' }
        },

        observers: [
            '_fallbackZoneEnabledChanged(_fallbackZone.enabled)'
        ],

        ready: function() {
            var _this = this;
            //Define some constants.
            this._CONTAINER_ID = 'container';
            this._SIDE_PANEL_ID = 'sidePanel';
            this._FULLSCREEN_BUTTON_ID = 'fullscreenBttn';
            this._FULLSCREEN_CONTAINER_ID = 'fullscreenContainer';
            this._CIRCLE_BUTTON_ID = 'circleBttn';
            this._POLYGON_BUTTON_ID = 'polygonBttn';
            this._FALLBACK_ZONE_BUTTON_ID = 'fallbackZoneBttn';
            this._IMPORT_BUTTON_ID = 'importBttn';
            this._ZOOM_BUTTONS_ID = 'zoomBttns';
            this._MAP_TYPE_BUTTONS_ID = 'mapTypeBttns';
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            //We will always depend on loading the map API externally.
            this._mapsApiAvailable().then(function() {
                _this._initializeGoogleMap();
            });
        },

        /**
         * General function for initializing the Google Map and other required features.
         * @private
         */
        _initializeGoogleMap: function () {
            var _this = this;
            var mapOptions = {
                zoom: 10,
                // Restrict the min zoom level since less than 3 is meaningless and causes
                // issues with calculating the map area in the zoom changed listener
                minZoom: 3,
                center: new google.maps.LatLng(51.08427,-114.13062),
                streetViewControl: false,
                fullscreenControl: false,
                scrollwheel: false,
                scaleControl: true,
                mapTypeControl: false,
                zoomControl: false,
                keyboardShortcuts: false //VRAS-394
            };
            if (!this._isMyLocations()) {
                mapOptions.clickableIcons = false;
            }
            //Alert view map is readonly.
            if (this._isAlertView()) {
                mapOptions.draggable = false;
                mapOptions.disableDoubleClickZoom = true;
            }
            //Initialize the map.
            this._map = new google.maps.Map(this.$.map,mapOptions);
            // Add the map type and zoom buttons (VRAS-671)
            this._addMapControlButtons();
            //Calculate the map size.
            this._calcMapSize();
            this._setupMapListeners();
            if (this._isAnAlertEditor()) {
                //Setup ui and listeners for adding new marker based entities.
                this._drawingManager = new google.maps.drawing.DrawingManager({
                    map:this._map,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        drawingModes: []
                    },
                    //This settings only apply to entities created with
                    //the drawing API, not when creating manually.
                    markerOptions: { draggable:true, zIndex:50 }
                });
                this._setupDrawingListeners();
                this._removeStopDrawingButton();
                //Add the fullscreen control.
                this._addFullscreenButton();
                // Add the import file input validator
                this.querySelector('#fileUploadValidator').validate = this._validateFile.bind(this);
                //Maintain the isZoneSelected toggle for updating the UI.
                this._isZoneSelected = false;
                this.addEventListener('voyent-alert-zone-selected',function(e) {
                    _this.set('_isZoneSelected',!!e.detail.id);
                    //When zone's are selected we will bring their name overlay to the top
                    var selectedZone = e.detail.zone;
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        var zones = this._loadedAlert.template.zoneStacks[i].zones;
                        for (var j=0; j<zones.length; j++) {
                            if (zones[j].nameOverlay) {
                                if (selectedZone) {
                                    if (zones[j] === selectedZone) {
                                        zones[j].nameOverlay.moveToTopPane();
                                        zones[j].shapeOverlay.setOptions( { zIndex: 50 });
                                        continue;
                                    }
                                }
                                zones[j].nameOverlay.moveToDefaultPane();
                                zones[j].shapeOverlay.setOptions( { zIndex: zones[j].zIndex });
                            }
                        }
                    }
                    // Pan the map automatically based on zone selection
                    if (selectedZone) {
                        selectedZone === this._fallbackZone
                            ? _this._adjustBoundsAndPan(true)
                            : _this._panToZone(selectedZone);
                    }
                    else {
                        _this._adjustBoundsAndPan(this._fallbackZone && this._fallbackZone.enabled);
                    }
                });
                this.addEventListener('voyent-alert-zone-added',function(e) {
                    if (e.detail.isFallbackZone) {
                        _this._adjustBoundsAndPan(true);
                    }
                });
                this.addEventListener('voyent-alert-zone-removed',function() {
                    _this._adjustBoundsAndPan();
                });
            }
            // Listen for map zoom level changes
            this._addZoomChangedListener();
            this._maxZoom = 17; //The maximum amount we will zoom when panning the map in certain cases.
            this._manageMaxZoomLevel(); //Ensure we always have imagery in satellite view modes.
            this._regionMapping = {}; //Map of region data so we can toggle between them.
            this._isLoggedIn = false; //Toggle for side panel.
            //Custom initialization for each component after login.
            if (voyent.auth.isLoggedIn()) {
                this._onAfterLogin();
            }
            else {
                //We only want to do this on initial login and not access_token refreshes so we'll
                //save a reference to the listener so we can remove it the first time it fires.
                var onAfterLoginListener = function() {
                    _this._onAfterLogin();
                    window.removeEventListener('voyent-login-succeeded',onAfterLoginListener);
                };
                window.addEventListener('voyent-login-succeeded',onAfterLoginListener);
            }
            //Make sure the map is always sized correctly when the window size changes.
            window.addEventListener('resize', function() {
                _this._resizeMapAndAdjustBounds();
            });
            //Make sure the map is always sized correctly when the map size changes.
            new ResizeObserver(function() {
                // If we have a center coordinate for the map then it means we are toggling fullscreen mode and
                // want to maintain that position so we'll skip this listener and manage the map bounds manually
                if (_this._mapCenterPosition) {
                    return;
                }
                var newWidth = _this.querySelector('#map').offsetWidth;
                var newHeight = _this.querySelector('#map').offsetHeight;
                var currentObserverTime = new Date().getTime();
                // The ResizeObserver sometimes fires when the map dimensions have not changed or when the map is not
                // visible (dimensions of 0) so we will ignore these events. Additionally, ignore any events which were
                // fired within the last 250ms to prevent the map from resizing recursively (VRAS-650).
                if ((_this._previousMapWidth === newWidth && _this._previousMapHeight === newHeight) ||
                    (newWidth === 0 || newHeight === 0) ||
                    currentObserverTime - _this._previousObserverTime < 250) {
                    return;
                }
                _this._previousMapWidth = newWidth;
                _this._previousMapHeight = newHeight;
                _this._previousObserverTime = new Date().getTime();
                _this._resizeMapAndAdjustBounds();
            }).observe(this.querySelector('#map'));
            //De-select any selected zone stack on map click.
            this._deselectStacksOnClick(this._map);
            //Create a general use OverlayView object that so we can access some of its utility functions.
            this._overlayView = new google.maps.OverlayView();
            this._overlayView.draw = function() {};
            this._overlayView.setMap(this._map);
        },

        /**
         * Initializes map listeners that track the position of vertices while they are
         * dragged and updates the polygon distance-to-center overlay in real time.
         * @private
         */
        _setupMapListeners: function() {
            var _this = this;
            if (this._isAnAlertEditor()) {
                var mapDiv = this._map.getDiv(), stack;
                if (mapDiv) {
                    mapDiv.addEventListener('mousemove', function(e) {
                        var mouseLatLng = _this._fromMouseEventToLatLng(e);
                        if (_this._activelyMovingVertex) {
                            stack = _this._activeVertexDetails.zone.getParentStack();
                            // For the innermost zone we must consider that the position
                            // of the marker may change as the vertex is dragged
                            if (_this._activeVertexDetails.zone === stack.getInnermostZone()) {
                                // Clone the paths of the zone so we can calculate the new centroid
                                var paths = new google.maps.MVCArray([new google.maps.MVCArray(_this._activeVertexDetails.zone.shapeOverlay.getPaths().getAt(0).getArray().slice(0))]);
                                // Adjusted the paths to include the new vertex position
                                paths.getAt(0)[_this._activeVertexDetails.type](_this._activeVertexDetails.index, mouseLatLng);
                                // Update the marker position and update the coordinate overlay
                                stack.marker.setPosition(_this._AlertTemplate.calculateCentroidFromPaths(paths));
                                stack.updateLatLngFromMarker();
                            }
                            _this._activeVertexDetails.zone.managePolygonDistanceBetweenPointsOverlay(true, mouseLatLng);
                        }
                    });
                    // Disable the vertex drag operation if the user mouses up anywhere so
                    // it catches all cases (inside or outside the map, over an overlay, etc...)
                    document.addEventListener('mouseup', function() {
                        _this._activelyMovingVertex = false;
                    });
                }
            }
        },

        /**
         * Saves or updates the current alert.
         */
        saveAlert: function() {
            this._saveAlert().catch(function(e){})
        },

        /**
         * Wrapped function for `saveAlert` that returns a Promise for internal component use.
         * @returns {Promise}
         * @private
         */
        _saveAlert: function() {
            var _this = this, msg;
            return new Promise(function (resolve, reject) {
                if (_this._savingAlert) { return reject('already saving alert'); }
                _this._savingAlert = true;

                //Pull the latest JSON from each of the stacks
                _this._loadedAlert.template.updateJSON();
                var requestOpts = {
                    realm: _this.realm,
                    account: _this.account,
                    alert:_this._loadedAlert.template.json,
                    coordinates:_this._buildAlertLocationJSON().location.geometry.coordinates
                };
                var func = 'createAlert';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlert';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlert = false;
                    if (func === 'createAlert') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    //Adjust message based on the component making the request and whether we are saving an alert as a template.
                    _this.fire('message-error', 'Issue saving alert: ' + (e.responseText || e.message || e));
                    _this._savingAlert = false;
                    reject(msg);
                });
            });
        },

        /**
         * Returns preview data via a Promise for the currently loaded alert.
         * @returns {Promise}
         */
        previewAlert: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this._loadedAlert || !_this._loadedAlert.template) {
                    _this.fire('message-error', 'Unable to preview alert: No alert loaded');
                    return reject();
                }
                var promises = [];
                var event = _this._buildPreviewEvent();
                promises.push(voyent.action.executeModule({
                    "id":"alert-moved-notify-for-zones",
                    "params":{
                        "moduleParams": {
                            "synchronous": true
                        },
                        "_eventMessage": event
                    }
                }));
                promises.push(voyent.action.executeModule({
                    "id":"alert-moved-notify-social-media",
                    "params":{
                        "moduleParams": {
                            "synchronous": true,
                            "isPreview": true
                        },
                        "_eventMessage": event
                    }
                }));
                Promise.all(promises).then(function(moduleResults) {
                    var previewMetrics = moduleResults[0];
                    var socialMediaStatuses = moduleResults[1];

                    if (!previewMetrics.summary) {
                        previewMetrics.summary = {};
                    }
                    if (socialMediaStatuses.summary) {
                        previewMetrics.summary.facebookWillNotify = !!(socialMediaStatuses.summary.facebookWillNotify);
                        previewMetrics.summary.twitterWillNotify = !!(socialMediaStatuses.summary.twitterWillNotify);
                    }
                    else {
                        previewMetrics.summary.facebookWillNotify = false;
                        previewMetrics.summary.twitterWillNotify = false;
                    }
                    for (var i=0; i<previewMetrics.zoneMetrics.length; i++) {
                        var currentZone = socialMediaStatuses.zones ? socialMediaStatuses.zones[previewMetrics.zoneMetrics[i].id] : null;
                        if (currentZone) {
                            previewMetrics.zoneMetrics[i].facebookWillNotify = !!(currentZone.facebookWillNotify);
                            previewMetrics.zoneMetrics[i].twitterWillNotify = !!(currentZone.twitterWillNotify);
                        }
                        else {
                            previewMetrics.zoneMetrics[i].facebookWillNotify = false;
                            previewMetrics.zoneMetrics[i].twitterWillNotify = false;
                        }
                    }
                    resolve(previewMetrics);
                }).catch(function(e) {
                    console.error(e);
                    _this.fire('message-error','Unable to preview alert, try again later.');
                    reject(e);
                });
            });
        },

        /**
         * Fabricates a location create event so we can generate preview metrics.
         * @returns Object {}
         * @private
         */
        _buildPreviewEvent: function() {
            this._loadedAlert.template.updateJSON();
            var json = this._loadedAlert.template.json;

            json.state = 'preview';

            var alertId = this._loadedAlert.template.id || 'preview';
            var alertFamilyId = this._loadedAlert.template.alertFamilyId || this._generateUid();

            var currentLocation = this._buildAlertLocationJSON().location;
            if (!currentLocation.properties.alertId) {
                currentLocation.properties.alertId = alertId;
            }
            if (!json.properties.alertFamilyId) {
                json.properties.alertFamilyId = alertFamilyId;
            }

            // Add the activatedBy property as it's required for the social-media module.
            json.activatedBy = voyent.auth.getLastKnownUsername();

            return {
                "time": new Date().toISOString(),
                "account": this.account,
                "realm": this.realm,
                "service": "locate",
                "event": "create",
                "type": "location",
                "username": voyent.auth.getLastKnownUsername(),
                "tx": "",
                "data": {
                    "resourceId": alertId,
                    "origin": window.location.hostname,
                    "previousLocation": {}, //This isn't being used by the modules currently so don't bother including it.
                    "currentLocation": currentLocation,
                    "alert": json,
                    "alertId" : alertId,
                    "alertFamilyId":alertFamilyId
                }
            };
        },

        /**
         * Returns a list of zone ids sorted by stack from west to east and then from
         * innermost to outermost zone within each stack. Excludes the fallback zone.
         * @returns []
         */
        getSortedZoneIds: function() {
            var sortedZoneIds = [];
            var zoneStacks = this._loadedAlert && this._loadedAlert.template && this._loadedAlert.template.zoneStacks;
            if (zoneStacks && zoneStacks.length) {
                var stackData = [];
                for (var i=0; i<zoneStacks.length; i++) {
                    var zoneData = [];
                    // Build a list of zones sorted from outermost to innermost
                    for (var j=zoneStacks[i].zones.length-1; j>=0; j--) {
                        var zone = zoneStacks[i].zones[j];
                        zoneData.push({
                            id: zone.id,
                            lat: this._AlertZone.getBoundingBox(zone).getNorthEast().lat()
                        });
                    }
                    // Build a list of stacks
                    stackData.push(zoneData);
                }
                // Sort the stacks from north to south. Since the zones within each stack are already
                // sorted from outermost to innermost we will get the outermost zone by selecting
                // the first zone and use that to determine the order of the stacks. This also means
                // that we don't need to sort the list of zones further since they will already
                // be sorted by stack from north to south and zone by outermost to innermost.
                stackData.sort(function(a, b) {
                    return b[0].lat - a[0].lat;
                });
                // Build an array of zone ids grouped by stack and then flatten the arrays to a simple list of zone ids.
                // We used to use .flat() but this is not supported in Edge so we will use reduce/contact instead
                sortedZoneIds = stackData.map(function(zonesForStack) {
                    return zonesForStack.map(function(zoneObj) {
                        return zoneObj.id;
                    });
                });
                sortedZoneIds = sortedZoneIds.reduce(function (arr, val) {
                    return arr.concat(val);
                }, []);
            }
            return sortedZoneIds;
        },

        /**
         * Waits up to 5 seconds for an alert to be loaded and then resolves with the response from getSortedZoneIds.
         * @returns {Promise}
         */
        getSortedZoneIdsWhenReady: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this._waitForCondition(
                    function() {
                        return !!(_this._loadedAlert && _this._loadedAlert.template);
                    },
                    5000
                ).then(function() {
                    resolve(_this.getSortedZoneIds());
                }).catch(function() {
                    reject();
                });
            });
        },

        /**
         * Returns a JSON representation of the currently loaded alert.
         * @returns {*}
         */
        getCurrentAlert: function() {
            if (this._loadedAlert && this._loadedAlert.template) {
                this._loadedAlert.template.updateJSON();
                return this._loadedAlert.template.json;
            }
            return null;
        },

        /**
         * Returns the id of the currently loaded alert.
         * @returns {*}
         */
        getCurrentAlertId: function() {
            if (this._loadedAlert && this._loadedAlert.template) {
                return this._loadedAlert.template.id;
            }
            return null;
        },

        /**
         * Get the coordinates of the the loaded alert's current position in the format [lng,lat].
         * @returns {Array}
         */
        getCurrentCoordinates: function() {
            if (this._loadedAlert && this._loadedAlert.template) {
                this._loadedAlert.template.updateJSON();
                return this._buildAlertLocationJSON().location.geometry.coordinates;
            }
            return null;
        },

        /**
         * Disables fullscreen mode if it is enabled.
         */
        disableFullscreenMode: function() {
            // Always leave the view as a windowed component
            if (this._isFullscreenMode) {
                this._toggleFullscreenContainer();
            }
        },

        /**
         * Clears the map entirely. In the case of alert editor the list of templates will also be refreshed.
         */
        clearMap: function() {
            var _this = this;
            // Always leave the view as a windowed component
            this.disableFullscreenMode();
            // Don't zoom on region when clearing map on alert detail view as
            // this causes some jerky pan behaviour when viewing an alert
            if (!this._isAlertView()) {
                this._zoomOnRegion();
            }
            // Clear loaded alert template
            if (this._loadedAlert || this._fallbackZone) {
                this._removeAlertTemplateFromMap();
            }
            // Clear the user marker and locations
            if (this._isAlertView()) {
                if (this._myLocations) {
                    this._clearMyLocations();
                }
            }
            if (this._isAnAlertEditor()) {
                // Disable drawing mode for alert editors
                this._disableDrawingMode();
                if (this._isAlertEditor()) {
                    this._enableDefaultPane();
                    this._showMovement = false;
                    // Clear the movement inputs, async so the side panel has time to render
                    setTimeout(function() {
                        _this._alertDirection = _this._alertSpeed = null;
                        _this._alertSpeedUnit = 'kph';
                    },0);
                }
            }
        },

        /**
         * Opens a dialog for choosing alert badges.
         */
        chooseAlertBadge: function() {
            var _this = this;
            this._openDialog('Choose Alert Badge',null,null,null,null,true,false,function() {
                // Persist our choice to the template JSON
                _this._loadedAlert.template.setBadge(_this._dialogBadge);
                // Update the badge icon for any image overlays
                var zoneStacks = _this._loadedAlert.template.zoneStacks;
                for (var i=0; i<zoneStacks.length; i++) {
                    if (zoneStacks[i].badgeOverlay) {
                        zoneStacks[i].badgeOverlay.updateImgUrl(_this.getBadgeUrl(_this._loadedAlert.template.badge));
                    }
                }
                // Fire an event that the badge changed
                _this.fire('voyent-alert-badge-changed', {"badge": _this._loadedAlert.template.badge});
            });
        },

        /**
         * Sets the alert schedule into the loaded template.
         * @param schedule
         */
        setSchedule: function(schedule) {
            if (!this._loadedAlert || !this._loadedAlert.template) { return; }
            this._loadedAlert.template.setSchedule(schedule);
        },

        /**
         * Sets the message template into the zone associated with the stack and zone indices.
         * @param messageTemplate
         * @param zoneIndex
         * @param stackIndex
         */
        setMessageTemplate: function(messageTemplate, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].messageTemplate = messageTemplate;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].messageTemplate = messageTemplate;
                }
            }
        },

        /**
         * Sets the notification filter into the zone associated with the stack and zone indices.
         * @param notificationFilter
         * @param zoneIndex
         * @param stackIndex
         */
        setNotificationFilter: function(notificationFilter, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].notificationFilter = notificationFilter;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].notificationFilter = notificationFilter;
                }
            }
        },

        /**
         * Gets the notification filter for the zone associated with the stack and zone indices.
         * @param zoneIndex
         * @param stackIndex
         */
        getNotificationFilter: function(zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    return this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].notificationFilter;
                }
                else {
                    return this._loadedAlert.selectedStack.zones[zoneIndex].notificationFilter;
                }
            }
            return null;
        },

        /**
         * Sets the acknowledgement property into the zone associated with the stack and zone indices.
         * @param acknowledgement
         * @param zoneIndex
         * @param stackIndex
         */
        setAcknowledgement: function(acknowledgement, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].acknowledgement = acknowledgement;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].acknowledgement = acknowledgement;
                }
            }
        },

        /**
         * Gets the acknowledgement property for the zone associated with the stack and zone indices.
         * @param zoneIndex
         * @param stackIndex
         */
        getAcknowledgement: function(zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    return this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].acknowledgement;
                }
                else {
                    return this._loadedAlert.selectedStack.zones[zoneIndex].acknowledgement;
                }
            }
            return null;
        },

        /**
         * Updates the zone name associated with the stack and zone indices.
         * @param zoneName
         * @param zoneIndex
         * @param stackIndex
         */
        setZoneName: function(zoneName,zoneIndex,stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].setName(zoneName);
                    //Redraw the overlay since the content changed.
                    if (this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].nameOverlay) {
                        this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].nameOverlay.draw();
                    }
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].setName(zoneName);
                    //Redraw the overlay since the content changed.
                    if (this._loadedAlert.selectedStack.zones[zoneIndex].nameOverlay) {
                        this._loadedAlert.selectedStack.zones[zoneIndex].nameOverlay.draw();
                    }
                }
            }
        },

        /**
         * Sets the message template for the fallback zone.
         * @param messageTemplate
         */
        setFallbackMessageTemplate: function(messageTemplate) {
            if (this._fallbackZone) {
                this._fallbackZone.messageTemplate = messageTemplate;
            }
        },

        /**
         * Sets the notification filter for the fallback zone.
         * @param notificationFilter
         */
        setFallbackNotificationFilter: function(notificationFilter) {
            if (this._fallbackZone) {
                this._fallbackZone.notificationFilter = notificationFilter;
            }
        },

        /**
         * Gets the notification filter for the fallback zone.
         */
        getFallbackNotificationFilter: function() {
            if (this._fallbackZone) {
                return this._fallbackZone.notificationFilter;
            }
            return null;
        },

        /**
         * Sets the acknowledgement property for the fallback zone.
         * @param acknowledgement
         */
        setFallbackAcknowledgement: function(acknowledgement) {
            if (this._fallbackZone) {
                this._fallbackZone.acknowledgement = acknowledgement;
            }
        },

        /**
         * Gets the acknowledgement property for the fallback zone.
         */
        getFallbackAcknowledgement: function() {
            if (this._fallbackZone) {
                return this._fallbackZone.acknowledgement;
            }
            return null;
        },

        /**
         * Updates the zone name for the fallback zone.
         * @param zoneName
         */
        setFallbackZoneName: function(zoneName) {
            if (this._fallbackZone) {
                this._fallbackZone.setName(zoneName);
                // Redraw the overlay since the content changed
                if (this._fallbackZone.nameOverlay && this._fallbackZone.enabled) {
                    this._fallbackZone.nameOverlay.displayAndDraw();
                    //this.nameOverlay.draw();
                }
            }
        },

        //******************PRIVATE API******************

        /**
         * Fetches the region boundary for the realm.
         * @returns {Promise}
         * @private
         */
        _fetchRealmRegion: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findRegions({realm:_this.realm, account:_this.account,
                                           query:{"_id":_this.realm+"_region"}
                }).then(function (regions) {
                    if (!regions || !regions[0]) { return resolve(); }
                    //Filter out the alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches an alert template that matches the passed id.
         * @param id
         * @private
         */
        _fetchAlertTemplate: function(id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findAlertTemplates({
                    realm: this.realm,
                    account: this.account,
                    query: {"_id":id}
                }).then(function (results) {
                    if (!results || !results.length) {
                        if (_this._isAlertView()) {
                            return resolve(null);
                        }
                        _this.fire('message-error', 'Alert template not found');
                        return reject('Alert template not found');
                    }
                    resolve(results[0]);
                }).catch(function (error) {
                    _this.fire('message-error', 'Error fetching alert template: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches alert template categories from realm scope and builds an object array from the results.
         */
        _fetchTemplateCategories: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.set('_templateCategories',[]);
                _this.set('_filteredTemplateCategories',[]);
                voyent.scope.getRealmData({"property":"templateCategories"}).then(function (categories) {
                    if (categories && categories.length) {
                        //Build an object array to simplify template logic for category editing.
                        _this.set('_templateCategories',categories.map(function(categoryName) {
                            return {
                                "id": _this._generateUid(), //This is will be used to find the associated category name input for editing validation
                                "name": categoryName,
                                "editable": true,
                                "newName": '',
                                "editing": false
                            }
                        }));
                    }
                    //Always add the "Mobile" category but we'll be sure not to persist this.
                    _this.push('_templateCategories',{
                        "id": _this._generateUid(),
                        "name": 'Mobile',
                        "editable": false
                    });
                    //Add the "Sample" category if the realm has permission to add new sample templates.
                    if (_this._isVrasAdministratorRealm) {
                        _this.push('_templateCategories',{
                            "id": _this._generateUid(),
                            "name": 'Sample',
                            "editable": false
                        });
                    }
                    _this.set('_filteredTemplateCategories',_this._templateCategories.slice(0));
                    resolve(_this._templateCategories);
                }).catch(function (error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches the most recent User or alert location depending on whether we are passed an alertId.
         * @param alertId
         * @private
         */
        _fetchLocationRecord: function(alertId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var query = {};
                if (alertId && typeof alertId === 'string') {
                    query = {"location.properties.alertId":alertId};
                }
                else {
                    query = {
                        "location.properties.alertId": {"$exists":false},
                        "location.properties.vras.type": "mobile"
                    };
                    query.username = voyent.auth.getLastKnownUsername();
                }
                //Only get the last location.
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,query:query,
                    options:{"sort":{"lastUpdated":-1},"limit":1}}).then(function(location) {
                    //Only error out for alerts.
                    if (alertId) {
                        if ((!location || !location[0])) {
                            if (_this._isAlertView()) {
                                return resolve(null);
                            }
                            return reject('Alert location cannot be found');
                        }
                    }
                    else {
                        if ((!location || !location[0])) {
                            return resolve();
                        }
                    }
                    resolve(location[0]);
                }).catch(function(error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches existing fixed location records, groups them by id and keeps only the latest.
         * @returns {Promise}
         * @private
         */
        _fetchMyLocations: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.action.executeModule({
                    id: 'get-locations',
                    params: {
                        username: voyent.auth.getLastKnownUsername()
                    }
                }).then(function(locations) {
                    if (_this._isMyLocations()) {
                        //Clear the map and draw the locations.
                        _this._loadedLocation = null;
                        _this._clearMyLocations();
                        _this._drawMyLocations(locations);
                    }
                    else {
                        locations = locations.map(function(obj) {
                            return obj.location;
                        })
                    }
                    resolve(locations);
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching location records: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed locations on the map.
         * @param locations
         * @private
         */
        _drawMyLocations: function(locations) {
            for (var i=0; i<locations.length; i++) {
                this.push('_myLocations',new this._MyLocation(
                    locations[i].location.properties.vras.id,
                    locations[i].location.properties.vras.name,
                    locations[i].location.properties.vras.type,
                    new google.maps.Marker({
                        position: new google.maps.LatLng(
                            locations[i].location.geometry.coordinates[1],
                            locations[i].location.geometry.coordinates[0]
                        ),
                        map: this._map,
                        draggable: this._isMyLocations(),
                        icon: this._MY_LOCATION_ICON_INACTIVE
                    })
                ));
            }
        },

        /**
         * Clears the map of all drawn locations.
         * @private
         */
        _clearMyLocations: function() {
            for (var i=0; i<this._myLocations.length; i++) {
                this._myLocations[i].removeFromMap();
            }
            this.set('_myLocations',[]);
        },

        /**
         * Draws the passed region on the map as an invisible polygon. We'll use the polygon
         * for setting the map bounds or favouring autocomplete results to it's area.
         * @param region - The region to be drawn, in GeoJSON format.
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path;
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j=0; j<coords.length; j++) {
                path = [];
                for (var k=0; k<coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    bounds.extend(googlePoint);
                }
                paths.push(path);
            }
            var polygon;
            //If we have an existing polygon then just modify it.
            if (this._areaRegion && this._areaRegion.polygon) {
                polygon = this._areaRegion.polygon;
                polygon.setPaths(paths);
            }
            else {
                //Create the invisible polygon object.
                polygon = new google.maps.Polygon({
                    paths: paths, map: this._map, visible: false
                });
            }
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon,"bounds":bounds};
            this._regionMapping[this.realm] = this._areaRegion;
            //Pan the map on the new region but only if we haven't already loaded an alert in one of
            //our editors, otherwise the map will pan to the alert and then snap back to the region.
            if ((!this._isAlertEditor() || !this.isAlertLoaded) &&
                (!this._isAlertTemplateEditor() || !this.isTemplateLoaded) &&
                (!this._isMobileAlertEditor() || !this.isAlertLoaded)) {
                this._zoomOnRegion();
            }
        },

        /**
         * Zooms on the realm region.
         * @private
         */
        _zoomOnRegion: function() {
            if (this._areaRegion && this._areaRegion.bounds && !this._skipRegionPanning) {
                this._map.fitBounds(this._areaRegion.bounds);
                this._map.panToBounds(this._areaRegion.bounds);
            }
        },

        /**
         * Draws the passed alert or alert template on the map.
         * @param templateJSON - The JSON to build the alert template from.
         * @param latLngCentroid - An optional LatLng object specifying the centroid of the template. When this is not
         *                         provided we will calculate the centroid based on the template's stack coordinates.
         * @param maintainMapState - Set to true to not pan or zoom the map after finishing
         * @private
         */
        _drawAndLoadAlertTemplate: function(templateJSON,latLngCentroid,maintainMapState) {
            var _this = this;
            var properties, zoneGeometries, zones, zoneStacks = [], zIndex,
                haveStackFromFile, currentStackFromFile, foundZoneIdMatch = false;
            // Add the zone stacks if we have a geo property. Without this it means we only have the fallback zone defined
            if (templateJSON.geo) {
                var zoneStackGeometries = templateJSON.geo.geometries.reduce(function(stackGroups, item) {
                    // If the user was notified by any zone within a stack (we have an affectedStackId)
                    // then we will only draw the affected stack on the map so discard all others
                    if (_this._isAlertView() &&
                        _this.mode === 'notification' && _this._affectedStackId &&
                        _this._affectedStackId !== item.stackId) {
                        return stackGroups;
                    }
                    stackGroups[item.stackId] = stackGroups[item.stackId] || [];
                    stackGroups[item.stackId].push(item);
                    return stackGroups;
                },{});
                for (var stackId in zoneStackGeometries) {
                    zoneGeometries = zoneStackGeometries[stackId];
                    zones = [];
                    zIndex = 49;
                    currentStackFromFile = false;
                    for (var i=0; i<zoneGeometries.length; i++) {
                        properties = templateJSON.properties[zoneGeometries[i].id];
                        if (zoneGeometries[i].fromFile) {
                            currentStackFromFile = zoneGeometries[i].fromFile;
                            haveStackFromFile = true;
                        }
                        if (this._isAlertView()) {
                            // For alert detail notification view only show the inner zone of each relevant stack.
                            // The relevant stacks are determined above when building the zoneStackGeometries list
                            if (this.mode === 'notification') {
                                if (i >= 1) { break; }
                            }
                            // For all other alert detail modes only show the requested zone, if available
                            else if (this._zoneIdToDisplay) {
                                if (this._zoneIdToDisplay === zoneGeometries[i].id) {
                                    foundZoneIdMatch = true;
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                        // Generate the ordered sequence of coordinates that completes the Polygon shape.
                        zones.push(new this._AlertZone(
                            zoneGeometries[i].id, properties.name,
                            this._AlertTemplate.calculatePathsFromCoordinates(zoneGeometries[i].coordinates),
                            properties.shape === 'circle', properties.opacity, properties.colour,
                            properties.messageTemplate, properties.notificationFilter,
                            properties.acknowledgement, zIndex, properties.fromFile)
                        );
                        if (this._isAlertView()) {
                            //Add click listener to the zone so the user can click anywhere on the map to enable fullscreen.
                            this._addFullscreenClickListener(zones[zones.length-1].shapeOverlay);
                        }
                        zIndex--;
                        // Exit if we found a match for the only zone we are looking for
                        if (foundZoneIdMatch) {
                            break;
                        }
                    }
                    //Build the stack marker, calculate the position using by building JSON that represents only the stack.
                    if (zones.length) {
                        zoneStacks.push(new this._AlertZoneStack(stackId, zones, currentStackFromFile));
                    }
                }
            }

            var parentId = templateJSON.properties.parentAlertId || null;
            var alertFamilyId = templateJSON.properties.alertFamilyId || null;
            //We only want to create a template marker if we have more than
            //one stack, otherwise the stack marker will just be used.
            var templateMarker;
            if (zoneStacks.length > 1) {
                templateMarker = new google.maps.Marker({
                    position: (latLngCentroid ? latLngCentroid : this._AlertTemplate.calculateCentroidFromJSON(templateJSON)),
                    map: this._map, draggable: true, zIndex: 50,
                    icon: this.pathtoimages+'/img/move_icon.png',
                    cursor: 'move', visible: false
                });
            }
            this.set('_loadedAlert', {
                template: new this._AlertTemplate(
                    templateJSON._id, parentId, alertFamilyId, templateJSON.name, templateJSON.badge,
                    templateMarker, zoneStacks, templateJSON.state, !!templateJSON.properties.center,
                    templateJSON.schedule, templateJSON.categories
                ),
                selectedStack: zoneStacks.length === 1 ? zoneStacks[0] : null
            });
            // If the template has one or more stacks that were created from a file import
            // then we will always force the position to be saved with the template
            this._loadedAlert.template.forceSavePositionWithTemplate(haveStackFromFile);
            //If we were provided a centroid for the template then we need to move the centroid of the zones from the current
            //position to the new one. To do this we will first calculate their current position based on the template and then
            //move them to the new coordinate while maintaining the distance and bearing they were from the original position.
            if (latLngCentroid) {
                this._loadedAlert.template.calculateRelativeStackPositions(this._AlertTemplate.calculateCentroidFromJSON(templateJSON));
                this._loadedAlert.template.moveStacksRelativeToPosition(latLngCentroid, true);
                //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                this._loadedAlert.template.initializePolygonStackPathListeners();
            }
            // Process the fallback zone. A few different conditionals here of when we initialize it:
            // 1) When we are not using the alert view component we will initialize it if it is enabled or
            //    we have properties other than enabled set since it may be disabled but with saved state
            // 2) When we are viewing a notification detail and the fallback zone is the only zone in the alert
            // 3) When we are using the alert view in view, preview, or response mode and are displaying all
            //    zones or only the fallback
            var fallbackZoneProperties = templateJSON.properties[this._FALLBACK_ZONE_ID];
            if ((!this._isAlertView() && (fallbackZoneProperties.enabled || fallbackZoneProperties.name)) ||
                (this.mode === 'notification' && fallbackZoneProperties.enabled && !zoneStacks.length) ||
                (this.mode !== 'notification' && (!this._zoneIdToDisplay || this._zoneIdToDisplay === this._FALLBACK_ZONE_ID))) {
                this._fallbackZone = new this._FallbackAlertZone(
                    fallbackZoneProperties.enabled,
                    fallbackZoneProperties.name,
                    fallbackZoneProperties.opacity,
                    fallbackZoneProperties.colour,
                    fallbackZoneProperties.messageTemplate,
                    fallbackZoneProperties.notificationFilter,
                    fallbackZoneProperties.acknowledgement,
                    fallbackZoneProperties.zIndex
                );
            }
            if (!maintainMapState && this.mode !== 'notification') {
                // Pan the map but ensure the area region is available first. Fixes an issue with
                // the map doesn't pan properly on initial load for fallback zone only alerts
                this._areaRegionIsAvailable().then(function() {
                    _this._adjustBoundsAndPan();
                });
            }
        },

        /**
         * Initialize the listeners for drawing a new alert template on the map.
         * @private
         */
        _setupDrawingListeners: function() {
            var _this = this, zone;
            google.maps.event.addListener(this._drawingManager, 'overlaycomplete', function (oce) {
                //We do this async so the _drawingCancelled property has time to be applied. This allows
                //the user to toggle the drawing mode off mid-draw by clicking the draw button.
                setTimeout(function() {
                    if (_this._drawingCancelled) {
                        oce.overlay.setMap(null);
                        _this.set('_drawingCancelled',false);
                        return;
                    }
                    var paths;
                    if (oce.type === 'circle') {
                        // Ensure the circle is valid since if the user clicks immediately rather than
                        // sizing the shape then it will have a radius of 0 and will break the editor
                        if (!oce.overlay.getRadius()) {
                            oce.overlay.setRadius(1);
                        }
                        paths = _this._AlertTemplate.calculatePathsFromCircleProperties(oce.overlay.getCenter(),oce.overlay.getRadius());
                    }
                    else { //polygon
                        paths = oce.overlay.getPaths();
                    }
                    //Check if they drew a self-intersecting polygon and if so remove it from the map and notify them.
                    if (oce.type === 'polygon') {
                        var kinks = turf.kinks({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": _this._AlertTemplate.calculateCoordinatesFromPaths(paths)
                            }
                        });
                        if (kinks.features.length) {
                            _this.fire('message-error','The zone cannot self-intersect');
                            oce.overlay.setMap(null);
                            return;
                        }
                    }
                    _this._openDialog('Add New Zone','Enter the zone name','','Must provide a zone name',null,false,false,function() {
                        if (oce.type === 'polygon' && _this._drawingCancelled) {
                            // If cancelled via esc, Google will still draw the
                            // polygon so we need to remove it from the map
                            oce.overlay.setMap(null);
                            _this._drawingCancelled = false;
                            return;
                        }
                        zone = new _this._AlertZone(null,_this._dialogInput,paths,oce.type === 'circle');

                        var zoneStack = new _this._AlertZoneStack(null, [zone], false);
                        //Add the stack and fire the zone added event.
                        _this._loadedAlert.template.addZoneStack(zoneStack);
                        _this.fire('voyent-alert-zone-added',{"id":zone.id,"zone":zone,"stack":zoneStack,"insertIndex":0,"isFallbackZone":false});
                        // Load the new stack / zone
                        _this._selectZone(zoneStack, zone);
                        //When we have only one stack we don't have a template marker, just the marker for the zone stack.
                        //So once we have two zone stacks we need to create the marker and if we have more than two (the
                        //marker exists already) then we'll update it's position.
                        if (_this._loadedAlert.template.zoneStacks.length === 2) {
                            _this._loadedAlert.template.setMarker(new google.maps.Marker({
                                position: _this._AlertTemplate.calculateCentroidFromJSON(_this._loadedAlert.template.json),
                                map: _this._map, draggable: true, zIndex: 50,
                                icon: _this.pathtoimages+'/img/move_icon.png',
                                cursor: 'move', visible: false
                            }));
                        }
                        else if (_this._loadedAlert.template.zoneStacks.length > 2) {
                            _this._loadedAlert.template.updateJSONAndCentroid();
                        }
                        //To keep things simple we'll always use our custom classes for
                        //drawing the shapes so remove the google-drawn shape from the map.
                        oce.overlay.setMap(null);
                        //Re-punch out the fallback zone.
                        if (_this._fallbackZone) {
                            _this._fallbackZone.punchOutOverlay();
                        }
                        _this._disableDrawingMode();
                    },function() {
                        oce.overlay.setMap(null);
                        _this.set('_drawingCancelled',false);
                    });
                },0);
            });
            //When the escape key is pressed exit drawing mode.
            window.addEventListener('keydown', function (e) {
                // Ensure we only process the listener if the component is visible
                if (_this.visible && e.key === 'Escape') {
                    var drawingMode = _this._drawingManager.getDrawingMode();
                    if (drawingMode !== null) {
                        // Flag so overlaycomplete listener won't be allowed to proceed after
                        // cancelling a polygon mid-draw (not relevant for circles).
                        if (drawingMode === google.maps.drawing.OverlayType.POLYGON) {
                            _this._drawingCancelled = true;
                        }
                        _this._disableDrawingMode();
                    }
                    else if (_this._isFullscreenMode) {
                        _this._toggleFullscreenContainer();
                    }
                }
            });
        },

        /**
         * Clears the map of overlays associated with the currently loaded alert template.
         */
        _removeAlertTemplateFromMap: function() {
            //Remove the entire template from the map.
            if (this._loadedAlert) {
                this._loadedAlert.template.removeFromMap();
                this._loadedAlert = null;
            }
            if (this._fallbackZone) {
                this._fallbackZone.removeFromMap();
            }
        },

        /**
         * Determines the northern most coordinate of the passed coordinates array,
         * used to calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns []
         * @private
         */
        _determineNorthernCoordinate: function(coordinates) {
            var northernCoordinate =[-100,null,-100];
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > northernCoordinate[1]) {
                    northernCoordinate = coordinates[i];
                }
            }
            return northernCoordinate;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         * @private
         */
        _calcMapSize: function() {
            var _this = this;
            this._mapIsReady().then(function() {
                //Calculate and set the height
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (typeof height === 'undefined' || !height || height < 0) {
                        if (_this._isFullscreenMode) {
                            height = _this.querySelector('#'+_this._FULLSCREEN_CONTAINER_ID).clientHeight;
                        }
                        else {
                            height = _this._map.getDiv().parentElement.parentElement.parentElement.clientHeight;
                        }
                    }
                    //If we still don't have a valid height default to the last valid height or a 400px minimum
                    if (height < 50) {
                        height = _this._lastHeight > 50 ? _this._lastHeight : 400;
                    }
                }
                _this.customStyle['--map-height'] = height + 'px';
                _this._lastHeight = height;

                //Calculate and set the width
                var width = _this.width;
                //If the width is specified then set it
                if (typeof width === 'undefined' || !width || width < 0) {
                    if (_this._isAnAlertEditor()) {
                        width = (_this._map.getDiv().parentElement.offsetWidth - _this.querySelector('#'+_this._SIDE_PANEL_ID).offsetWidth);
                        //-20px for map borders and padding when not in fullscreen mode
                        if (!_this._isFullscreenMode) {
                            width -= 20;
                        }
                    }
                    else {
                        width = _this._map.getDiv().parentElement.offsetWidth;
                    }
                }
                //If we still don't have a valid width default to the last width or a 400px minimum
                if (width < 50) {
                    width = _this._lastWidth > 50 ? _this._lastWidth : 400;
                }
                _this.customStyle['--map-width'] = width + 'px';
                _this._lastWidth = width;

                //Apply the styles
                _this.updateStyles();
                //Update the position of any displayed tooltips.
                if (_this._tooltipsDisplayed) {
                    _this._repositionTooltips();
                }
            });
        },

        /**
         * Add the map type and zoom buttons (VRAS-671).
         * @private
         */
        _addMapControlButtons: function () {
            this._addZoomButton();
            this._addMapTypeButton();
        },

        /**
         * Adds the custom control for adjusting the zoom level.
         * @private
         */
        _addZoomButton: function () {
            var _this = this;
            // Since we have multiple buttons in a single control we'll add event
            // listeners to the desired elements after the button has been added
            this._addCustomControl(this._ZOOM_BUTTONS_ID, google.maps.ControlPosition.LEFT_TOP, null, function () {
                var newControl = _this['_' + _this._ZOOM_BUTTONS_ID];
                // Alert view map is readonly, so start with the control hidden
                if (_this._isAlertView()) {
                    newControl.style.display = 'none';
                }
                // Zoom in button
                newControl.querySelector('#zoomInBttn').onclick = function () {
                    _this._map.setZoom(_this._map.getZoom() + 1);
                };
                // Zoom out button
                newControl.querySelector('#zoomOutBttn').onclick = function () {
                    _this._map.setZoom(_this._map.getZoom() - 1);
                };
            });
        },

        /**
         * Adds the custom control for selecting the map type.
         * @private
         */
        _addMapTypeButton: function () {
            var _this = this;
            // Since we have multiple buttons in a single control we'll add event
            // listeners to the desired elements after the button has been added
            this._addCustomControl(this._MAP_TYPE_BUTTONS_ID, google.maps.ControlPosition.TOP_LEFT, null, function () {
                // We want to manage the state of the checkboxes separately from the current mode so
                // we can restore the previously set state when switching between Map and Satellite
                _this._mapTerrainEnabled = false;
                _this._mapPlacesEnabled = true;
                _this._satPlacesEnabled = true;
                var newControl = _this['_' + _this._MAP_TYPE_BUTTONS_ID];
                // Alert view map is readonly, so start with the control hidden.
                // The visibility of it will be toggled in `_toggleEditableMap`
                if (_this._isAlertView()) {
                    newControl.style.display = 'none';
                }
                // Map button
                newControl.querySelector('#mapBttn').onclick = function () {
                    // Don't do anything if a map mode is already enabled
                    if (_this._map.getMapTypeId() !== google.maps.MapTypeId.ROADMAP &&
                        _this._map.getMapTypeId() !== google.maps.MapTypeId.TERRAIN) {
                        // Ensure the correct map mode is enabled based on current state
                        _this._map.setMapTypeId(
                            _this._mapTerrainEnabled
                                ? google.maps.MapTypeId.TERRAIN
                                : google.maps.MapTypeId.ROADMAP
                        );
                        // Set the places icon visibility based on current state
                        _this._map.setOptions(
                            _this._mapPlacesEnabled
                                ? { styles: null }
                                : _this._getDisabledPlacesOptions()
                        );
                        // Update button state
                        _this._manageMapTypeButtonState(_this._map);
                    }
                };
                // Map > Terrain button
                newControl.querySelector('#mapTerrainBttn').onclick = function () {
                    if (_this._mapTerrainEnabled) {
                        // Hide terrain
                        _this._map.setMapTypeId(google.maps.MapTypeId.ROADMAP);
                        _this._mapTerrainEnabled = false;
                    }
                    else {
                        // Show terrain
                        _this._mapTerrainEnabled = true;
                        _this._map.setMapTypeId(google.maps.MapTypeId.TERRAIN);
                    }
                    // Update button state
                    _this._manageMapTypeButtonState(_this._map);
                };
                // Map > Places button
                newControl.querySelector('#mapPlacesBttn').onclick = function () {
                    // Ensure the correct map mode is enabled based on current state
                    if (_this._map.getMapTypeId() !== google.maps.MapTypeId.ROADMAP ||
                        _this._map.getMapTypeId() !== google.maps.MapTypeId.TERRAIN) {
                        _this._map.setMapTypeId(
                            _this._mapTerrainEnabled
                                ? google.maps.MapTypeId.TERRAIN
                                : google.maps.MapTypeId.ROADMAP
                        );
                    }
                    if (_this._mapPlacesEnabled) {
                        // Hide places icons
                        _this._map.setOptions(_this._getDisabledPlacesOptions());
                        _this._mapPlacesEnabled = false;
                    }
                    else {
                        // Show places icons
                        _this._map.setOptions({ styles: null });
                        _this._mapPlacesEnabled = true;
                    }
                    // Update button state
                    _this._manageMapTypeButtonState(_this._map);
                };
                // Satellite button
                newControl.querySelector('#satBttn').onclick = function () {
                    // Don't do anything if hybrid mode is already enabled
                    if (_this._map.getMapTypeId() !== google.maps.MapTypeId.HYBRID) {
                        // Ensure hybrid mode is enabled
                        _this._map.setMapTypeId(google.maps.MapTypeId.HYBRID);
                        // Set the places icon visibility based on current state
                        _this._map.setOptions(
                            _this._satPlacesEnabled
                                ? { styles: null }
                                : _this._getDisabledPlacesOptions()
                        );
                        // Update button state
                        _this._manageMapTypeButtonState(_this._map);
                    }
                };
                // Satellite > Places button
                newControl.querySelector('#satPlacesBttn').onclick = function () {
                    // Ensure hybrid mode is enabled
                    _this._map.setMapTypeId(google.maps.MapTypeId.HYBRID);
                    if (_this._satPlacesEnabled) {
                        // Hide places icons
                        _this._map.setOptions(_this._getDisabledPlacesOptions());
                        _this._satPlacesEnabled = false;

                    }
                    else {
                        // Show places icons
                        _this._map.setOptions({ styles: null });
                        _this._satPlacesEnabled = true;
                    }
                    // Update button state
                    _this._manageMapTypeButtonState(_this._map);
                };
            });
        },

        /**
         * Adds the button for creating new circular zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addCircleButton: function(listener,cb) {
            this._addCustomControl(this._CIRCLE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the button for creating new polygonal zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addPolygonButton: function(listener,cb) {
            this._addCustomControl(this._POLYGON_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the button for toggling the fallback zone.
         * @param listener
         * @param cb
         * @private
         */
        _addFallbackZoneButton: function(listener,cb) {
            this._addCustomControl(this._FALLBACK_ZONE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the button for opening the geospatial file import dialog.
         * @param listener
         * @param cb
         * @private
         */
        _addImportFileButton: function(listener,cb) {
            this._addCustomControl(this._IMPORT_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the circle, polygon, fallback and import zone buttons.
         * @private
         */
        _addAlertTemplateButtons: function() {
            var _this = this;
            // The controls API doesn't behave nicely when we try to inject controls too quickly so we'll use a callback chain
            // to add each button after the other one has been added successfully. Without this Google adds the buttons but
            // they end up all stacked up on top of each other, likely because the styling doesn't have time to update.
            this._addCircleButton(this._circleButtonListener.bind(this),function() {
                _this._addPolygonButton(_this._polygonButtonListener.bind(_this),function() {
                    _this._addFallbackZoneButton(_this._fallbackZoneButtonListener.bind(_this),function() {
                        _this._addImportFileButton(_this._importFileListener.bind(_this));
                    });
                });
            });
        },

        /**
         * Adds the button for toggling fullscreen mode.
         * @private
         */
        _addFullscreenButton: function() {
            this._isFullscreenMode = false;
            this._addCustomControl(
                this._FULLSCREEN_BUTTON_ID,
                google.maps.ControlPosition.RIGHT_TOP,
                this._fullscreenButtonListener.bind(this),
                null
            );
            //Add click listener to the map so the user can click on the map to enable fullscreen
            this._addFullscreenClickListener(this._map);
        },

        /**
         * Removes the button for creating new circular zone stacks.
         * @private
         */
        _removeCircleButton: function() {
            this._removeCustomControl(this._CIRCLE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the button for creating new polygonal zone stacks.
         * @private
         */
        _removePolygonButton: function() {
            this._removeCustomControl(this._POLYGON_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the button for toggling the fallback zone.
         * @private
         */
        _removeFallbackZoneButton: function() {
            this._removeCustomControl(this._FALLBACK_ZONE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the button for importing geospatial files.
         * @private
         */
        _removeImportFileButton: function() {
            this._removeCustomControl(this._IMPORT_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the circle, polygon, fallback and import zone buttons.
         * @private
         */
        _removeAlertTemplateButtons: function() {
            this._removeCircleButton();
            this._removePolygonButton();
            this._removeFallbackZoneButton();
            this._removeImportFileButton();
        },

        /**
         * Removes the button for toggling fullscreen mode.
         * @private
         */
        _removeFulscreenButton: function() {
            this._removeCustomControl(this._FULLSCREEN_BUTTON_ID,google.maps.ControlPosition.RIGHT_TOP);
        },

        /**
         * Adds custom controls (draw buttons, legends, etc..).
         * @param id - The id of the button to create.
         * @param position - The control position.
         * @param listener - The click listener.
         * @param cb - An optional callback that will be executed after the button has been added.
         * @private
         */
        _addCustomControl: function(id,position,listener,cb) {
            var _this = this;
            this._mapIsReady().then(function() {
                // Use the saved button reference to check if the button already exists (eg. this._fullscreenBttn)
                if (!_this['_'+id]) {
                    // Clone the node so the control does not flicker on the page before being positioned
                    _this['_'+id] = _this.$$('#'+id).cloneNode(true);
                    // Append "_cc" to the id so we can find the custom control easily later
                    _this['_'+id].setAttribute('id',_this['_'+id].id+'_cc');
                    // Remove the hidden attribute so the control is displayed when added to the DOM
                    _this['_'+id].removeAttribute('hidden');
                    // Add the click listener
                    if (listener) {
                        _this['_'+id].onclick = listener;
                    }
                    // Add the button to the DOM by adding it to the map controls
                    _this._map.controls[position].push(_this['_'+id]);
                    //Call our callback function, if provided.
                    if (cb && typeof cb === 'function') { cb(); }
                }
            });
        },

        /**
         * Redraws custom controls (draw buttons, legends, etc..). This function is used when we need to update the state
         * of the custom control because the data bindings do not apply to the control once positioned since it is cloned.
         * @param id - The id of the button to create.
         * @param position - The control position.
         * @param listener - The click listener.
         * @param cb - An optional callback that will be executed after the button has been redrawn.
         * @private
         */
        _redrawCustomControl: function(id,position,listener,cb) {
            var _this = this;
            // Async so the styling and bindings have time to update before cloning
            setTimeout(function() {
                if (_this['_'+id]) {
                    var oldControl = _this['_'+id];
                    // Clone the node so the control does not flicker on the page before being positioned
                    _this['_'+id] = _this.$$('#'+id).cloneNode(true);
                    // Append "_cc" to the id so we can find the custom control easily later
                    _this['_'+id].setAttribute('id',_this['_'+id].id+'_cc');
                    // Remove the hidden attribute so the control is displayed when added to the DOM
                    _this['_'+id].removeAttribute('hidden');
                    // Add the click listener
                    if (listener) {
                        _this['_'+id].onclick = listener;
                    }
                    // Replace the existing button in the in the map controls
                    var index = _this._map.controls[position].indexOf(oldControl);
                    if (index > -1) {
                        _this._map.controls[position].removeAt(index);
                        _this._map.controls[position].insertAt(index,_this['_'+id]);
                    }
                    //Call our callback function, if provided.
                    if (cb && typeof cb === 'function') { cb(); }
                }
            },0);
        },

        /**
         * Removes custom controls (draw buttons, legends, etc..).
         * @param id - The id of the button to remove.
         * @param position - The control position.
         * @private
         */
        _removeCustomControl: function(id,position) {
            if (!this._map || !this._map.controls) { return; }
            var index = this._map.controls[position].indexOf(this['_'+id]);
            if (index > -1) {
                this._map.controls[position].removeAt(index);
                this['_'+id] = null;
            }
        },

        /**
         * The listener to fire when the circle button is clicked.
         * @private
         */
        _circleButtonListener: function() {
            this._deselectDrawingButtons();
            if (this._drawingManager.getDrawingMode() === google.maps.drawing.OverlayType.CIRCLE) {
                this._drawingManager.setDrawingMode(null);
                return;
            }
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);
            // Select the custom control (+ '_cc')
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID+'_cc');
            if (circleButton) {
                this.toggleClass('selected', true, circleButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the polygon button is clicked.
         * @private
         */
        _polygonButtonListener: function() {
            this._deselectDrawingButtons();
            if (this._drawingManager.getDrawingMode() === google.maps.drawing.OverlayType.POLYGON) {
                this._drawingManager.setDrawingMode(null);
                // Indicate that drawing was cancelled because for polygons the overlaycomplete will fire after cancelling
                this.set('_drawingCancelled',true);
                return;
            }
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            // Select the custom control (+ '_cc')
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID+'_cc');
            if (polygonButton) {
                this.toggleClass('selected', true, polygonButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the fallback zone button is clicked.
         * @private
         */
        _fallbackZoneButtonListener: function() {
            this._disableDrawingMode();
            if (this._fallbackZone) {
                this._fallbackZone.setEnabled(!this._fallbackZone.enabled);
            }
            else {
                this._fallbackZone = new this._FallbackAlertZone(true);
                this._deselectStacksOnClick(this._fallbackZone.shapeOverlay);
            }
        },

        /**
         * The listener to fire when the import button is clicked.
         * @private
         */
        _importFileListener: function() {
            this._disableDrawingMode();
            this._openFileImportDialog();
        },

        /**
         * The listener to fire when the fullscreen button is clicked.
         * @private
         */
        _fullscreenButtonListener: function() {
            this._toggleFullscreenContainer();
        },

        /**
         * Removes Google's "Stop drawing" hand button from the top-right corner.
         * @private
         */
        _removeStopDrawingButton: function() {
            if (!this._stopDrawingButtonRemoved) {
                var _this = this;
                function waitForStopDrawingButton() {
                    var stopDrawingButton = document.querySelector('div[title="Stop drawing"]');
                    if (!stopDrawingButton) {
                        setTimeout(waitForStopDrawingButton, 10);
                        return;
                    }
                    stopDrawingButton.parentNode.removeChild(stopDrawingButton);
                    _this._stopDrawingButtonRemoved = true;
                }
                waitForStopDrawingButton();
            }
        },

        /**
         * Returns a google.maps.MapOptions `styles` option which disables map place icons and labels.
         * @returns {{}}
         * @private
         */
        _getDisabledPlacesOptions: function() {
            return {
                styles: [
                    {
                        featureType: 'poi',
                        elementType: 'labels.text',
                        stylers: [
                            {
                                visibility: 'off'
                            }
                        ]
                    },
                    {
                        featureType: 'poi.business',
                        stylers: [
                            {
                                visibility: 'off'
                            }
                        ]
                    },
                    {
                        featureType: 'road',
                        elementType: 'labels.icon',
                        stylers: [
                            {
                                visibility: 'off'
                            }
                        ]
                    },
                    {
                        featureType: 'transit',
                        stylers: [
                            {
                                visibility: 'off'
                            }
                        ]
                    }
                ]
            };
        },

        /**
         * Manages checkbox state for the map type buttons.
         * @private
         */
        _manageMapTypeButtonState: function () {
            var control = this['_' + this._MAP_TYPE_BUTTONS_ID];
            // Manage active styling for Map / Satellite buttons
            var bttnClass = 'selected';

            var mapBttn = control.querySelector('#mapBttn');
            var mapActive = this._map.getMapTypeId() === google.maps.MapTypeId.ROADMAP ||
                this._map.getMapTypeId() === google.maps.MapTypeId.TERRAIN;
            this.toggleClass(bttnClass, mapActive, mapBttn);

            var satBttn = control.querySelector('#satBttn');
            var satActive = this._map.getMapTypeId() === google.maps.MapTypeId.HYBRID;
            this.toggleClass(bttnClass, satActive, satBttn);

            // Manage checkbox state
            var checkboxImgTerrain = control.querySelector('#mapTerrainCheckbox');
            checkboxImgTerrain.style.display = 'none';
            if (this._mapTerrainEnabled) {
                checkboxImgTerrain.style.display = 'block';
            }

            var checkboxImgLabels = control.querySelector('#mapPlacesCheckbox');
            checkboxImgLabels.style.display = 'none';
            if (this._mapPlacesEnabled) {
                checkboxImgLabels.style.display = 'block';
            }

            var checkboxImgHybrid = control.querySelector('#satPlacesCheckbox');
            checkboxImgHybrid.style.display = 'none';
            if (this._satPlacesEnabled) {
                checkboxImgHybrid.style.display = 'block';
            }
        },

        /**
         * Toggles the modal fullscreen dialog.
         * @private
         */
        _toggleFullscreenContainer: function() {
            // Open or close the dialog depending on the current state
            if (this._isFullscreenMode) {
                this._closeFullscreenContainer();
            }
            else {
                // Ensure that when the fullscreen container is opened by the user that we force the map pan operation
                // for the initial load rather than skipping it which we will do afterwards until they close it (VRAS-306).
                this._openFullscreenContainer();
            }
            this._isFullscreenMode = !this._isFullscreenMode;
            // Toggle the editable features of the map
            if (this._isAlertView() && (this.mode !== 'view' && this.mode !== 'response')) {
                this._toggleEditableMap(this._isFullscreenMode);
            }
        },

        /**
         * Opens the fullscreen modal dialog.
         * @private
         */
        _openFullscreenContainer: function() {
            var dialog = this.querySelector('#'+this._FULLSCREEN_CONTAINER_ID);
            if (dialog) {
                // Display the dialog
                dialog.removeAttribute('hidden');
                // Save the current map width before moving it into the dialog container
                var mapDiv = this._map.getDiv();
                if (this.width) {
                    this._beforeFullscreenWidth = this.width;
                    this.width = null;
                }
                if (this.height) {
                    this._beforeFullscreenHeight = this.height;
                    this.height = null;
                }
                // Toggle button visibility so that the close button is displayed (select the custom controls (+ '_cc'))
                var buttonContainer = this.querySelector('#'+this._FULLSCREEN_BUTTON_ID+'_cc');
                buttonContainer.querySelector('#closeButton').removeAttribute('hidden');
                buttonContainer.querySelector('#openButton').setAttribute('hidden','hidden');
                // Move the map to the dialog container, adjust the size and add the esc key listener
                dialog.append(mapDiv);
                if (this._isAnAlertEditor()) {
                    dialog.append(this.querySelector('#'+this._SIDE_PANEL_ID));
                }
                // Resize the map
                this._isAlertView()
                    ? this._resizeMapAndAdjustBounds()
                    : this._resizeMapAndMaintainCenter();
            }
        },

        /**
         * Closes the fullscreen modal dialog.
         * @private
         */
        _closeFullscreenContainer: function() {
            // Restore the original map width before moving it to the inline container
            if (this._beforeFullscreenWidth) {
                this.width = this._beforeFullscreenWidth;
            }
            if (this._beforeFullscreenHeight) {
                this.height = this._beforeFullscreenHeight;
            }
            // Toggle button visibility so that the fullscreen button is displayed (select the custom controls (+ '_cc'))
            var buttonContainer = this.querySelector('#'+this._FULLSCREEN_BUTTON_ID+'_cc');
            buttonContainer.querySelector('#openButton').removeAttribute('hidden');
            buttonContainer.querySelector('#closeButton').setAttribute('hidden','hidden');
            // Move the map to the inline container, adjust the size and remove the esc key listener
            var mapDiv = this._map.getDiv();
            this.querySelector('#'+this._CONTAINER_ID).append(mapDiv);
            if (this._isAnAlertEditor()) {
                this.querySelector('#'+this._CONTAINER_ID).append(this.querySelector('#'+this._SIDE_PANEL_ID));
            }
            // Resize the map
            this._isAlertView()
                ? this._resizeMapAndAdjustBounds()
                : this._resizeMapAndMaintainCenter();
            // Hide the dialog
            var dialog = this.querySelector('#'+this._FULLSCREEN_CONTAINER_ID);
            if (dialog) {
                dialog.setAttribute('hidden','hidden');
            }
        },

        /**
         * Adds a map click listener for mobile devices so that when the map
         * is windowed clicking on the map will enable fullscreen mode.
         * @private
         */
        _addFullscreenClickListener: function(mapElement) {
            if (this._isAlertView() && this.mode === 'notification') {
                var _this = this;
                google.maps.event.addListener(mapElement, 'click', function() {
                    if (!_this._isFullscreenMode) {
                        _this._toggleFullscreenContainer();
                    }
                });
            }
        },
        
        _addUserDetailsCloseListener: function() {
            if (this.$.map && this._isAlertView() && this.mode === 'response') {
                var _this = this;
                this.$.map.addEventListener('click', function(e) {
                    if (singletonInfoWindow) {
                        singletonInfoWindow.close();
                        singletonInfoWindow = null;
                        
                        // Reset the map zoom level and area
                        _this._adjustBoundsAndPan();
                    }
                }, true);
            }
        },
        
        _addUserDetailsClickListener: function(mapElement, user, answer, optionalTimezone) {
            if (this._isAlertView() && this.mode === 'response') {
                var contentString = '<h3 style="margin-top: 0;">';
                
                if (mapElement.icon && mapElement.icon.url) {
                    contentString += '<img src="' + mapElement.icon.url + '" style="max-height: 18px;"/> ';
                }
                
                contentString += 'Recipient Details</h3>';
                
                if (user) {
                    contentString += '<p>Contact: ' + user.contact + '</p>';
                    
                    if (user.firstname && user.lastname) {
                        contentString += '<p>Name: ' + user.firstname + ' ' + user.lastname + '</p>';
                    }
                    
                    if (answer) {
                        contentString += '<p>Response: <b>' + answer + '</b></p>';
                    }
                    if (answer && user.response && user.response.received) {
                        var dateFormatString = 'MM/DD/YYYY HH:mm:ss';
                        var ourDate = moment(user.response.received).format(dateFormatString);
                        
                        // Apply a timezone if we have one
                        if (optionalTimezone) {
                            // Change the date to use the proper timezone
                            if (optionalTimezone.name) {
                                ourDate = moment.tz(user.response.received, optionalTimezone.name);
                            }
                            
                            // Format and append the timezone code if we have it
                            ourDate = ourDate.format(dateFormatString);
                            if (optionalTimezone.code) {
                                ourDate += ' ' + optionalTimezone.code;
                            }
                        }
                        
                        contentString += '<p>Response Time: ' + ourDate + '</p>';
                    }
                    
                    if (user.location && user.location.properties && user.location.properties.vras) {
                        var locationRes = '<p>Location: ' + user.location.properties.vras.name;
                        if (user.location.properties.vras.type) {
                            locationRes += ' (' + user.location.properties.vras.type + ')';
                        }
                        if (user.location.geometry && user.location.geometry.coordinates) {
                            locationRes += ' at ' + user.location.geometry.coordinates[1].toFixed(5) + ", " + user.location.geometry.coordinates[0].toFixed(5);
                        }
                        
                        locationRes += '</p>';
                        contentString += locationRes;
                    }
                }
                else {
                    contentString += '<p>No details found</p>';
                }
                
                var _this = this;
                google.maps.event.addListener(mapElement, 'click', function(e) {
                    if (singletonInfoWindow) {
                        singletonInfoWindow.close();
                        singletonInfoWindow = null;
                    }
                    
                    singletonInfoWindow = new google.maps.InfoWindow({
                        content: contentString
                    });
                    
                    singletonInfoWindow.open(_this._map, mapElement);
                    
                    _this._panToLatLng(mapElement.getPosition());
                });
            }
        },
        
        /**
         * Pans the map bounds to the provided LatLng coordinates.
         * @param latLng
         * @private
         */
        _panToLatLng: function(latLng) {
            var _this = this;
            this._map.setOptions({maxZoom:this._maxZoom});
            var bounds = new google.maps.LatLngBounds();
            bounds.extend(latLng);
            this._map.fitBounds(bounds);
            this._map.panToBounds(bounds);
            setTimeout(function() {
                _this._map.setOptions({maxZoom:null});
            },250); //Since Google Maps version 3.32 we must add a slight delay when
                    //resetting the max zoom in order for the map to render correctly.
        },

        /**
         * Opens the file import dialog.
         * @private
         */
        _openFileImportDialog: function() {
            var dialog = this.querySelector('#fileImportDialog');
            if (dialog) {
                dialog.open();
            }
        },

        /**
         * Closes the file import dialog.
         * @private
         */
        _closeFileImportDialog: function() {
            // Reset the associacted state
            var fileUploadInput = this.querySelector('#fileUpload');
            fileUploadInput.inputElement.value = null;
            fileUploadInput.invalid = false;
            // Close the dialog
            var dialog = this.querySelector('#fileImportDialog');
            if (dialog) {
                dialog.close();
            }
        },

        /**
         * Validates the file and uploads it to the relevant module.
         * @private
         */
        _importFile: function() {
            var _this = this;

            var fileUploadInput = this.querySelector('#fileUpload');
            if (!fileUploadInput.validate()) {
                return;
            }

            voyent.action.uploadFilesToModule({
                id: 'process-geospatial-file',
                files: [fileUploadInput.inputElement.files[0]]
            }).then(function(res) {
                if (res && res.length) {
                    for (var i=0; i<res.length; i++) {
                        // Convert the GeoJSON into the appropriate objects
                        var paths = _this._AlertTemplate.calculatePathsFromCoordinates(res[i].coordinates);
                        var zone = new _this._AlertZone(
                            null, res[i].name, paths, false, null, null, null, null, null, null, true
                        );
                        var zoneStack = new _this._AlertZoneStack(null, [zone], true);

                        // Add the stack and fire the zone added event
                        _this._loadedAlert.template.addZoneStack(zoneStack);
                        _this.fire('voyent-alert-zone-added',{
                            id: zone.id,
                            zone: zone,
                            stack: zoneStack,
                            insertIndex: 0,
                            isFallbackZone: false
                        });
                        // Load the new stack / zone
                        _this._selectZone(zoneStack, zone);

                        //When we have only one stack we don't have a template marker, just the marker for the zone stack.
                        //So once we have two zone stacks we need to create the marker and if we have more than two (the
                        //marker exists already) then we'll update it's position.
                        if (_this._loadedAlert.template.zoneStacks.length === 2) {
                            _this._loadedAlert.template.setMarker(new google.maps.Marker({
                                position: _this._AlertTemplate.calculateCentroidFromJSON(_this._loadedAlert.template.json),
                                map: _this._map, draggable: true, zIndex: 50,
                                icon: _this.pathtoimages+'/img/move_icon.png',
                                cursor: 'move', visible: false
                            }));
                        }
                        else if (_this._loadedAlert.template.zoneStacks.length > 2) {
                            _this._loadedAlert.template.updateJSONAndCentroid();
                        }
                        // Always force the position to be saved with the template
                        // when we have a zone derived from an imported file
                        _this._loadedAlert.template.forceSavePositionWithTemplate(true);
                    }
                    // Close the dialog
                    _this._closeFileImportDialog();
                }
                else {
                    fileUploadInput.inputElement.value = null;
                    _this.fire('message-error', 'File contains no usable data, check your file or try another one');
                }
            }).catch(function(e) {
                _this.fire('message-error', 'Failed to process file, try again later or contact a Voyent administrator');
                console.error(e);
            });
        },

        /**
         * Validates the file the user has selected in the file import dialog.
         * @returns {boolean}
         * @private
         */
        _validateFile: function() {
            var elem = this.querySelector('#fileUpload');
            var file = elem.inputElement.files[0];
            if (!file) {
                elem.setAttribute('error-message','Must specify a file to upload');
                return false;
            }
            var ext = file.name.slice(file.name.length-4, file.name.length).toLowerCase();
            if (['.kml','.kmz'].indexOf(ext) === -1) {
                elem.setAttribute('error-message','File must be of type KML or KMZ');
                return false;
            }
            if (file.size > 250000) {
                elem.setAttribute('error-message','File must be less than 250KB in size');
                return false;
            }
            return true;
        },

        /**
         * Updates the map bounds to include all zone stacks and conditionally includes the region geography.
         * Falls back to zooming on the region if there is nothing to include in the map bounds.
         * @param includeRegionGeography
         * @private
         */
        _adjustBoundsAndPan: function(includeRegionGeography) {
            var bounds = new google.maps.LatLngBounds(), boundsExtended = false;
            var zoneStacks = this._loadedAlert && this._loadedAlert.template
                ? this._loadedAlert.template.zoneStacks
                : [];
            if (this._loadedAlert && zoneStacks.length) {
                for (var i=0; i<zoneStacks.length; i++) {
                    var outerZone = zoneStacks[i].getOutermostZone();
                    if (outerZone) {
                        for (var j=0; j<outerZone.shapeOverlay.getPath().length; j++) {
                            bounds.extend(outerZone.shapeOverlay.getPath().getAt(j));
                            boundsExtended = true;
                        }
                    }
                }
            }
            if (includeRegionGeography && this._areaRegion && this._areaRegion.bounds) {
                bounds.extend(this._areaRegion.bounds.getNorthEast());
                bounds.extend(this._areaRegion.bounds.getSouthWest());
                boundsExtended = true;
            }
            // Only pan the map if the bounds were extended otherwise it
            // will try to pan to an empty bounds (middle of the sea)
            if (boundsExtended) {
                this._map.fitBounds(bounds);
                this._map.panToBounds(bounds);
                return;
            }
            // If we never panned the map then just zoom on the region
            this._zoomOnRegion();
        },

        /**
         * Returns a Promise which resolves after recalculating the map size.
         * @returns {Promise}
         * @private
         */
        _resizeMap: function() {
            var _this = this;
            return new Promise(function (resolve) {
                _this._mapIsReady().then(function() {
                    _this._calcMapSize();
                    // Delay so the new dimensions render first
                    setTimeout(function() {
                        return resolve();
                    },0);
                });
            });
        },

        /**
         * Recalculates the map size and adjusts the map bounds.
         * @private
         */
        _resizeMapAndAdjustBounds: function() {
            var _this = this;
            this._resizeMap().then(function() {
                _this._adjustBoundsAndPan();
            });
        },

        /**
         * Recalculates the map size and ensures the map center position is maintained.
         * @private
         */
        _resizeMapAndMaintainCenter: function() {
            var _this = this;
            this._mapCenterPosition = this._map.getCenter();
            this._resizeMap().then(function() {
                if (_this._mapCenterPosition) {
                    _this._map.setCenter(_this._mapCenterPosition);
                    _this._mapCenterPosition = null;
                }
            });
        },

        /**
         * Set up a click listener on the passed map entity that when clicked will de-select the currently selected stack.
         * @param mapEntity
         * @private
         */
        _deselectStacksOnClick: function(mapEntity) {
            var _this = this;
            google.maps.event.addListener(mapEntity, 'click', function() {
                var zoneDeselected = false;
                if (_this._loadedAlert &&  _this._loadedAlert.selectedStack) {
                    _this._loadedAlert.selectedStack.deactivateZoneOverlays();
                    _this.set('_loadedAlert.selectedStack',null);
                    zoneDeselected = true;
                }
                else if (_this._fallbackZone && _this._fallbackZone.active) {
                    _this._fallbackZone.setActive(false);
                    zoneDeselected = true;
                }
                if (zoneDeselected) {
                    _this.fire('voyent-alert-zone-selected',{
                        "id": null,
                        "zone": null
                    });
                }
            });
        },

        /**
         * Listens to whether an alert is loading and toggles the flag for skipping region panning.
         * @param isAlertLoading
         * @private
         */
        _isAlertLoading: function(isAlertLoading) {
            this._skipRegionPanning = isAlertLoading;
        },

        /**
         * Disables drawing mode and selected button states.
         * @private
         */
        _disableDrawingMode: function() {
            if (this._drawingManager) {
                this._drawingManager.setDrawingMode(null);
            }
            this._deselectDrawingButtons();
        },

        /**
         * Ensure that all the drawing buttons are styled as de-selected.
         * @private
         */
        _deselectDrawingButtons: function() {
            var bttnClass = '.customMapBttn';
            // Select the custom controls (+ '_cc')
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID+'_cc');
            if (polygonButton) {
                this.toggleClass('selected', false, polygonButton.querySelector(bttnClass));
            }
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID+'_cc');
            if (circleButton) {
                this.toggleClass('selected', false, circleButton.querySelector(bttnClass));
            }
            var fallbackZoneButton = this.querySelector('#'+this._FALLBACK_ZONE_ID+'_cc');
            if (fallbackZoneButton) {
                this.toggleClass('selected', false, fallbackZoneButton.querySelector(bttnClass));
            }
        },

        /**
         * Listens to change to the map zoom and replaces zone stacks with the badge icons
         * if the zones are small in relation to the boundaries of the map (VRAS-837).
         * @private
         */
        _addZoomChangedListener: function() {
            var _this = this;
            if (this._isAnAlertEditor() || this._isAlertView() || this._isMobileAlertEditor()) {
                google.maps.event.addListener(this._map, 'zoom_changed', function () {
                    var zoneStacks = _this._loadedAlert && _this._loadedAlert.template && _this._loadedAlert.template.zoneStacks;
                    if (zoneStacks && zoneStacks.length) {
                        for (var i=0; i<zoneStacks.length; i++) {
                            var zoneStack = zoneStacks[i];
                            var outerZone = zoneStack.getOutermostZone();
                            var zoneArea = google.maps.geometry.spherical.computeArea(outerZone.shapeOverlay.getPaths().getAt(0));
                            var mapBounds = _this._map.getBounds();
                            var n = mapBounds.getNorthEast().lat(), e = mapBounds.getNorthEast().lng();
                            var s = mapBounds.getSouthWest().lat(), w = mapBounds.getSouthWest().lng();
                            var mapArea = google.maps.geometry.spherical.computeArea(new google.maps.MVCArray([
                                        new google.maps.LatLng(n, e),
                                        new google.maps.LatLng(s, e),
                                        new google.maps.LatLng(s, w),
                                        new google.maps.LatLng(n, w),
                                        new google.maps.LatLng(n, e)
                                    ]
                            ));

                            var percentageOfMapZoneFills = (zoneArea / mapArea) * 100;
                            // Show a badge icon for the zone if the area of the outermost zone is less than 0.1% of the size of the map
                            if (percentageOfMapZoneFills < 0.1) {
                                if (!zoneStack.badgeOverlay) {
                                    (function(zoneStack) {
                                        zoneStack.badgeOverlay = new _this._ImageOverlay(
                                            zoneStack,
                                            _this.getBadgeUrl(_this._loadedAlert.template.badge),
                                            { height: '32px', width: '32px' },
                                            _this._isAnAlertEditor()
                                                ? function() {
                                                    _this._selectZone(zoneStack, zoneStack.getInnermostZone());
                                                }
                                                : function() {
                                                    if (_this._isAlertView() && !_this._isFullscreenMode) {
                                                        return;
                                                    }
                                                    _this._panToZone(zoneStack.getInnermostZone(), true);
                                                }
                                        )
                                    })(zoneStack);
                                }
                                else {
                                    zoneStack.badgeOverlay.displayAndDraw();
                                }
                            }
                            else if (zoneStack.badgeOverlay) {
                                zoneStack.badgeOverlay.hide();
                            }
                        }
                    }
                });
            }
        },

        /**
         * Initializes listeners to manage the max zoom level of the map. This is to
         * ensure that we always have imagery in satellite view modes (see VRAS-367).
         * @private
         */
        _manageMaxZoomLevel: function() {
            var _this = this;

            google.maps.event.addListener(this._map, 'center_changed', function () {
                if (_this._map.get('mapTypeId') === 'satellite' ||
                    _this._map.get('mapTypeId') === 'hybrid') {
                    setMaxZoomLevel();
                }
            });
            google.maps.event.addListener(this._map, 'maptypeid_changed', function() {
                if (_this._map.get('mapTypeId') === 'satellite' ||
                    _this._map.get('mapTypeId') === 'hybrid') {
                    setMaxZoomLevel();
                }
                else {
                    _this._map.setOptions({maxZoom: null});
                }
            });
            function setMaxZoomLevel() {
                new google.maps.MaxZoomService().getMaxZoomAtLatLng(_this._map.getCenter(), function(response) {
                    if (response.status !== 'OK') {
                        return;
                    }
                    //Since Google Maps version 3.32 we must explicitly zoom out if we are zoomed in past the max zoom level.
                    if (_this._map.getZoom() > response.zoom) {
                        _this._map.setZoom(response.zoom);
                    }
                    _this._map.setOptions({maxZoom: response.zoom});
                });
            }
        },

        /**
         * A promise that when resolved indicates that the Google Maps API is available.
         * @returns {*}
         * @private
         */
        _mapsApiAvailable: function() {
            return new Promise(function (resolve) {
                if (('google' in window) && ('maps' in window.google)) {
                    resolve();
                }
                else {
                    waitForMapApi();
                    function waitForMapApi() {
                        if (!('google' in window) || !('maps' in window.google)) {
                            setTimeout(function(){waitForMapApi();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * A promise that when resolved indicates that google maps is ready. Can be used in public facing functions
         * to avoid race conditions where the function tries to execute map related calls before the map is ready.
         * @returns {*}
         * @private
         */
        _mapIsReady: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._map) {
                    resolve();
                }
                else {
                    waitForMap();
                    function waitForMap() {
                        if (!_this._map) {
                            setTimeout(function(){waitForMap();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * A promise that when resolved indicates that we have loaded our realm region.
         * @returns {*}
         * @private
         */
        _areaRegionIsAvailable: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._areaRegion) {
                    resolve();
                }
                else {
                    waitForAreaRegion();
                    function waitForAreaRegion() {
                        if (!_this._areaRegion) {
                            setTimeout(function(){waitForAreaRegion();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * Manages component state between realm changes.
         * @param newRealm
         * @private
         */
        _realmChanged: function(newRealm) {
            //We don't render the region on the map for the alert view.
            if (!this._isAlertView()) {
                //Only proceed if we have a valid realm and the map is initialized.
                if (!newRealm || !this._map) { return; }
                //First clear the current region from the map.
                if (this._areaRegion && this._areaRegion.polygon) {
                    this._areaRegion.polygon.setMap(null);
                    this._areaRegion = null;
                }
                //Check if we have the realm region cached otherwise fetch it.
                var areaRegion = this._regionMapping && this._regionMapping[newRealm] ?
                    this._regionMapping[newRealm] : null;
                if (areaRegion && areaRegion.polygon) {
                    areaRegion.polygon.setMap(this._map);
                    this._areaRegion = areaRegion;
                }
                else {
                    this._fetchRealmRegion();
                }
            }
            //Clear the map entirely.
            this.clearMap();
        },

        /**
         * Listens for changes to map size related properties and recalculates and sizes the map.
         */
        _mapSizePropertyChanged: function() {
            this._calcMapSize();
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Manages selected styling on fallback zone button.
         * @param enabled
         * @private
         */
        _fallbackZoneEnabledChanged: function(enabled) {
            var _this = this;
            // Update the fallback zone button state once it is available. We need to wait because
            // when loading the editor for the first time with an alert that contains a fallback
            // zone the button will not be rendered before we try to set the toggled state
            var fallbackZoneButton;
            this._waitForCondition(function() {
                fallbackZoneButton = _this.querySelector('#'+_this._FALLBACK_ZONE_BUTTON_ID+'_cc');
                return !!fallbackZoneButton;
            },2000).then(function() {
                _this.toggleClass('selected', !!enabled, fallbackZoneButton.querySelector('.customMapBttn'));
                var childDiv = fallbackZoneButton.children[0];
                if (childDiv) {
                    childDiv.setAttribute('title',enabled ? 'Disable Entire Region Zone' : 'Enable Entire Region Zone')
                }
            }).catch(function(){});
        }
    };
</script>
