<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by map-based `voyent-alert-*` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the Alert Template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String, observer: '_realmChanged' },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: Number,
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: Number,
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             */
            autoheight: { type: Number, value: -1, notify: true },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' }
        },

        ready: function() {
            var _this = this;
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            window.initializeLocationsMap = function () {
                var mapOptions = {
                    zoom: 10,
                    center: new google.maps.LatLng(51.08427,-114.13062),
                    streetViewControl: false,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.RIGHT_TOP
                    },
                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.LARGE,
                        position: google.maps.ControlPosition.LEFT_CENTER
                    }
                };
                //Alert view map is readonly.
                if (_this.nodeName === 'VOYENT-ALERT-VIEW') {
                    mapOptions.mapTypeControl =  mapOptions.scrollwheel =
                    mapOptions.zoomControl =  mapOptions.draggable = false;
                    mapOptions.disableDoubleClickZoom = true;
                }
                _this._map = new google.maps.Map(_this.$.map,mapOptions);
                //Calculate the map size.
                _this._calcMapSize();
                if (_this.nodeName !== 'VOYENT-ALERT-VIEW') {
                    //Setup ui and listeners for adding new alert templates.
                    _this._drawingManager = new google.maps.drawing.DrawingManager({
                        map:_this._map,
                        drawingControlOptions: {
                            position: google.maps.ControlPosition.TOP_RIGHT,
                            drawingModes: []
                        },
                        markerOptions: {draggable:true, 'zIndex':50}
                    });
                    _this._setupDrawingListeners();
                }
                _this._regionMapping = {}; //Map of region data so we can toggle between them.
                _this._isLoggedIn = false; //Toggle for side panel.
                //More initialization for each component after login.
                if (voyent.auth.isLoggedIn()) {
                    _this._onAfterLogin();
                }
                window.addEventListener('voyent-login-succeeded',function() {
                    _this._onAfterLogin();
                });
                //Make sure the map is sized correctly when the window size changes.
                window.addEventListener('resize', function() { _this.resizeMap(); });
            };
            if (!('google' in window) || !('maps' in window.google)) {
                var script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyAZVsIO4CmSqqE7qbSO8pB0JPVUkO5bOd8&v=3.27&' +
                    'libraries=places,geometry,visualization,drawing&callback=initializeLocationsMap';
                this.$.container.appendChild(script);
            }
            else {
                initializeLocationsMap();
            }
        },

        /**
         * Re-calculates the map size, fires the Google Map resize event and pans the map.
         */
        resizeMap: function() {
            if (('google' in window) && this._map) {
                var _this = this;
                this._calcMapSize();
                //Async so the new dimensions have time to render.
                setTimeout(function() {
                    google.maps.event.trigger(_this._map, 'resize');
                    if (_this._areaRegion && _this._areaRegion.bounds) {
                        _this._map.fitBounds(_this._areaRegion.bounds);
                        _this._map.panToBounds(_this._areaRegion.bounds);
                    }
                },0);
            }
        },

        /**
         * Saves or updates the current Alert Template.
         */
        saveAlertTemplate: function () {
            //Use this flag to avoid race conditions if the user mashes the "Activate Now" and "Back" buttons.
            if (this._savingAlert) { return; } this._savingAlert = true;
            var _this = this;
            var func = !this._loadedAlertTemplateData.isPersisted ? 'createTracker' : 'updateTracker';
            var alertTemplate = this._loadedAlertTemplateData.alertTemplate, zoneTmpProperties = [];
            //Save the tmpProperties before deleting them from the array,
            //we can't parse first because they contain invalid JSON.
            for (var i=0; i<alertTemplate.zones.features.length; i++) {
                zoneTmpProperties.push(alertTemplate.zones.features[i].tmpProperties);
                delete alertTemplate.zones.features[i].tmpProperties;
            }
            var newTemplate = JSON.parse(JSON.stringify(this._loadedAlertTemplateData.alertTemplate));
            delete newTemplate.tmpProperties;
            voyent.locate[func]({
                realm: this.realm,
                account: this.account,
                tracker: newTemplate,
                id: newTemplate._id //Not valid if 'createTracker' but no harm in passing it anyway.
            }).then(function (uri) {
                _this._savingAlert = false;
                if (func === 'createTracker') {
                    //Grab the generated ID from the return URI and setup change listeners
                    _this.set('_loadedAlertTemplateData.alertTemplate._id',uri.split('/').pop());
                    _this._loadedAlertTemplateData.isPersisted = true;
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                        _this.fire('message-info', 'Alert Template successfully created.');
                    }
                }
                else if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                    _this.fire('message-info', 'Alert Template successfully updated.');
                }
                //Update our local copy of the persisted Alert Template in case we need to revert later.
                _this._loadedAlertTemplateData.persistedAlertTemplate =
                JSON.parse(JSON.stringify(_this._loadedAlertTemplateData.alertTemplate));
                //Restore the tmpProperties for each of the zones.
                var zones = _this._loadedAlertTemplateData.persistedAlertTemplate.zones.features;
                for (var i=0; i<_this._loadedAlertTemplateData.persistedAlertTemplate.zones.features.length; i++) {
                    _this.set('_loadedAlertTemplateData.alertTemplate.zones.features.'+i+'.tmpProperties',zoneTmpProperties[i]);
                    _this.set('_loadedAlertTemplateData.persistedAlertTemplate.zones.features.'+i+'.tmpProperties',zoneTmpProperties[i]);
                }
                //Fire an event for anyone interested.
                _this.fire('voyent-alert-template-saved',{});
            });
        },

        /**
         * Clears the map of the loaded Alert and conditionally also the drawn Alerts.
         * @param clearAlerts
         */
        clearMap: function(clearAlerts) {
            //Always re-zoom the bounds on the area's region if available.
            if (this._areaRegion && this._areaRegion.bounds) {
                this._map.fitBounds(this._areaRegion.bounds);
                this._map.panToBounds(this._areaRegion.bounds);
            }
            //Clear loaded Alert Template.
            if (this._loadedAlertTemplateData) {
                deleteAlertEntity(this._loadedAlertTemplateData);
                this._loadedAlertTemplateData = null;
            }
            //Clear all Alerts.
            if (clearAlerts && this._alerts) {
                for (var i=0; i<this._alerts.length; i++) {
                    deleteAlertEntity(this._alerts[i]);
                }
                this.set('_alerts',[]);
            }
            //Re-draw the buttons.
            if (this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                this._drawingManager.setOptions({
                    "drawingControlOptions":{
                        "drawingModes":['marker'],
                        "position":google.maps.ControlPosition.TOP_RIGHT}
                });
            }
            else if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                this._addAlertButton();
            }
            function deleteAlertEntity(alertTemplateData) {
                //Remove the marker, circles and zoneOverlays from the map.
                alertTemplateData.marker.setMap(null);
                var zones = alertTemplateData.alertTemplate.zones.features;
                for (var i=0; i<zones.length; i++) {
                    zones[i].tmpProperties.circle.setMap(null);
                    zones[i].tmpProperties.zoneOverlay.setMap(null);
                }
            }
        },

        /**
         * Set an optional message template on a per zone basis.
         * This will be saved along with the rest of the alert template, and is used for notifications.
         * The data for the message template will likely come from the voyent-transport-editor.
         * The specific JSON location to save is as a property of the zone, so zones.features[x].properties.messageTemplate.
         * @param messageTemplate
         * @param zoneIndex
         */
        setMessageTemplate: function(messageTemplate, zoneIndex) {
            // Ensure we have valid template data, zones, and features
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                this._loadedAlertTemplateData.alertTemplate.zones.features[zoneIndex].properties.messageTemplate = messageTemplate;
            }
        },

        //******************PRIVATE API******************

        /**
         * Fetches the region boundary for the realm.
         * @returns {*}
         * @private
         */
        _fetchRealmRegion: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findRegions({realm:_this.realm,account:_this.account,
                                             options:{"sort":{"time":-1},"limit":1}}).then(function (regions) {
                    //Filter out the Alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions.filter(function(region) {
                        return !region.location.properties || !region.location.properties.trackerId;
                    })[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Draws a user marker on the map based on the passed location data.
         * @param location
         * @private
         */
        _drawUser: function(location) {
            if (!location) { return; }
            var coordinates = location.location.geometry.coordinates;
            //Set the label of the user marker to the first letter of the username.
            var label = "?";
            if (location.username && location.username.length > 0) {
                label = location.username.substring(0, 1).toLowerCase();
            }
            //Check if we already have a user location drawn on the map.
            if (this._userData) { //Update the existing instance.
                this._userData.marker.setPosition(new google.maps.LatLng(coordinates[1],coordinates[0]));
                this._userData.location = location;
            }
            else { //Draw the user and store the data for later use.
                this._userData = {"location":location,"marker":new google.maps.Marker({
                    position: new google.maps.LatLng(coordinates[1],coordinates[0]),
                    map: this._map,
                    draggable: false,
                    icon: this.pathtoimages+'/img/user_marker.png',
                    label: {
                        text: label,
                        color: "white"
                    }
                })};
            }
        },

        /**
         * Fetches the most recent User or Alert location depending on whether we are passed a trackerId.
         * @param trackerId
         * @private
         */
        _fetchLocationRecord: function(trackerId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                //Build the query.
                var query = {};
                if (trackerId && typeof trackerId === 'string') {
                    query = {"location.properties.trackerId":trackerId};
                }
                else {
                    query["location.properties.trackerId"] = {"$exists":false};
                    query.username = voyent.auth.getLastKnownUsername();
                }
                //Only get the last location.
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,query:query,
                options:{"sort":{"lastUpdated":-1},"limit":1}}).then(function(location) {
                    if (trackerId) {
                        processAlertLocation();
                        function processAlertLocation() {
                            if (!location || !location[0]) { resolve(); return; }
                            //We make the call that fetches the currentTemplate in parallel for performance but this
                            //can cause a race condition so we'll wait for the value to be set before continuing.
                            if (!_this._currentTemplate) {
                                setTimeout(processAlertLocation,10);
                                return;
                            }
                            //First clear the map of any previously drawn entities.
                            _this.clearMap(true);
                            //Draw the Alert.
                            var alert = JSON.parse(JSON.stringify(_this._currentTemplate));
                            alert.anchor.geometry.coordinates = location[0].location.geometry.coordinates;
                            _this._drawAlertEntity(alert, location[0]);
                            resolve(location[0]);
                        }
                    }
                    else {
                        //Draw the user.
                        _this._drawUser(location[0]);
                        resolve(location[0]);
                    }
                }).catch(function(error) {
                    _this.fire('message-error', 'Issue getting User Location: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches existing fixed location records, groups them by uid and keeps only the latest.
         * @returns {*}
         * @private
         */
        _fetchMyLocations: function() {
            var _this = this;
            var locs = {};
            return new Promise(function (resolve, reject) {
                var query = {"location.properties.trackerId":{"$exists":false},
                             "location.properties.vras.label":{"$exists":true},
                             "location.properties.vras.type":{"$exists":true},
                             "location.properties.vras.uid":{"$exists":true}};
                var fields = {"_id":0,"username":0};
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,
                                             query:query,fields:fields}).then(function(locations) {
                    for (var i=0; i<locations.length; i++) {
                        if (!locs[locations[i].location.properties.vras.uid]) {
                            locs[locations[i].location.properties.vras.uid] = locations[i];
                        }
                        else if (locs[locations[i].location.properties.vras.uid].lastUpdated <
                                 locations[i].lastUpdated) {
                            locs[locations[i].location.properties.vras.uid] = locations[i];
                        }
                    }
                    //Convert the mapping back to an array and return it.
                    resolve(Object.keys(locs).map(function(key){return locs[key]}));
                }).catch(function (error) {
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed polygon region on the map.
         * @param region
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path = [];
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j = 0; j < coords.length; j++) {
                for (var k = 0; k < coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    bounds.extend(googlePoint);
                }
                paths.push(path);
            }
            //Draw the Polygon.
            var polygon = new google.maps.Polygon({
                'paths': paths,
                'map': this._map,
                'editable': false,
                'clickable': false //Necessary to get the Alert cursor to display correctly.
            });
            //Zoom on the newly drawn Region.
            this._map.fitBounds(bounds);
            this._map.panToBounds(bounds);
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon,"bounds":bounds};
            this._regionMapping[this.realm] = this._areaRegion;
        },

        /**
         * Draws the passed Alert or Alert Template on the map and sets up the properties panel or Alert list.
         * @param alertTemplate
         * @param alertLocation - If an Alert then this is the location data associated with it.
         * @private
         */
        _drawAlertEntity: function(alertTemplate,alertLocation) {
            var alertTemplateData = null;
            //Create the marker and build the alertTemplateData.
            var marker = new google.maps.Marker({
                position: new google.maps.LatLng(alertTemplate.anchor.geometry.coordinates[1],alertTemplate.anchor.geometry.coordinates[0]),
                map: this._map,
                draggable: this.nodeName !== 'VOYENT-ALERT-VIEW',
                zIndex: 50,
                icon: this.nodeName === 'VOYENT-ALERT-EDITOR' ? this.pathtoimages+'/img/alert_marker.png' : null
            });
            //This is triggered from alert-template-editor when drawing templates or from alert-editor when drawing Alerts.
            if (!this._loadedAlertTemplateData || alertLocation) {
                alertTemplateData = {"alertTemplate":alertTemplate,
                    "persistedAlertTemplate":JSON.parse(JSON.stringify(alertTemplate)),
                    "marker":marker,"isPersisted":true};
                if (alertLocation) { alertTemplateData.alertInstance = alertLocation; }
                //Load immediately since it's a template.
                else { this._loadedAlertTemplateData = alertTemplateData; }
            }
            //This will be triggered from alert-editor when drawing child templates only
            else {
                //Alert template data already initialized as a child template so just set the marker.
                alertTemplateData = this._loadedAlertTemplateData;
                alertTemplateData.marker = marker;
            }
            //Add the tmpProperties to the Alert Template (used by the view).
            if (!alertTemplateData.alertTemplate.tmpProperties) {
                alertTemplateData.alertTemplate.tmpProperties = this._getAlertTemplateTmpProperties();
            }
            //Generate the circles and bind them to the marker.
            var zones = alertTemplateData.alertTemplate.zones.features,circle, properties;
            for (var i=0; i<zones.length; i++) {
                //Add the tmpProperties to the Zone (used by the view).
                if (!zones[i].tmpProperties) {
                    zones[i].tmpProperties = this._getZoneTmpProperties();
                }
                //Set the properties of the circle based on the alertTemplate JSON.
                properties = this._getCircleProperties();
                properties.radius = zones[i].properties.googleMaps.radius;
                properties.fillColor = '#'+ zones[i].properties.Color;
                properties.fillOpacity = zones[i].properties.Opacity;
                properties.zIndex = zones[i].properties.googleMaps.zIndex;
                //Create the circle and bind it.
                circle = new google.maps.Circle(properties);
                circle.bindTo('center', marker, 'position');
                zones[i].tmpProperties.circle = circle;
                //Determine where to draw the Proximity Zone label overlay and draw it.
                zones[i].tmpProperties.highestLat = this._determineHighestLat(zones[i].geometry.coordinates[0]);
                zones[i].tmpProperties.zoneOverlay = new this._ProximityZoneOverlay(zones[i]);
            }
            //Set the alerts array if adding a new alert.
            if (alertLocation) {
                this.push('_alerts',alertTemplateData);
                //Update the template coordinates to correctly calculate the positions of the labels.
                this._updateAlertTemplateJSON(alertTemplateData);
            }
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                this._setupMapListeners(alertTemplateData);
            }
            if (this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                //Disable further Alert Template creations - only allowed one at a time.
                this._drawingManager.setOptions({
                    "drawingControlOptions":{
                        "drawingModes":[],
                        "position":google.maps.ControlPosition.TOP_RIGHT}
                });
            }
            else if (this.nodeName === 'VOYENT-ALERT-EDITOR' && !alertLocation) {
                //Disable further Alert creations - only allowed one at a time.
                this._removeAlertButton();
            }
        },

        /**
         * Determines the highest latitude of the passed coordinates array, used to
         * calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns {number}
         * @private
         */
        _determineHighestLat: function(coordinates) {
            var highestLat = -100;
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > highestLat) {
                    highestLat = coordinates[i][1];
                }
            }
            return highestLat;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         * @private
         */
        _calcMapSize: function() {
            var _this = this;
            //Do this async so the container has time to load and properly calculate it's size.
            setTimeout(function() {
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight !== null && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (height === null) {
                        height = _this.$$('#container').clientHeight;
                    }
                    //If we still don't have a valid height default to a minimum
                    if (height < 50) {
                        height = 500;
                    }
                }
                _this.customStyle['--height-var'] = height + 'px';

                //If the width is specified then set it
                if (_this.width && _this.width !== null && _this.width > 0) {
                    _this.customStyle['--width-var'] = _this.width + 'px';
                }
                else { //Otherwise the map will take up as much space as possible.
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' ||
                        _this.nodeName === 'VOYENT-ALERT-EDITOR') {
                        //-4px for map borders.
                        _this.customStyle['--width-var'] = (_this.querySelector('#container').offsetWidth -
                            _this.querySelector('#sidePanel').offsetWidth - 4) + 'px';
                    }
                    else {
                        _this.customStyle['--width-var'] = _this.querySelector('#container').offsetWidth + 'px';
                    }

                }
                //Apply the styles
                _this.updateStyles();
            },0);
        },

        /**
         * Handles removing the button for creating new Alerts.
         * @private
         */
        _removeAlertButton: function() {
            var alertBttn = this.querySelector('#alertBttn');
            if (alertBttn) { alertBttn.parentNode.removeChild(alertBttn); }
        },

        /**
         * Opens the dialog and sets various properties to be used later.
         * @param message
         * @param input
         * @param confirmFunc
         * @param cancelFunc
         * @private
         */
        _openDialog: function(message,input,confirmFunc,cancelFunc) {
            this._dialogMessage = message;
            this._dialogInput = input;
            if (this._dialogInput !== null) {
                this._showDialogInput = true;
            }
            this._dialogConfirmFunc = confirmFunc;
            this._dialogCancelFunc = cancelFunc;
            var dialog = this.querySelector('#modalDialog');
            if (dialog) {
                dialog.open();
                //If there's no input rendered in the dialog then focus on the dialog so
                //we can capture the user's key presses. The input will focus automatically.
                if (!this._showDialogInput) {
                    setTimeout(function() {
                        dialog.focus();
                    },200);
                }
            }
        },

        /**
         * Handles dialog input validation and calling the confirmation function if available.
         * @private
         */
        _confirmDialog: function() {
            //Validate the input.
            if (this._showDialogInput && (!this._dialogInput ||
                !this._dialogInput.trim())) {
                return;
            }
            //We allow for passing the confirm function directly or as a string.
            if (this._dialogConfirmFunc) {
                if (typeof this._dialogConfirmFunc === 'string') { this[this._dialogConfirmFunc](); }
                else { this._dialogConfirmFunc(); }
            }
            //Close the dialog after.
            this._closeDialog(true);
        },

        /**
         * Handles closing the dialog and calling the cancel function if available.
         * @param confirmed
         * @private
         */
        _closeDialog: function(confirmed) {
            //Only call the cancel function if this is triggered by a cancel.
            //We allow passing the confirm function directly or as a string.
            if (!confirmed && this._dialogCancelFunc) {
                if (typeof this._dialogCancelFunc === 'string') { this[this._dialogCancelFunc](); }
                else { this._dialogCancelFunc(); }
            }
            this._dialogMessage = this._dialogInput = this._showDialogInput =
                this._dialogConfirmFunc = this._dialogCancelFunc = null;
            this.querySelector('#modalDialog').close();
        },

        /**
         * Handles enter and escape key presses when the dialog is focused.
         * @param e
         * @private
         */
        _dialogKeyUp: function(e) {
            if (e.keyCode === 13) { //Enter
                this._customProperties ? this._confirmCustomDialog() : this._confirmDialog();
            }
            else if (e.keyCode === 27) { //Escape
                this._closeDialog();
            }
        },

        /**
         * Fixes an issue with paper-dialog modal stacking context when the dialog is inside an app-drawer.
         * @param e
         * @private
         */
        _fixModalStacking: function (e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },

        /**
         * Manages component state between realm changes.
         * @param newRealm
         * @private
         */
        _realmChanged: function(newRealm) {
            //We don't render the region on the map for the alert view.
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                //Only proceed if we have a valid realm and the map is initialized.
                if (!newRealm || !this._map) { return; }
                //First clear the current region from the map.
                if (this._areaRegion && this._areaRegion.polygon) {
                    this._areaRegion.polygon.setMap(null);
                    this._areaRegion = null;
                }
                //Check if we have the realm region cached otherwise fetch it.
                var areaRegion = this._regionMapping && this._regionMapping[newRealm] ?
                    this._regionMapping[newRealm] : null;
                if (areaRegion && areaRegion.polygon) {
                    areaRegion.polygon.setMap(this._map);
                    this._areaRegion = areaRegion;
                }
                else {
                    this._fetchRealmRegion();
                }
            }
            //Clear the map entirely.
            this.clearMap(true);
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                //Refresh the map with the latest data.
                this.refreshMap();
            }
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Returns temporary Alert Template properties used by the view.
         * @returns {{renaming: boolean, newName: string}}
         * @private
         */
        _getAlertTemplateTmpProperties: function() {
            return {
                "renaming":false,
                "newName":''
            }
        }
    };
</script>