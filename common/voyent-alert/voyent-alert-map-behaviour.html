<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">
<link rel="import" href="../imports/resize-observer.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by map-based `voyent-alert-*` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        /**
         * Fires when the alert template is successfully saved. Does not include any data.
         * @event voyent-alert-template-saved
         */

        /**
         * Fires when the user cancels creating a new template.
         * @event voyent-alert-template-cancel
         */

        /**
         * Fires when the alert template name changes. Includes a `name` property that contains the new value.
         * @event voyent-alert-template-name-changed
         */

        /**
         * Fires when an alert zone name changes. Includes a `name` property that contains the new value, an `id` property
         * which identifies the zone and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-name-changed
         */

        /**
         * Fires when a new alert zone is added to the template. This could be in the form of a completely new stack or
         * adding to an existing stack. Includes an `id` property which identifies the zone, a `zone` property that
         * contains the associated data and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-added
         */

        /**
         * Fired when an alert zone is removed from the template. Includes an `id` property which identifies
         * the zone and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-removed
         */

        /**
         * Fires when the selected alert zone changes. Includes an `id` property which identifies the zone, a `zone`
         * property that contains the associated data and an `isFallbackZone` property indicating whether the zone is
         * the fallback zone. If no zone is selected then the `id` and `zone` values will be null.
         * @event voyent-alert-zone-selected
         */

        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the alert template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String, observer: '_realmChanged' },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: { type: Number, observer: '_mapSizePropertyChanged' },
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: { type: Number, observer: '_mapSizePropertyChanged' },
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             * @default -1
             */
            autoheight: { type: Number, value: -1, notify: true, observer: '_mapSizePropertyChanged' },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             * @default '.'
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' },
            /**
             * The subdirectory where our badge files are stored
             */
            badgedir: { type: String, value: '' }
        },

        observers: [
            '_selectedStackChanged(_loadedAlert.selectedStack)',
            '_fallbackZoneEnabledChanged(_fallbackZone.enabled)'
        ],

        ready: function() {
            var _this = this;
            //Define some constants.
            this._CONTAINER_ID = 'container';
            this._SIDE_PANEL_ID = 'sidePanel';
            this._FULLSCREEN_BUTTON_ID = 'fullscreenBttn';
            this._FULLSCREEN_CONTAINER_ID = 'fullscreenContainer';
            this._CIRCLE_BUTTON_ID = 'circleBttn';
            this._POLYGON_BUTTON_ID = 'polygonBttn';
            this._FALLBACK_ZONE_BUTTON_ID = 'fallbackZoneBttn';
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            //We will always depend on loading the map API externally.
            this._mapsApiAvailable().then(function() {
                _this._initializeGoogleMap();
            });
        },

        /**
         * General function for initializing the Google Map and other required features.
         * @private
         */
        _initializeGoogleMap: function () {
            var _this = this;
            var mapOptions = {
                zoom: 10,
                center: new google.maps.LatLng(51.08427,-114.13062),
                streetViewControl: false,
                fullscreenControl: false,
                scrollwheel: false,
                scaleControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                    position: google.maps.ControlPosition.TOP_LEFT
                },
                zoomControlOptions: {
                    style: google.maps.ZoomControlStyle.LARGE,
                    position: google.maps.ControlPosition.LEFT_TOP
                },
                keyboardShortcuts: false //VRAS-394
            };
            if (this.nodeName !== 'VOYENT-MY-LOCATIONS') {
                mapOptions.clickableIcons = false;
            }
            //Alert view map is readonly.
            if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                mapOptions.mapTypeControl = mapOptions.zoomControl = mapOptions.draggable = false;
                mapOptions.disableDoubleClickZoom = true;
            }
            //Initialize the map.
            this._map = new google.maps.Map(this.$.map,mapOptions);
            //Calculate the map size.
            this._calcMapSize();
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                //Setup ui and listeners for adding new marker based entities.
                this._drawingManager = new google.maps.drawing.DrawingManager({
                    map:this._map,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        drawingModes: []
                    },
                    //This settings only apply to entities created with
                    //the drawing API, not when creating manually.
                    markerOptions: { draggable:true, zIndex:50 }
                });
                this._setupDrawingListeners();
                this._removeStopDrawingButton();
            }
            if (this.nodeName === 'VOYENT-ALERT-EDITOR' || this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                //Add the fullscreen control.
                this._addFullscreenButton();
                //Maintain the isZoneSelected toggle for updating the UI.
                this._isZoneSelected = false;
                this.addEventListener('voyent-alert-zone-selected',function(e) {
                    _this.set('_isZoneSelected',!!e.detail.id);
                    //When zone's are selected we will bring their name overlay to the top
                    var selectedZone = e.detail.zone;
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        var zones = this._loadedAlert.template.zoneStacks[i].zones;
                        for (var j=0; j<zones.length; j++) {
                            if (zones[j].nameOverlay) {
                                if (selectedZone) {
                                    if (zones[j] === selectedZone) {
                                        zones[j].nameOverlay.moveToTopPane();
                                        continue;
                                    }
                                }
                                zones[j].nameOverlay.moveToDefaultPane();
                            }
                        }
                    }
                });
            }
            this._maxZoom = 17; //The maximum amount we will zoom when panning the map in certain cases.
            this._manageMaxZoomLevel(); //Ensure we always have imagery in satellite view modes.
            this._regionMapping = {}; //Map of region data so we can toggle between them.
            this._isLoggedIn = false; //Toggle for side panel.
            //Custom initialization for each component after login.
            if (voyent.auth.isLoggedIn()) {
                this._onAfterLogin();
            }
            else {
                //We only want to do this on initial login and not access_token refreshes so we'll
                //save a reference to the listener so we can remove it the first time it fires.
                var onAfterLoginListener = function() {
                    _this._onAfterLogin();
                    window.removeEventListener('voyent-login-succeeded',onAfterLoginListener);
                };
                window.addEventListener('voyent-login-succeeded',onAfterLoginListener);
            }
            //Make sure the map is always sized correctly when the window size changes.
            window.addEventListener('resize', function() {
                _this.resizeMap();
            });
            //Make sure the map is always sized correctly when the map size changes.
            new ResizeObserver(function() {
                //This ResizeObserver listener sometimes fires when the map
                //dimensions have not changed so we will ignore these events.
                var offsetWidth = _this.querySelector('#map').offsetWidth;
                var offsetHeight = _this.querySelector('#map').offsetHeight;
                if ((_this._previousMapWidth === offsetWidth &&
                    _this._previousMapHeight === offsetHeight) ||
                    (offsetWidth === 0 || offsetHeight === 0)) {
                    return;
                }
                _this._previousMapWidth = offsetWidth;
                _this._previousMapHeight = offsetHeight;
                _this.resizeMap();
            }).observe(this.querySelector('#map'));
            //De-select any selected zone stack on map click.
            this._deselectStacksOnClick(this._map);
            //Create a general use OverlayView object that so we can access some of its utility functions.
            this._overlayView = new google.maps.OverlayView();
            this._overlayView.draw = function() {};
            this._overlayView.setMap(this._map);
        },

        /**
         * Recalculates the map size, fires the Google Map resize event and pans the map.
         * @param forceMapPan
         */
        resizeMap: function(forceMapPan) {
            var _this = this;
            this._mapIsReady().then(function() {
                _this._calcMapSize();
                //Async so the new dimensions render first.
                setTimeout(function() {
                    _this._adjustBoundsAndPan(forceMapPan);
                },0);
            });
        },

        /**
         * Saves or updates the current alert.
         */
        saveAlert: function() {
            this._saveAlert().catch(function(e){})
        },

        /**
         * Wrapped function for `saveAlert` that returns a Promise for internal component use.
         * @returns {Promise}
         * @private
         */
        _saveAlert: function() {
            var _this = this, msg;
            return new Promise(function (resolve, reject) {
                if (_this._savingAlert) { return reject('already saving alert'); }
                _this._savingAlert = true;

                //Pull the latest JSON from each of the stacks and specify that we want to punch out the circular templates.
                _this._loadedAlert.template.updateJSON(true);
                var requestOpts = {
                    realm: _this.realm,
                    account: _this.account,
                    alert:_this._loadedAlert.template.json,
                    coordinates:_this._buildAlertLocationJSON().location.geometry.coordinates
                };
                var func = 'createAlert';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlert';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlert = false;
                    if (func === 'createAlert') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    //Adjust message based on the component making the request and whether we are saving an alert as a template.
                    _this.fire('message-error', 'Issue saving alert: ' + (e.responseText || e.message || e));
                    _this._savingAlert = false;
                    reject(msg);
                });
            });
        },

        /**
         * Returns preview data via a Promise for the currently loaded alert.
         * @returns {Promise}
         */
        previewAlert: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this._loadedAlert || !_this._loadedAlert.template) {
                    _this.fire('message-error', 'Unable to preview alert: No alert loaded');
                    return reject();
                }
                var promises = [];
                var event = _this._buildPreviewEvent();
                promises.push(voyent.action.executeModule({
                    "id":"alert-moved-notify-for-zones",
                    "params":{
                        "moduleParams": {
                            "synchronous": true
                        },
                        "_eventMessage": event
                    }
                }));
                promises.push(voyent.action.executeModule({
                    "id":"alert-moved-notify-social-media",
                    "params":{
                        "moduleParams": {
                            "synchronous": true,
                            "isPreview": true
                        },
                        "_eventMessage": event
                    }
                }));
                Promise.all(promises).then(function(moduleResults) {
                    var previewMetrics = moduleResults[0];
                    var socialMediaStatuses = moduleResults[1];

                    if (!previewMetrics.summary) {
                        previewMetrics.summary = {};
                    }
                    if (socialMediaStatuses.summary) {
                        previewMetrics.summary.facebookWillNotify = !!(socialMediaStatuses.summary.facebookWillNotify);
                        previewMetrics.summary.twitterWillNotify = !!(socialMediaStatuses.summary.twitterWillNotify);
                    }
                    else {
                        previewMetrics.summary.facebookWillNotify = false;
                        previewMetrics.summary.twitterWillNotify = false;
                    }
                    for (var i=0; i<previewMetrics.zoneMetrics.length; i++) {
                        var currentZone = socialMediaStatuses.zones ? socialMediaStatuses.zones[previewMetrics.zoneMetrics[i].id] : null;
                        if (currentZone) {
                            previewMetrics.zoneMetrics[i].facebookWillNotify = !!(currentZone.facebookWillNotify);
                            previewMetrics.zoneMetrics[i].twitterWillNotify = !!(currentZone.twitterWillNotify);
                        }
                        else {
                            previewMetrics.zoneMetrics[i].facebookWillNotify = false;
                            previewMetrics.zoneMetrics[i].twitterWillNotify = false;
                        }
                    }
                    resolve(previewMetrics);
                }).catch(function(e) {
                    console.error(e);
                    _this.fire('message-error','Unable to preview alert, try again later.');
                    reject(e);
                });
            });
        },

        /**
         * Fabricates a location create event so we can generate preview metrics.
         * @returns Object {}
         * @private
         */
        _buildPreviewEvent: function() {
            this._loadedAlert.template.updateJSON(true);
            var json = this._loadedAlert.template.json;

            json.state = 'preview';

            var alertId = this._loadedAlert.template.id || 'preview';
            var alertFamilyId = this._loadedAlert.template.alertFamilyId || this._generateUid();

            var currentLocation = this._buildAlertLocationJSON().location;
            if (!currentLocation.properties.alertId) {
                currentLocation.properties.alertId = alertId;
            }
            if (!json.properties.alertFamilyId) {
                json.properties.alertFamilyId = alertFamilyId;
            }

            // Add the activatedBy property as it's required for the social-media module.
            json.activatedBy = voyent.auth.getLastKnownUsername();

            return {
                "time": new Date().toISOString(),
                "account": this.account,
                "realm": this.realm,
                "service": "locate",
                "event": "create",
                "type": "location",
                "username": voyent.auth.getLastKnownUsername(),
                "tx": "",
                "data": {
                    "resourceId": alertId,
                    "origin": window.location.hostname,
                    "previousLocation": {}, //This isn't being used by the modules currently so don't bother including it.
                    "currentLocation": currentLocation,
                    "alert": json,
                    "alertId" : alertId,
                    "alertFamilyId":alertFamilyId
                }
            };
        },

        /**
         * Returns a JSON representation of the currently loaded alert.
         * @returns {*}
         */
        getCurrentAlert: function() {
            if (this._loadedAlert && this._loadedAlert.template) {
                this._loadedAlert.template.updateJSON(true);
                return this._loadedAlert.template.json;
            }
            return null;
        },

        /**
         * Returns the id of the currently loaded alert.
         * @returns {*}
         */
        getCurrentAlertId: function() {
            if (this._loadedAlert && this._loadedAlert.template) {
                return this._loadedAlert.template.id;
            }
            return null;
        },

        /**
         * Get the coordinates of the the loaded alert's current position in the format [lng,lat].
         * @returns {Array}
         */
        getCurrentCoordinates: function() {
            return this._buildAlertLocationJSON().location.geometry.coordinates;
        },

        /**
         * Clears the map entirely. In the case of alert editor the list of templates will also be refreshed.
         */
        clearMap: function() {
            var _this = this;
            this._disableDrawingMode();
            //Don't zoom on region when clearing map on alert detail view as
            //this causes some jerky pan behaviour when viewing an alert.
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                this._zoomOnRegion();
            }
            //Clear loaded alert template.
            if (this._loadedAlert || this._fallbackZone) {
                this._removeAlertTemplateFromMap();
            }
            //Clear the user marker.
            if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                if (this._mobileLocation) {
                    this._mobileLocation.removeFromMap();
                    this._mobileLocation = null;
                }
                else if (this._myLocations) {
                    this._clearMyLocations();
                }
            }
            if (this.nodeName === 'VOYENT-ALERT-EDITOR' ||
                this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                //Always start the view with a windowed component.
                if (this._isFullscreenMode) {
                    this._toggleFullscreenContainer();
                }
                if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                    this._enableDefaultPane();
                    this._showMovement = false;
                    //Clear the movement inputs, async so the side panel has time to render.
                    setTimeout(function() {
                        _this._alertDirection = _this._alertSpeed = null;
                        _this._alertSpeedUnit = 'kph';
                    },0);
                }
            }
        },

        /**
         * Opens a dialog for choosing alert badges.
         */
        chooseAlertBadge: function() {
            var _this = this;
            this._openDialog('Choose Alert Badge',null,null,null,null,true,false,function() {
                // Persist our choice to the template JSON
                _this._loadedAlert.template.setBadge(_this._dialogBadge);
                // Fire an event that the badge changed
                _this.fire('voyent-alert-badge-changed', {"badge": _this._loadedAlert.template.badge});
            });
        },

        /**
         * Sets the alert schedule into the loaded template.
         * @param schedule
         */
        setSchedule: function(schedule) {
            if (!this._loadedAlert || !this._loadedAlert.template) { return; }
            this._loadedAlert.template.setSchedule(schedule);
        },

        /**
         * Sets the message template into the zone associated with the stack and zone indices.
         * @param messageTemplate
         * @param zoneIndex
         * @param stackIndex
         */
        setMessageTemplate: function(messageTemplate, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].messageTemplate = messageTemplate;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].messageTemplate = messageTemplate;
                }
            }
        },

        /**
         * Sets the notification filter into the zone associated with the stack and zone indices.
         * @param notificationFilter
         * @param zoneIndex
         * @param stackIndex
         */
        setNotificationFilter: function(notificationFilter, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].notificationFilter = notificationFilter;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].notificationFilter = notificationFilter;
                }
            }
        },

        /**
         * Gets the notification filter for the zone associated with the stack and zone indices.
         * @param zoneIndex
         * @param stackIndex
         */
        getNotificationFilter: function(zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    return this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].notificationFilter;
                }
                else {
                    return this._loadedAlert.selectedStack.zones[zoneIndex].notificationFilter;
                }
            }
            return null;
        },

        /**
         * Updates the zone name associated with the stack and zone indices.
         * @param zoneName
         * @param zoneIndex
         * @param stackIndex
         */
        setZoneName: function(zoneName,zoneIndex,stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].setName(zoneName);
                    //Redraw the overlay since the content changed.
                    if (this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].nameOverlay) {
                        this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].nameOverlay.draw();
                    }
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].setName(zoneName);
                    //Redraw the overlay since the content changed.
                    if (this._loadedAlert.selectedStack.zones[zoneIndex].nameOverlay) {
                        this._loadedAlert.selectedStack.zones[zoneIndex].nameOverlay.draw();
                    }
                }
            }
        },

        /**
         * Sets the message template for the fallback zone.
         * @param messageTemplate
         */
        setFallbackMessageTemplate: function(messageTemplate) {
            if (this._fallbackZone) {
                this._fallbackZone.messageTemplate = messageTemplate;
            }
        },

        /**
         * Sets the notification filter for the fallback zone.
         * @param notificationFilter
         */
        setFallbackNotificationFilter: function(notificationFilter) {
            if (this._fallbackZone) {
                this._fallbackZone.notificationFilter = notificationFilter;
            }
        },

        /**
         * Gets the notification filter for the fallback zone.
         */
        getFallbackNotificationFilter: function() {
            if (this._fallbackZone) {
                return this._fallbackZone.notificationFilter;
            }
            return null;
        },

        /**
         * Updates the zone name for the fallback zone.
         * @param zoneName
         */
        setFallbackZoneName: function(zoneName) {
            if (this._fallbackZone) {
                this._fallbackZone.setName(zoneName);
                //Redraw the overlay since the content changed.
                if (this._fallbackZone.nameOverlay) {
                    this._fallbackZone.nameOverlay.draw();
                }
            }
        },

        //******************PRIVATE API******************

        /**
         * Fetches the region boundary for the realm.
         * @returns {Promise}
         * @private
         */
        _fetchRealmRegion: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findRegions({realm:_this.realm, account:_this.account,
                                           query:{"_id":_this.realm+"_region"}
                }).then(function (regions) {
                    if (!regions || !regions[0]) { return resolve(); }
                    //Filter out the alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches an alert template that matches the passed id.
         * @param id
         * @private
         */
        _fetchAlertTemplate: function(id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findAlertTemplates({
                    realm: this.realm,
                    account: this.account,
                    query: {"_id":id}
                }).then(function (results) {
                    if (!results || !results.length) {
                        if (_this.nodeName === 'VOYENT-ALERT-VIEW') {
                            return resolve(null);
                        }
                        _this.fire('message-error', 'Alert template not found');
                        return reject('Alert template not found');
                    }
                    resolve(results[0]);
                }).catch(function (error) {
                    _this.fire('message-error', 'Error fetching alert template: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches alert template categories from realm scope and builds an object array from the results.
         */
        _fetchTemplateCategories: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.set('_templateCategories',[]);
                _this.set('_filteredTemplateCategories',[]);
                voyent.scope.getRealmData({"property":"templateCategories"}).then(function (categories) {
                    if (categories && categories.length) {
                        //Build an object array to simplify template logic for category editing.
                        _this.set('_templateCategories',categories.map(function(categoryName) {
                            return {
                                "id": _this._generateUid(), //This is will be used to find the associated category name input for editing validation
                                "name": categoryName,
                                "editable": true,
                                "newName": '',
                                "editing": false
                            }
                        }));
                    }
                    //Always add the "Mobile" category but we'll be sure not to persist this.
                    _this.push('_templateCategories',{
                        "id": _this._generateUid(),
                        "name": 'Mobile',
                        "editable": false
                    });
                    //Add the "Sample" category if the realm has permission to add new sample templates.
                    if (_this._isVrasAdministratorRealm) {
                        _this.push('_templateCategories',{
                            "id": _this._generateUid(),
                            "name": 'Sample',
                            "editable": false
                        });
                    }
                    _this.set('_filteredTemplateCategories',_this._templateCategories.slice(0));
                    resolve(_this._templateCategories);
                }).catch(function (error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches the most recent User or alert location depending on whether we are passed an alertId.
         * @param alertId
         * @private
         */
        _fetchLocationRecord: function(alertId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var query = {};
                if (alertId && typeof alertId === 'string') {
                    query = {"location.properties.alertId":alertId};
                }
                else {
                    query = {
                        "location.properties.alertId": {"$exists":false},
                        "location.properties.vras.type": "mobile"
                    };
                    query.username = voyent.auth.getLastKnownUsername();
                }
                //Only get the last location.
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,query:query,
                    options:{"sort":{"lastUpdated":-1},"limit":1}}).then(function(location) {
                    //Only error out for alerts.
                    if (alertId) {
                        if ((!location || !location[0])) {
                            if (_this.nodeName === 'VOYENT-ALERT-VIEW') {
                                return resolve(null);
                            }
                            return reject('Alert location cannot be found');
                        }
                    }
                    else {
                        if ((!location || !location[0])) {
                            return resolve();
                        }
                    }
                    resolve(location[0]);
                }).catch(function(error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches existing fixed location records, groups them by id and keeps only the latest.
         * @returns {Promise}
         * @private
         */
        _fetchMyLocations: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.query.executeQuery({
                    realm:_this.realm, account:_this.account,
                    id:"getMyLocationsForUsername", execParams: {username:voyent.auth.getLastKnownUsername()}
                }).then(function(locations) {
                    if (_this.nodeName === 'VOYENT-MY-LOCATIONS') {
                        //Clear the map and draw the locations.
                        _this._loadedLocation = null;
                        _this._clearMyLocations();
                        _this._drawMyLocations(locations);
                    }
                    else {
                        locations = locations.map(function(obj) {
                            return obj.location;
                        })
                    }
                    resolve(locations);
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching location records: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed locations on the map.
         * @param locations
         * @private
         */
        _drawMyLocations: function(locations) {
            for (var i=0; i<locations.length; i++) {
                this.push('_myLocations',new this._MyLocation(
                    locations[i].location.properties.vras.id,
                    locations[i].location.properties.vras.name,
                    locations[i].location.properties.vras.type,
                    new google.maps.Marker({
                        position: new google.maps.LatLng(
                            locations[i].location.geometry.coordinates[1],
                            locations[i].location.geometry.coordinates[0]
                        ),
                        map: this._map,
                        draggable: this.nodeName === 'VOYENT-MY-LOCATIONS',
                        icon: this._MY_LOCATION_ICON_INACTIVE
                    })
                ));
            }
        },

        /**
         * Clears the map of all drawn locations.
         * @private
         */
        _clearMyLocations: function() {
            for (var i=0; i<this._myLocations.length; i++) {
                this._myLocations[i].removeFromMap();
            }
            this.set('_myLocations',[]);
        },

        /**
         * Draws the passed region on the map as an invisible polygon. We'll use the polygon
         * for setting the map bounds or favouring autocomplete results to it's area.
         * @param region - The region to be drawn, in GeoJSON format.
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path;
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j=0; j<coords.length; j++) {
                path = [];
                for (var k=0; k<coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    bounds.extend(googlePoint);
                }
                paths.push(path);
            }
            var polygon;
            //If we have an existing polygon then just modify it.
            if (this._areaRegion && this._areaRegion.polygon) {
                polygon = this._areaRegion.polygon;
                polygon.setPaths(paths);
            }
            else {
                //Create the invisible polygon object.
                polygon = new google.maps.Polygon({
                    paths: paths, map: this._map, visible: false
                });
            }
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon,"bounds":bounds};
            this._regionMapping[this.realm] = this._areaRegion;
            //Pan the map on the new region but only if we haven't already loaded an alert in one of
            //our editors, otherwise the map will pan to the alert and then snap back to the region.
            if ((this.nodeName !== 'VOYENT-ALERT-EDITOR' || !this.isAlertLoaded) &&
                (this.nodeName !== 'VOYENT-ALERT-TEMPLATE-EDITOR' || !this.isTemplateLoaded) &&
                (this.nodeName !== 'VOYENT-MOBILE-ALERT-EDITOR' || !this.isAlertLoaded)) {
                this._zoomOnRegion();
            }
        },

        /**
         * Zooms on the realm region.
         * @private
         */
        _zoomOnRegion: function() {
            if (this._areaRegion && this._areaRegion.bounds && !this._skipRegionPanning) {
                this._map.fitBounds(this._areaRegion.bounds);
                this._map.panToBounds(this._areaRegion.bounds);
            }
        },

        /**
         * Draws the passed alert or alert template on the map.
         * @param templateJSON - The JSON to build the alert template from.
         * @param latLngCentroid - An optional LatLng object specifying the centroid of the template. When this is not
         *                         provided we will calculate the centroid based on the template's stack coordinates.
         * @private
         */
        _drawAndLoadAlertTemplate: function(templateJSON,latLngCentroid) {
            var properties, zoneGeometries, zones, zoneStacks = [], zIndex, stackMarker;
            //Add the zone stacks if we have a geo property. Without this it means we only have the fallback zone defined.
            if (templateJSON.geo) {
                var zoneStackGeometries = templateJSON.geo.geometries.reduce(function(stackGroups, item) {
                    stackGroups[item.stackId] = stackGroups[item.stackId] || [];
                    stackGroups[item.stackId].push(item);
                    return stackGroups;
                },{});
                for (var stackId in zoneStackGeometries) {
                    zoneGeometries = zoneStackGeometries[stackId];
                    zones = [];
                    zIndex = 49;
                    for (var i=0; i<zoneGeometries.length; i++) {
                        properties = templateJSON.properties[zoneGeometries[i].id];
                        if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                            //For alert detail notification view show the inner zone of each relevant stack.
                            if (this.mode === 'notification') {
                                if (i >= 1) { break; }
                            }
                            //For alert detail view and preview show the requested zone only, if available.
                            else if (this._zoneIdToDisplay) {
                                if (this._foundZoneIdMatch) {
                                    this._foundZoneIdMatch = false;
                                    break;
                                }
                                if (this._zoneIdToDisplay === zoneGeometries[i].id) {
                                    this._foundZoneIdMatch = true;
                                }
                                else { continue; }
                            }
                        }
                        // Generate the ordered sequence of coordinates that completes the Polygon shape.
                        zones.push(new this._AlertZone(
                            zoneGeometries[i].id, properties.name,
                            this._AlertTemplate.calculatePathsFromCoordinates(zoneGeometries[i].coordinates),
                            properties.shape === 'circle', properties.opacity, properties.colour,
                            properties.messageTemplate, properties.notificationFilter, zIndex)
                        );
                        if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                            //Add click listener to the zone so the user can click anywhere on the map to enable fullscreen.
                            this._addFullscreenClickListener(zones[zones.length-1].shapeOverlay);
                        }
                        zIndex--;
                    }
                    //Build the stack marker, calculate the position using by building JSON that represents only the stack.
                    if (zones.length) {
                        stackMarker = new google.maps.Marker({
                            position: this._AlertTemplate.calculateCentroidFromJSON({
                                "geo": {
                                    "type": "GeometryCollection",
                                    "geometries": zoneGeometries
                                }
                            }),
                            map: this._map, draggable: true, zIndex: 50,
                            visible: this.nodeName !== 'VOYENT-ALERT-VIEW',
                            cursor: 'move'
                        });

                        zoneStacks.push(new this._AlertZoneStack(stackId, stackMarker, zones));
                    }
                }
            }

            var parentId = templateJSON.properties.parentAlertId || null;
            var alertFamilyId = templateJSON.properties.alertFamilyId || null;
            //We only want to create a template marker if we have more than
            //one stack, otherwise the stack marker will just be used.
            var templateMarker;
            if (zoneStacks.length > 1) {
                templateMarker = new google.maps.Marker({
                    position: (latLngCentroid ? latLngCentroid : this._AlertTemplate.calculateCentroidFromJSON(templateJSON)),
                    map: this._map, draggable: true, zIndex: 50,
                    icon: this.pathtoimages+'/img/move_icon.png',
                    visible: this.nodeName !== 'VOYENT-ALERT-VIEW',
                    cursor: 'move'
                });
            }
            this.set('_loadedAlert', {
                template: new this._AlertTemplate(
                    templateJSON._id, parentId, alertFamilyId, templateJSON.name, templateJSON.badge,
                    templateMarker, zoneStacks, templateJSON.state, !!templateJSON.properties.center,
                    templateJSON.schedule, templateJSON.categories
                ),
                selectedStack: zoneStacks.length === 1 ? zoneStacks[0] : null
            });
            //If we were provided a centroid for the template then we need to move the centroid of the zones from the current
            //position to the new one. To do this we will first calculate their current position based on the template and then
            //move them to the new coordinate while maintaining the distance and bearing they were from the original position.
            if (latLngCentroid) {
                this._loadedAlert.template.calculateRelativeStackPositions(this._AlertTemplate.calculateCentroidFromJSON(templateJSON));
                this._loadedAlert.template.moveStacksRelativeToPosition(latLngCentroid);
                //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                this._loadedAlert.template.initializePolygonStackPathListeners();
            }
            //Draw the fallback zone but only if we have properties
            //other then enabled set (checking name exists is sufficient).
            if (this.nodeName !== 'VOYENT-ALERT-VIEW' ||
                (this.nodeName === 'VOYENT-ALERT-VIEW' && this.mode !== 'notification' && (!this._zoneIdToDisplay || this._zoneIdToDisplay === this._FALLBACK_ZONE_ID))) {
                var fallbackZoneProperties = templateJSON.properties[this._FALLBACK_ZONE_ID];
                if (fallbackZoneProperties && fallbackZoneProperties.name) {
                    this._fallbackZone = new this._FallbackAlertZone(
                        fallbackZoneProperties.enabled,
                        fallbackZoneProperties.name,
                        fallbackZoneProperties.opacity,
                        fallbackZoneProperties.colour,
                        fallbackZoneProperties.messageTemplate,
                        fallbackZoneProperties.notificationFilter,
                        fallbackZoneProperties.zIndex
                    );
                }
            }
            if (this.nodeName !== 'VOYENT-ALERT-VIEW' || this.mode !== 'notification') {
                this._adjustBoundsAndPan();
            }
        },

        /**
         * Initialize the listeners for drawing a new alert template on the map.
         * @private
         */
        _setupDrawingListeners: function() {
            var _this = this, zone;
            google.maps.event.addListener(this._drawingManager, 'overlaycomplete', function (oce) {
                //We do this async so the _drawingCancelled property has time to be applied. This allows
                //the user to toggle the drawing mode off mid-draw by clicking the draw button.
                setTimeout(function() {
                    if (_this._drawingCancelled) {
                        oce.overlay.setMap(null);
                        _this.set('_drawingCancelled',false);
                        return;
                    }
                    var paths;
                    if (oce.type === 'circle') {
                        paths = _this._AlertTemplate.calculatePathsFromCircleProperties(oce.overlay.getCenter(),oce.overlay.getRadius());
                    }
                    else { //polygon
                        paths = oce.overlay.getPaths();
                    }
                    //Check if the new zone overlaps another zone stack.
                    if (_this._alertHasIntersectingStacks(paths)) {
                        _this._displayStackOverlapMsg();
                        oce.overlay.setMap(null);
                        return;
                    }
                    //Check if they drew a self-intersecting polygon and if so remove it from the map and notify them.
                    if (oce.type === 'polygon') {
                        var kinks = turf.kinks({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": _this._AlertTemplate.calculateCoordinatesFromPaths(paths)
                            }
                        });
                        if (kinks.features.length) {
                            _this.fire('message-error','The zone cannot self-intersect');
                            oce.overlay.setMap(null);
                            return;
                        }
                    }
                    _this._openDialog('Add New Zone','Enter the zone name','','Must provide a zone name',null,false,false,function() {
                        //Build our stack marker, the position will be added later.
                        var stackMarker = new google.maps.Marker({
                            map: _this._map, draggable: true, zIndex: 50, cursor: 'move'
                        });
                        if (oce.type === 'circle') { //Circular template.
                            stackMarker.setPosition(oce.overlay.getCenter());
                        }
                        else { //Polygonal template.
                            //If cancelled via esc, Google will still draw the polygon so we need to remove it from the map.
                            if (_this._drawingCancelled) {
                                oce.overlay.setMap(null);
                                _this._drawingCancelled = false;
                                return;
                            }
                            stackMarker.setPosition(_this._AlertTemplate.calculateCentroidFromPaths(paths));
                        }
                        zone = new _this._AlertZone(null,_this._dialogInput,paths,oce.type === 'circle');

                        var zoneStack = new _this._AlertZoneStack(null, stackMarker, [zone]);
                        //Add the stack and fire the zone added event.
                        _this._loadedAlert.template.addZoneStack(zoneStack);
                        _this.fire('voyent-alert-zone-added',{"id":zone.id,"zone":zone,"stack":zoneStack,"isFallbackZone":false});
                        //Toggle the accordion closed for the current stack and load the new one.
                        _this._toggleProperties(-1);
                        _this.set('_loadedAlert.selectedStack',zoneStack);
                        _this._toggleProperties(0);
                        //When we have only one stack we don't have a template marker, just the marker for the zone stack.
                        //So once we have two zone stacks we need to create the marker and if we have more than two (the
                        //marker exists already) then we'll update it's position.
                        if (_this._loadedAlert.template.zoneStacks.length === 2) {
                            _this._loadedAlert.template.setMarker(new google.maps.Marker({
                                position: _this._AlertTemplate.calculateCentroidFromJSON(_this._loadedAlert.template.json),
                                draggable: true, zIndex: 50,
                                map: _this._map,
                                icon: _this.pathtoimages+'/img/move_icon.png',
                                cursor: 'move'
                            }));
                        }
                        else if (_this._loadedAlert.template.zoneStacks.length > 2) {
                            _this._loadedAlert.template.updateJSONAndCentroid();
                        }
                        //To keep things simple we'll always use our custom classes for
                        //drawing the shapes so remove the google-drawn shape from the map.
                        oce.overlay.setMap(null);
                        //Re-punch out the fallback zone.
                        if (_this._fallbackZone) {
                            _this._fallbackZone.punchOutOverlay();
                        }
                        _this._disableDrawingMode();
                        _this._adjustBoundsAndPan();
                    },function() {
                        oce.overlay.setMap(null);
                        _this.set('_drawingCancelled',false);
                    });
                },0);
            });
            //When the escape key is pressed exit drawing mode.
            window.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    if (_this.nodeName === 'VOYENT-ALERT-EDITOR' && _this._showTemplateListPane) {
                        _this._cancelNewAlert();
                        _this._revertCursor();
                    }
                    var drawingMode = _this._drawingManager.getDrawingMode();
                    if (drawingMode !== null) {
                        // Flag so overlaycomplete listener won't be allowed to proceed after
                        // cancelling a polygon mid-draw (not relevant for circles).
                        if (drawingMode === google.maps.drawing.OverlayType.POLYGON) {
                            _this._drawingCancelled = true;
                        }
                        _this._disableDrawingMode();
                    }
                    else if (_this._isFullscreenMode) {
                        _this._toggleFullscreenContainer(true);
                    }
                }
            });
        },

        /**
         * Clears the map of overlays associated with the currently loaded alert template.
         */
        _removeAlertTemplateFromMap: function() {
            //Remove the entire template from the map.
            if (this._loadedAlert) {
                this._loadedAlert.template.removeFromMap();
                this._loadedAlert = null;
            }
            if (this._fallbackZone) {
                this._fallbackZone.removeFromMap();
            }
        },

        /**
         * Determines the northern most coordinate of the passed coordinates array,
         * used to calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns []
         * @private
         */
        _determineNorthernCoordinate: function(coordinates) {
            var northernCoordinate =[-100,null,-100];
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > northernCoordinate[1]) {
                    northernCoordinate = coordinates[i];
                }
            }
            return northernCoordinate;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         * @private
         */
        _calcMapSize: function() {
            var _this = this;
            this._mapIsReady().then(function() {
                //Calculate and set the height
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (typeof height === 'undefined' || !height || height < 0) {
                        if (_this._isFullscreenMode) {
                            height = _this.querySelector('#'+_this._FULLSCREEN_CONTAINER_ID).clientHeight;
                        }
                        else {
                            height = _this._map.getDiv().parentElement.parentElement.parentElement.clientHeight;
                        }
                    }
                    //If we still don't have a valid height default to the last valid height or a 400px minimum
                    if (height < 50) {
                        height = _this._lastHeight > 50 ? _this._lastHeight : 400;
                    }
                }
                _this.customStyle['--map-height'] = height + 'px';
                _this._lastHeight = height;

                //Calculate and set the width
                var width = _this.width;
                //If the width is specified then set it
                if (typeof width === 'undefined' || !width || width < 0) {
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' || _this.nodeName === 'VOYENT-ALERT-EDITOR') {
                        width = (_this._map.getDiv().parentElement.offsetWidth - _this.querySelector('#'+_this._SIDE_PANEL_ID).offsetWidth);
                        //-20px for map borders and padding when not in fullscreen mode
                        if (!_this._isFullscreenMode) {
                            width -= 20;
                        }
                    }
                    else {
                        width = _this._map.getDiv().parentElement.offsetWidth;
                    }
                }
                //If we still don't have a valid width default to the last width or a 400px minimum
                if (width < 50) {
                    width = _this._lastWidth > 50 ? _this._lastWidth : 400;
                }
                _this.customStyle['--map-width'] = width + 'px';
                _this._lastWidth = width;

                //Apply the styles
                _this.updateStyles();
                //Update the position of any displayed tooltips.
                if (_this._tooltipsDisplayed) {
                    _this._repositionTooltips();
                }
            });
        },

        /**
         * Adds the button for creating new circular zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addCircleButton: function(listener,cb) {
            this._addCustomControl(this._CIRCLE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the button for creating new polygonal zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addPolygonButton: function(listener,cb) {
            this._addCustomControl(this._POLYGON_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the button for toggling the fallback zone.
         * @param listener
         * @param cb
         * @private
         */
        _addFallbackZoneButton: function(listener,cb) {
            this._addCustomControl(this._FALLBACK_ZONE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT,listener,cb);
        },

        /**
         * Adds the circle, polygon and fallback zone buttons.
         * @private
         */
        _addAlertTemplateButtons: function() {
            var _this = this;
            //The controls API doesn't like it when we try to inject controls too quickly so we'll use a callback chain to
            //add each button after the other one has been added successfully. Without this Google adds the buttons but
            //they end up all stacked up on top of each other, likely because the styling doesn't have time to update.
            this._addCircleButton(this._circleButtonListener.bind(this),function() {
                _this._addPolygonButton(_this._polygonButtonListener.bind(_this),function() {
                    _this._addFallbackZoneButton(_this._fallbackZoneButtonListener.bind(_this));
                });
            });
        },

        /**
         * Adds the button for toggling fullscreen mode.
         * @private
         */
        _addFullscreenButton: function() {
            this._isFullscreenMode = false;
            this._addCustomControl(
                this._FULLSCREEN_BUTTON_ID,
                google.maps.ControlPosition.RIGHT_TOP,
                this._fullscreenButtonListener.bind(this),
                null
            );
            //Add click listener to the map so the user can click on the map to enable fullscreen
            this._addFullscreenClickListener(this._map);
        },

        /**
         * Removes the button for creating new circular zone stacks.
         * @private
         */
        _removeCircleButton: function() {
            this._removeCustomControl(this._CIRCLE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the button for creating new polygonal zone stacks.
         * @private
         */
        _removePolygonButton: function() {
            this._removeCustomControl(this._POLYGON_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the button for toggling the fallback zone.
         * @private
         */
        _removeFallbackZoneButton: function() {
            this._removeCustomControl(this._FALLBACK_ZONE_BUTTON_ID,google.maps.ControlPosition.TOP_RIGHT);
        },

        /**
         * Removes the circle, polygon and fallback zone buttons.
         * @private
         */
        _removeAlertTemplateButtons: function() {
            this._removeCircleButton();
            this._removePolygonButton();
            this._removeFallbackZoneButton();
        },

        /**
         * Removes the button for toggling fullscreen mode.
         * @private
         */
        _removeFulscreenButton: function() {
            this._removeCustomControl(this._FULLSCREEN_BUTTON_ID,google.maps.ControlPosition.RIGHT_TOP);
        },

        /**
         * Adds custom controls (draw buttons, legends, etc..).
         * @param id - The id of the button to create.
         * @param position - The control position.
         * @param listener - The click listener.
         * @param cb - An optional callback that will be executed after the button has been added.
         * @private
         */
        _addCustomControl: function(id,position,listener,cb) {
            var _this = this;
            this._mapIsReady().then(function() {
                // Use the saved button reference to check if the button already exists (eg. this._fullscreenBttn)
                if (!_this['_'+id]) {
                    // Clone the node so the control does not flicker on the page before being positioned
                    _this['_'+id] = _this.$$('#'+id).cloneNode(true);
                    // Append "_cc" to the id so we can find the custom control easily later
                    _this['_'+id].setAttribute('id',_this['_'+id].id+'_cc');
                    // Remove the hidden attribute so the control is displayed when added to the DOM
                    _this['_'+id].removeAttribute('hidden');
                    // Add the click listener
                    if (listener) {
                        _this['_'+id].onclick = listener;
                    }
                    // Add the button to the DOM by adding it to the map controls
                    _this._map.controls[position].push(_this['_'+id]);
                    //Call our callback function, if provided.
                    if (cb && typeof cb === 'function') { cb(); }
                }
            });
        },

        /**
         * Redraws custom controls (draw buttons, legends, etc..). This function is used when we need to update the state
         * of the custom control because the data bindings do not apply to the control once positioned since it is cloned.
         * @param id - The id of the button to create.
         * @param position - The control position.
         * @param listener - The click listener.
         * @param cb - An optional callback that will be executed after the button has been redrawn.
         * @private
         */
        _redrawCustomControl: function(id,position,listener,cb) {
            var _this = this;
            // Async so the styling and bindings have time to update before cloning
            setTimeout(function() {
                if (_this['_'+id]) {
                    var oldControl = _this['_'+id];
                    // Clone the node so the control does not flicker on the page before being positioned
                    _this['_'+id] = _this.$$('#'+id).cloneNode(true);
                    // Append "_cc" to the id so we can find the custom control easily later
                    _this['_'+id].setAttribute('id',_this['_'+id].id+'_cc');
                    // Remove the hidden attribute so the control is displayed when added to the DOM
                    _this['_'+id].removeAttribute('hidden');
                    // Add the click listener
                    if (listener) {
                        _this['_'+id].onclick = listener;
                    }
                    // Replace the existing button in the in the map controls
                    var index = _this._map.controls[position].indexOf(oldControl);
                    if (index > -1) {
                        _this._map.controls[position].removeAt(index);
                        _this._map.controls[position].insertAt(index,_this['_'+id]);
                    }
                    //Call our callback function, if provided.
                    if (cb && typeof cb === 'function') { cb(); }
                }
            },0);
        },

        /**
         * Removes custom controls (draw buttons, legends, etc..).
         * @param id - The id of the button to remove.
         * @param position - The control position.
         * @private
         */
        _removeCustomControl: function(id,position) {
            if (!this._map || !this._map.controls) { return; }
            var index = this._map.controls[position].indexOf(this['_'+id]);
            if (index > -1) {
                this._map.controls[position].removeAt(index);
                this['_'+id] = null;
            }
        },

        /**
         * The listener to fire when the circle button is clicked.
         * @private
         */
        _circleButtonListener: function() {
            this._deselectDrawingButtons();
            if (this._drawingManager.getDrawingMode() === google.maps.drawing.OverlayType.CIRCLE) {
                this._drawingManager.setDrawingMode(null);
                return;
            }
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);
            // Select the custom control (+ '_cc')
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID+'_cc');
            if (circleButton) {
                this.toggleClass('selected', true, circleButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the polygon button is clicked.
         * @private
         */
        _polygonButtonListener: function() {
            this._deselectDrawingButtons();
            if (this._drawingManager.getDrawingMode() === google.maps.drawing.OverlayType.POLYGON) {
                this._drawingManager.setDrawingMode(null);
                // Indicate that drawing was cancelled because for polygons the overlaycomplete will fire after cancelling
                this.set('_drawingCancelled',true);
                return;
            }
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            // Select the custom control (+ '_cc')
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID+'_cc');
            if (polygonButton) {
                this.toggleClass('selected', true, polygonButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the fallback zone button is clicked.
         * @private
         */
        _fallbackZoneButtonListener: function() {
            this._disableDrawingMode();
            if (this._fallbackZone && this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(false);
            }
            else if (this._fallbackZone && !this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(true);
            }
            else {
                this._fallbackZone = new this._FallbackAlertZone(true);
                this._deselectStacksOnClick(this._fallbackZone.shapeOverlay);
            }
        },

        /**
         * The listener to fire when the fullscreen button is clicked.
         * @private
         */
        _fullscreenButtonListener: function() {
            this._toggleFullscreenContainer(true);
        },

        /**
         * Removes Google's "Stop drawing" hand button from the top-right corner.
         * @private
         */
        _removeStopDrawingButton: function() {
            if (!this._stopDrawingButtonRemoved) {
                var _this = this;
                function waitForStopDrawingButton() {
                    var stopDrawingButton = document.querySelector('div[title="Stop drawing"]');
                    if (!stopDrawingButton) {
                        setTimeout(waitForStopDrawingButton, 10);
                        return;
                    }
                    stopDrawingButton.parentNode.removeChild(stopDrawingButton);
                    _this._stopDrawingButtonRemoved = true;
                }
                waitForStopDrawingButton();
            }
        },

        /**
         * Toggles the modal fullscreen dialog.
         * @param toggledByUser - A flag indicating whether the fullscreen container is being toggled by the user
         * via page interaction or whether the component itself toggled the fullscreen container. We use
         * this flag to manage the map panning behaviour when switching mobile orientation (VRAS-306).
         * @private
         */
        _toggleFullscreenContainer: function(toggledByUser) {
            if (toggledByUser) {
                this._fullscreenEnabledByUser = !this._isFullscreenMode;
                if (!this._fullscreenEnabledByUser) {
                    this._mapCenterBeforeOrientationChange = null;
                }
            }
            // Open or close the dialog depending on the current state
            if (this._isFullscreenMode) {
                this._closeFullscreenContainer();
            }
            else {
                // Ensure that when the fullscreen container is opened by the user that we force the map pan operation
                // for the initial load rather than skipping it which we will do afterwards until they close it (VRAS-306).
                this._openFullscreenContainer(toggledByUser);
            }
            this._isFullscreenMode = !this._isFullscreenMode;
            // Toggle the editable features of the map
            if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                this._toggleEditableMap(this._isFullscreenMode);
            }
        },

        /**
         * Opens the fullscreen modal dialog.
         * @param forceMapPan
         * @private
         */
        _openFullscreenContainer: function(forceMapPan) {
            var dialog = this.querySelector('#'+this._FULLSCREEN_CONTAINER_ID);
            if (dialog) {
                // Display the dialog
                dialog.removeAttribute('hidden');
                // Save the current map width before moving it into the dialog container
                var mapDiv = this._map.getDiv();
                if (this.width) {
                    this._beforeFullscreenWidth = this.width;
                    this.width = null;
                }
                if (this.height) {
                    this._beforeFullscreenHeight = this.height;
                    this.height = null;
                }
                // Toggle button visibility so that the close button is displayed (select the custom controls (+ '_cc'))
                var buttonContainer = this.querySelector('#'+this._FULLSCREEN_BUTTON_ID+'_cc');
                if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                    buttonContainer.querySelector('#closeButton').removeAttribute('hidden');
                    buttonContainer.querySelector('#openButton').setAttribute('hidden','hidden');
                }
                else {
                    buttonContainer.setAttribute('title','Exit Fullscreen Mode');
                }
                // Move the map to the dialog container, adjust the size and add the esc key listener
                dialog.append(mapDiv);
                if (this.nodeName === 'VOYENT-ALERT-EDITOR' || this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                    dialog.append(this.querySelector('#'+this._SIDE_PANEL_ID));
                }
                this.resizeMap(forceMapPan);
            }
        },

        /**
         * Closes the fullscreen modal dialog.
         * @private
         */
        _closeFullscreenContainer: function() {
            // Restore the original map width before moving it to the inline container
            if (this._beforeFullscreenWidth) {
                this.width = this._beforeFullscreenWidth;
            }
            if (this._beforeFullscreenHeight) {
                this.height = this._beforeFullscreenHeight;
            }
            // Toggle button visiblity so that the fullscreen button is displayed (select the custom controls (+ '_cc'))
            var buttonContainer = this.querySelector('#'+this._FULLSCREEN_BUTTON_ID+'_cc');
            if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                buttonContainer.querySelector('#openButton').removeAttribute('hidden');
                buttonContainer.querySelector('#closeButton').setAttribute('hidden','hidden');
            }
            else {
                buttonContainer.setAttribute('title','Enter Fullscreen Mode');
            }
            // Move the map to the inline container, adjust the size and remove the esc key listener
            var mapDiv = this._map.getDiv();
            this.querySelector('#'+this._CONTAINER_ID).append(mapDiv);
            if (this.nodeName === 'VOYENT-ALERT-EDITOR' || this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                this.querySelector('#'+this._CONTAINER_ID).append(this.querySelector('#'+this._SIDE_PANEL_ID));
            }
            this.resizeMap();
            // Hide the dialog
            var dialog = this.querySelector('#'+this._FULLSCREEN_CONTAINER_ID);
            if (dialog) {
                dialog.setAttribute('hidden','hidden');
            }
        },

        /**
         * Adds a map click listener for mobile devices so that when the map
         * is windowed clicking on the map will enable fullscreen mode.
         * @private
         */
        _addFullscreenClickListener: function(mapElement) {
            var _this = this;
            if (this.nodeName === 'VOYENT-ALERT-VIEW' && this.mode === 'notification') {
                google.maps.event.addListener(mapElement, 'click', function() {
                    if (_this._isFullscreenMode) {
                        return;
                    }
                    _this._toggleFullscreenContainer(true);
                });
            }
        },

        /**
         * Updates the map bounds so all the map overlays are in view and then pans the map.
         * @param forceMapPan
         * @private
         */
        _adjustBoundsAndPan: function(forceMapPan) {
            if (this._fullscreenEnabledByUser && !forceMapPan) { //VRAS-306
                if (this._mapCenterBeforeOrientationChange) {
                    this._map.setCenter(this._mapCenterBeforeOrientationChange);
                }
                return;
            }
            if (this._loadedAlert || (this.nodeName === 'VOYENT-ALERT-VIEW' && (this._mobileLocation || this._myLocations))) {
                var bounds = new google.maps.LatLngBounds(), boundsExtended = false, i, zoneStacks, locationsToPanTo = [];
                if (this._loadedAlert) {
                    zoneStacks = this._loadedAlert.template.zoneStacks;
                    if ((zoneStacks.length && (!this._affectedStackIds || !this._affectedStackIds.length)) || !zoneStacks.length) {
                        //If we don't have any zone stacks or we do and they have no affected
                        //locations then we will include the region boundary in the map bounds.
                        if (this.mode === 'notification') {
                            if (this._areaRegion && this._areaRegion.bounds) {
                                bounds.extend(this._areaRegion.bounds.getNorthEast());
                                bounds.extend(this._areaRegion.bounds.getSouthWest());
                                boundsExtended = true;
                            }
                        }
                        else {
                            //Make sure we force pan the region as this flag will be true in cases such as when loading an alert
                            //or template. This fixes an issue where when we load a fallback zone only template after a stacked
                            //template the map wouldn't pan.
                            this._skipRegionPanning = false;
                            this._zoomOnRegion();
                        }
                    }
                    //If we have zoneStacks then include them in the map bounds
                    if (zoneStacks.length) {
                        for (i=0; i<zoneStacks.length; i++) {
                            var largestZone = zoneStacks[i].getLargestZone();
                            if (largestZone) {
                                for (var j=0; j<largestZone.shapeOverlay.getPath().length; j++) {
                                    bounds.extend(largestZone.shapeOverlay.getPath().getAt(j));
                                }
                                boundsExtended = true;
                            }
                        }
                    }
                }
                //Only include the locations in the map panning if we have zone stacks and one of those zone stacks
                //has affected locations. This prevents the map from panning too far from the region boundary and
                //primary zone when the affected locations notified by a fallback zone are far away.
                if (zoneStacks && zoneStacks.length && this._affectedStackIds && this._affectedStackIds.length) {
                    if (this._mobileLocation && (this.mode !== 'notification' || this._affectedLocationIds.indexOf(this._mobileLocation.id) > -1)) {
                        bounds.extend(this._mobileLocation.marker.getPosition());
                        boundsExtended = true;
                    }
                    for (i=0; i<this._myLocations.length; i++) {
                        if (this.mode !== 'notification' || this._affectedLocationIds.indexOf(this._myLocations[i].id) > -1) {
                            bounds.extend(this._myLocations[i].marker.getPosition());
                            locationsToPanTo.push(this._myLocations[i]);
                            boundsExtended = true;
                        }
                    }
                }
                //Ensure we only do this if the bounds were extended otherwise
                //the map may pan to an empty bounds (middle of the ocean).
                if (boundsExtended) {
                    this._map.fitBounds(bounds);
                    this._map.panToBounds(bounds);
                    //Include the name overlays in the map bounds.
                    this._panBoundsForNameOverlays(locationsToPanTo,bounds);
                }
            }
            else {
                this._zoomOnRegion();
            }
        },

        /**
         * Pans the map bounds so that it includes all of the location name overlays in the view. This must be called after the map bounds
         * is already set on the locations so that we can determine the coordinates of the name overlays at the correct zoom level.
         * @param locations
         * @param bounds
         * @private
         */
        _panBoundsForNameOverlays: function(locations, bounds) {
            return; //TODO - Temporarily disable map panning for name overlays
            if (!locations || !locations.length) { return; }
            var _this = this;
            //Async to ensure the map is panned on the markers before proceeding. This
            //is so we can correctly calculate the pixel positions of the name overlays.
            setTimeout(function() {
                var panBounds = false;
                for (var i=0; i<locations.length; i++) {
                    if (_this._extendBoundsForNameOverlay(locations[i],bounds)) {
                        panBounds = true;
                    }
                }
                if (panBounds) {
                    _this._map.fitBounds(bounds);
                    _this._map.panToBounds(bounds);
                }
            },0);
        },

        /**
         * Checks if the map bounds needs to be extended to include the
         * location name overlay in the view and returns whether it was.
         * @param location
         * @param bounds
         * @returns {boolean}
         * @private
         */
        _extendBoundsForNameOverlay: function(location, bounds) {
            var boundsExtended = false;
            if (location.nameOverlay) {
                var overlayProjection = this._overlayView.getProjection();
                //Get the pixel coordinates of the marker position.
                var nc = overlayProjection.fromLatLngToDivPixel(location.marker.getPosition());
                //Include the location name overlay in the map bounds by extending the bounds to include
                //the NW and SE coordinate of the overlay. This will ensure the entire label is in view.
                var nwCoordinate = overlayProjection.fromDivPixelToLatLng(new google.maps.Point(
                    nc.x - location.nameOverlay.div.offsetWidth/2,
                    nc.y-64
                ));
                if (!this._map.getBounds().contains(nwCoordinate)) {
                    bounds.extend(nwCoordinate);
                    boundsExtended = true;
                }
                var seCoordindate = overlayProjection.fromDivPixelToLatLng(new google.maps.Point(
                    nc.x + location.nameOverlay.div.offsetWidth/2,
                    nc.y-64+location.nameOverlay.div.offsetHeight
                ));
                if (!this._map.getBounds().contains(seCoordindate)) {
                    bounds.extend(seCoordindate);
                    boundsExtended = true;
                }
            }
            return boundsExtended;
        },

        /**
         * Set up a click listener on the passed map entity that when clicked will de-select the currently selected stack.
         * @param mapEntity
         * @private
         */
        _deselectStacksOnClick: function(mapEntity) {
            var _this = this;
            google.maps.event.addListener(mapEntity, 'click', function() {
                if (_this._loadedAlert &&  _this._loadedAlert.selectedStack) {
                    _this._loadedAlert.selectedStack.deactivateZoneOverlays();
                    _this.set('_loadedAlert.selectedStack',null);
                    if (!_this._fallbackZone || !_this._fallbackZone.active) {
                        _this.fire('voyent-alert-zone-selected',{
                            "id": null,
                            "zone": null
                        });
                    }
                }
            });
        },

        /**
         * Listens to whether an alert is loading and toggles the flag for skipping region panning.
         * @param isAlertLoading
         * @private
         */
        _isAlertLoading: function(isAlertLoading) {
            this._skipRegionPanning = isAlertLoading;
        },

        /**
         * Disables drawing mode and selected button states.
         * @private
         */
        _disableDrawingMode: function() {
            if (this._drawingManager) {
                this._drawingManager.setDrawingMode(null);
            }
            this._deselectDrawingButtons();
        },

        /**
         * Ensure that all the drawing buttons are styled as de-selected.
         * @private
         */
        _deselectDrawingButtons: function() {
            var bttnClass = '.customMapBttn';
            // Select the custom controls (+ '_cc')
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID+'_cc');
            if (polygonButton) {
                this.toggleClass('selected', false, polygonButton.querySelector(bttnClass));
            }
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID+'_cc');
            if (circleButton) {
                this.toggleClass('selected', false, circleButton.querySelector(bttnClass));
            }
            var fallbackZoneButton = this.querySelector('#'+this._FALLBACK_ZONE_ID+'_cc');
            if (fallbackZoneButton) {
                this.toggleClass('selected', false, fallbackZoneButton.querySelector(bttnClass));
            }
        },

        /**
         * Initializes listeners to manage the max zoom level of the map. This is to
         * ensure that we always have imagery in satellite view modes (see VRAS-367).
         * @private
         */
        _manageMaxZoomLevel: function() {
            var _this = this;

            google.maps.event.addListener(this._map, 'center_changed', function () {
                if (_this._map.get('mapTypeId') === 'satellite' ||
                    _this._map.get('mapTypeId') === 'hybrid') {
                    setMaxZoomLevel();
                }
            });
            google.maps.event.addListener(this._map, 'maptypeid_changed', function() {
                if (_this._map.get('mapTypeId') === 'satellite' ||
                    _this._map.get('mapTypeId') === 'hybrid') {
                    setMaxZoomLevel();
                }
                else {
                    _this._map.setOptions({maxZoom: null});
                }
            });
            function setMaxZoomLevel() {
                new google.maps.MaxZoomService().getMaxZoomAtLatLng(_this._map.getCenter(), function(response) {
                    if (response.status !== 'OK') {
                        return;
                    }
                    //Since Google Maps version 3.32 we must explicitly zoom out if we are zoomed in past the max zoom level.
                    if (_this._map.getZoom() > response.zoom) {
                        _this._map.setZoom(response.zoom);
                    }
                    _this._map.setOptions({maxZoom: response.zoom});
                });
            }
        },

        /**
         * A promise that when resolved indicates that the Google Maps API is available.
         * @returns {*}
         * @private
         */
        _mapsApiAvailable: function() {
            return new Promise(function (resolve) {
                if (('google' in window) && ('maps' in window.google)) {
                    resolve();
                }
                else {
                    waitForMapApi();
                    function waitForMapApi() {
                        if (!('google' in window) || !('maps' in window.google)) {
                            setTimeout(function(){waitForMapApi();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * A promise that when resolved indicates that google maps is ready. Can be used in public facing functions
         * to avoid race conditions where the function tries to execute map related calls before the map is ready.
         * @returns {*}
         * @private
         */
        _mapIsReady: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._map) {
                    resolve();
                }
                else {
                    waitForMap();
                    function waitForMap() {
                        if (!_this._map) {
                            setTimeout(function(){waitForMap();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * A promise that when resolved indicates that we have loaded our realm region.
         * @returns {*}
         * @private
         */
        _areaRegionIsAvailable: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._areaRegion) {
                    resolve();
                }
                else {
                    waitForAreaRegion();
                    function waitForAreaRegion() {
                        if (!_this._areaRegion) {
                            setTimeout(function(){waitForAreaRegion();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * Manages component state between realm changes.
         * @param newRealm
         * @private
         */
        _realmChanged: function(newRealm) {
            //We don't render the region on the map for the alert view.
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                //Only proceed if we have a valid realm and the map is initialized.
                if (!newRealm || !this._map) { return; }
                //First clear the current region from the map.
                if (this._areaRegion && this._areaRegion.polygon) {
                    this._areaRegion.polygon.setMap(null);
                    this._areaRegion = null;
                }
                //Check if we have the realm region cached otherwise fetch it.
                var areaRegion = this._regionMapping && this._regionMapping[newRealm] ?
                    this._regionMapping[newRealm] : null;
                if (areaRegion && areaRegion.polygon) {
                    areaRegion.polygon.setMap(this._map);
                    this._areaRegion = areaRegion;
                }
                else {
                    this._fetchRealmRegion();
                }
            }
            //Clear the map entirely.
            this.clearMap();
        },

        /**
         * Listens for changes to map size related properties and recalculates and sizes the map.
         */
        _mapSizePropertyChanged: function() {
            this._calcMapSize();
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Manages the stack marker icon animation.
         * @param selectedStack
         * @private
         */
        _selectedStackChanged: function(selectedStack) {
            if (selectedStack) {
                // Don't bounce marker on initial load
                if (this.isAlertLoading || this.isTemplateLoading) {
                    return;
                }
                // Bounce the marker once to indicate selection.
                selectedStack.marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(function() {
                    selectedStack.marker.setAnimation(null);
                },700);
            }
        },

        /**
         * Manages selected styling on fallback zone button.
         * @param enabled
         * @private
         */
        _fallbackZoneEnabledChanged: function(enabled) {
            // Select the custom control (+ '_cc')
            var fallbackZoneButton = this.querySelector('#'+this._FALLBACK_ZONE_BUTTON_ID+'_cc');
            if (fallbackZoneButton) {
                this.toggleClass('selected', !!enabled, fallbackZoneButton.querySelector('.customMapBttn'));
                var childDiv = fallbackZoneButton.children[0];
                if (childDiv) {
                    childDiv.setAttribute('title',enabled ? 'Disable Entire Region Zone' : 'Enable Entire Region Zone')
                }
            }
        }
    };
</script>