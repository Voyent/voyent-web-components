<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by map-based `voyent-alert-*` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        /**
         * Fires when the alert template is successfully saved. Does not include any data.
         * @event voyent-alert-template-saved
         */

        /**
         * Fires when the user cancels creating a new template.
         * @event voyent-alert-template-cancel
         */

        /**
         * Fires when the alert template name changes. Includes a `name` property that contains the new value.
         * @event voyent-alert-template-name-changed
         */

        /**
         * Fires when an alert zone name changes. Includes a `name` property that contains the new value, an `id` property
         * which identifies the zone and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-name-changed
         */

        /**
         * Fires when a new alert zone is added to the template. This could be in the form of a completely new stack or
         * adding to an existing stack. Includes an `id` property which identifies the zone, a `zone` property that
         * contains the associated data and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-added
         */

        /**
         * Fired when an alert zone is removed from the template. Includes an `id` property which identifies
         * the zone and an `isFallbackZone` property indicating whether the zone is the fallback zone.
         * @event voyent-alert-zone-removed
         */

        /**
         * Fires when the selected alert zone changes. Includes an `id` property which identifies the zone, a `zone`
         * property that contains the associated data and an `isFallbackZone` property indicating whether the zone is
         * the fallback zone. If no zone is selected then the `id` and `zone` values will be null.
         * @event voyent-alert-zone-selected
         */

        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the alert template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String, observer: '_realmChanged' },
            /**
             * A boolean indicating whether the component should load the Google Maps API. When `false`
             * it is expected that the API is included manually in the application.
             * @default false
             */
            loadGoogleMaps: { type: Boolean, value: false },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: Number,
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: Number,
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             * @default -1
             */
            autoheight: { type: Number, value: -1, notify: true },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             * @default '.'
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' },
            /**
             * The subdirectory where our badge files are stored
             */
            badgedir: { type: String, value: '' }
        },

        observers: [
            '_selectedStackChanged(_loadedAlert.selectedStack)',
            '_fallbackZoneEnabledChanged(_fallbackZone.enabled)'
        ],

        ready: function() {
            //Define some constants.
            this._CIRCLE_BUTTON_ID = 'circleBttn';
            this._POLYGON_BUTTON_ID = 'polygonBttn';
            this._FALLBACK_ZONE_BUTTON_ID = 'fallbackZoneBttn';

            var _this = this;
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            window.initializeLocationsMap = function () {
                var mapOptions = {
                    zoom: 10,
                    center: new google.maps.LatLng(51.08427,-114.13062),
                    streetViewControl: false,
                    fullscreenControl: _this.nodeName === 'VOYENT-ALERT-VIEW',
                    scrollwheel: false,
                    scaleControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.LEFT_TOP
                    },
                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.LARGE,
                        position: google.maps.ControlPosition.LEFT_CENTER
                    }
                };
                if (_this.nodeName !== 'VOYENT-MY-LOCATIONS') {
                    mapOptions.clickableIcons = false;
                }
                //Alert view map is readonly.
                if (_this.nodeName === 'VOYENT-ALERT-VIEW') {
                    mapOptions.mapTypeControl = mapOptions.zoomControl =  mapOptions.draggable = false;
                    mapOptions.disableDoubleClickZoom = true;
                    _this._addFullscreenListener();
                }
                //Initialize the map.
                _this._map = new google.maps.Map(_this.$.map,mapOptions);
                //Calculate the map size.
                _this._calcMapSize();
                if (_this.nodeName !== 'VOYENT-ALERT-VIEW') {
                    //Setup ui and listeners for adding new marker based entities.
                    _this._drawingManager = new google.maps.drawing.DrawingManager({
                        map:_this._map,
                        drawingControlOptions: {
                            position: google.maps.ControlPosition.TOP_RIGHT,
                            drawingModes: []
                        },
                        //This settings only apply to entities created with
                        //the drawing API, not when creating manually.
                        markerOptions: { draggable:true, zIndex:50 }
                    });
                    _this._setupDrawingListeners();
                    _this._removeStopDrawingButton();
                }
                _this._regionMapping = {}; //Map of region data so we can toggle between them.
                _this._isLoggedIn = false; //Toggle for side panel.
                //Custom initialization for each component after login.
                if (voyent.auth.isLoggedIn()) {
                    _this._onAfterLogin();
                }
                else {
                    //We only want to do this on initial login and not access_token refreshes so we'll
                    //save a reference to the listener so we can remove it the first time it fires.
                    var onAfterLoginListener = function() {
                        _this._onAfterLogin();
                        window.removeEventListener('voyent-login-succeeded',onAfterLoginListener);
                    }.bind(_this);
                    window.addEventListener('voyent-login-succeeded',onAfterLoginListener);
                }
                //Make sure the map is always sized correctly when the window size changes.
                window.addEventListener('resize', function() { _this.resizeMap(); });
                //De-select any selected zone stack on map click.
                _this._deselectStacksOnClick(_this._map);
            };
            if (!('google' in window) || !('maps' in window.google)) {
                if (this.loadGoogleMaps) {
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyAZVsIO4CmSqqE7qbSO8pB0JPVUkO5bOd8&v=3&' +
                        'libraries=places,geometry,visualization,drawing&callback=initializeLocationsMap';
                    this.$.container.appendChild(script);
                }
                else {
                    var msg = 'Error initializing ' + this.nodeName.toLowerCase() + ': The attribute `load-google-maps` ' +
                              'is false but the Google Maps API cannot be found. Please load the component before ' +
                              'loading the API or set the attribute to true.';
                    this.fire('message-error',msg);
                    console.error(msg);
                }
            }
            else {
                initializeLocationsMap();
            }
        },

        /**
         * Recalculates the map size, fires the Google Map resize event and pans the map.
         */
        resizeMap: function() {
            var _this = this;
            this._mapIsReady().then(function() {
                _this._calcMapSize();
                //Async so the new dimensions render first.
                setTimeout(function() {
                    google.maps.event.trigger(_this._map, 'resize');
                    _this._adjustBoundsAndPan();
                },0);
            });
        },

        /**
         * Saves or updates the current alert template.
         */
        saveAlertTemplate: function () {
            if (this._savingAlertTemplate) { return; }
            if (!this._validateTemplate()) { return; }

            this._savingAlertTemplate = true;
             var _this = this, msg;
            return new Promise(function (resolve, reject) {
                _this._loadedAlert.template.updateJSON(true);
                var requestOpts = {realm: _this.realm, account: _this.account, alertTemplate: _this._loadedAlert.template.json};
                var func = 'createAlertTemplate';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlertTemplate';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlertTemplate = false;
                    if (func === 'createAlertTemplate') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                        _this.fire('message-info', 'Alert template successfully created');
                    }
                    else {
                        _this.fire('message-info', 'Alert template successfully updated');
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    _this._savingAlertTemplate = false;
                    _this.fire('message-error', 'Issue saving alert template: ' + (e.responseText || e.message || e));
                    reject(msg);
                });
            });
        },

        /**
         * Saves or updates the current alert.
         */
        saveAlert: function() {
            if (this._savingAlert) { return; }
            if (!this._validateTemplate()) { return; }

            this._savingAlert = true;
            var _this = this, msg;

            return new Promise(function (resolve, reject) {
                //Pull the latest JSON from each of the stacks and specify that we want to punch out the circular templates.
                _this._loadedAlert.template.updateJSON(true);
                var requestOpts = {
                    realm: _this.realm,
                    account: _this.account,
                    alert:_this._loadedAlert.template.json,
                    coordinates:_this._buildAlertLocationJSON().location.geometry.coordinates
                };
                var func = 'createAlert';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlert';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlert = false;
                    if (func === 'createAlert') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    //Adjust message based on the component making the request and whether we are saving an alert as a template.
                    _this.fire('message-error', 'Issue saving alert: ' + (e.responseText || e.message || e));
                    _this._savingAlert = false;
                    reject(msg);
                });
            });
        },

        /**
         * Prompts the user to create a new template. On cancel the `voyent-alert-template-cancel` event will be fired.
         */
        addNew: function() {
            var _this = this;
            this._openDialog('Please enter the alert template name','',null,true,function() {
                _this.clearMap();
                
                _this.set('_loadedAlert',{
                    template: new _this._AlertTemplate(null, null, _this._dialogInput, _this._dialogBadge, null, null, null, false, null),
                    selectedStack: null
                });
            },function() {
                _this.fire('voyent-alert-template-cancel',{});
            });
        },

        /**
         * Clears the map entirely. In the case of alert editor the list of templates will also be refreshed.
         */
        clearMap: function() {
            var _this = this;
            this._disableDrawingMode();
            this._zoomOnRegion();
            //Clear loaded alert template.
            if (this._loadedAlert || this._fallbackZone) {
                this._removeAlertTemplateFromMap();
            }
            //Clear the user marker.
            if (this.nodeName === 'VOYENT-ALERT-VIEW') {
                if (this._userLocationMarker) {
                    this._userLocationMarker.setMap(null);
                    this._userLocationMarker = null;
                }
                else if (this._locationMarkers) {
                    this._clearLocations();
                }
            }
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                this.fetchAlertTemplates();
                this._enableDefaultPane();
                this._showMovement = false;
                //Clear the movement inputs, async so the side panel has time to render.
                setTimeout(function() {
                    _this._alertDirection = _this._alertSpeed = null;
                    _this._alertSpeedUnit = 'kph';
                },0);
            }
        },

        /**
         * Sets the alert schedule into the loaded template.
         * @param schedule
         */
        setSchedule: function(schedule) {
            if (!this._loadedAlert || !this._loadedAlert.template) { return; }
            this._loadedAlert.template.setSchedule(schedule);
        },

        /**
         * Sets the message template into the zone associated with the stack and zone indices.
         * @param messageTemplate
         * @param zoneIndex
         * @param stackIndex
         */
        setMessageTemplate: function(messageTemplate, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].messageTemplate = messageTemplate;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].messageTemplate = messageTemplate;
                }
            }
        },

        /**
         * Sets the notification filter into the zone associated with the stack and zone indices.
         * @param notificationFilter
         * @param zoneIndex
         * @param stackIndex
         */
        setNotificationFilter: function(notificationFilter, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].notificationFilter = notificationFilter;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].notificationFilter = notificationFilter;
                }
            }
        },

        /**
         * Sets the message template for the fallback zone.
         * @param messageTemplate
         */
        setFallbackMessageTemplate: function(messageTemplate) {
            if (this._fallbackZone) {
                this._fallbackZone.messageTemplate = messageTemplate;
            }
        },

        /**
         * Sets the notification filter for the fallback zone.
         * @param notificationFilter
         */
        setFallbackNotificationFilter: function(notificationFilter) {
            if (this._fallbackZone) {
                this._fallbackZone.notificationFilter = notificationFilter;
            }
        },

        //******************PRIVATE API******************

        /**
         * Fetches the region boundary for the realm.
         * @returns {Promise}
         * @private
         */
        _fetchRealmRegion: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findRegions({realm:_this.realm, account:_this.account,
                                           query:{"_id":_this.realm+"_region"}
                }).then(function (regions) {
                    if (!regions) { return resolve(); }
                    //Filter out the alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions.filter(function(region) {
                        return !region.location.properties || !region.location.properties.alertId;
                    })[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches an alert template that matches the passed id.
         * @param id
         * @private
         */
        _fetchAlertTemplate: function(id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findAlertTemplates({
                    realm: this.realm,
                    account: this.account,
                    query: {"_id":id}
                }).then(function (results) {
                    if (!results || !results.length) {
                        _this.fire('message-error', 'Alert template not found');
                        return reject('Alert template not found');
                    }
                    resolve(results[0]);
                }).catch(function (error) {
                    _this.fire('message-error', 'Error fetching alert template: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches the most recent User or alert location depending on whether we are passed an alertId.
         * @param alertId
         * @private
         */
        _fetchLocationRecord: function(alertId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var query = {};
                if (alertId && typeof alertId === 'string') {
                    query = {"location.properties.alertId":alertId};
                }
                else {
                    query = {
                        "location.properties.alertId": {"$exists":false},
                        "location.properties.vras.type": "mobile"
                    };
                    query.username = voyent.auth.getLastKnownUsername();
                }
                //Only get the last location.
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,query:query,
                    options:{"sort":{"lastUpdated":-1},"limit":1}}).then(function(location) {
                    //Only error out for alerts.
                    if (alertId) {
                        if ((!location || !location[0])) {
                            return reject('Alert location cannot be found');
                        }
                    }
                    else {
                        if ((!location || !location[0])) {
                            return resolve();
                        }
                        _this._drawUser(location[0]);
                    }
                    resolve(location[0]);
                }).catch(function(error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches existing fixed location records, groups them by id and keeps only the latest.
         * @returns {Promise}
         * @private
         */
        _fetchMyLocations: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.query.executeQuery({
                    realm:_this.realm, account:_this.account,
                    id:"getMyLocationsForUsername", execParams: {username:voyent.auth.getLastKnownUsername()}
                }).then(function(locations) {
                    //Clear the map and draw the locations.
                    _this._loadedLocation = null;
                    _this._clearMyLocations();
                    _this._drawMyLocations(locations);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching location records: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed locations on the map.
         * @param locations
         * @private
         */
        _drawMyLocations: function(locations) {
            for (var i=0; i<locations.length; i++) {
                this._myLocations.push(new this._MyLocation(
                    locations[i].location.properties.vras.id,
                    locations[i].location.properties.vras.name,
                    locations[i].location.properties.vras.type === 'residential',
                    new google.maps.Marker({
                        position: new google.maps.LatLng(
                            locations[i].location.geometry.coordinates[1],
                            locations[i].location.geometry.coordinates[0]
                        ),
                        map: this._map,
                        draggable: this.nodeName === 'VOYENT-MY-LOCATIONS',
                        icon: this._MY_LOCATION_ICON_INACTIVE
                    }),
                    null
                ));
            }
        },

        /**
         * Clears the map of all drawn locations.
         * @private
         */
        _clearMyLocations: function() {
            for (var i=0; i<this._myLocations.length; i++) {
                this._myLocations[i].removeFromMap();
            }
            this._myLocations = [];
        },

        /**
         * Draws the passed region on the map as an invisible polygon. We'll use the polygon
         * for setting the map bounds or favouring autocomplete results to it's area.
         * @param region - The region to be drawn, in GeoJSON format.
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path;
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j=0; j<coords.length; j++) {
                path = [];
                for (var k=0; k<coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    bounds.extend(googlePoint);
                }
                paths.push(path);
            }
            var polygon;
            //If we have an existing polygon then just modify it.
            if (this._areaRegion && this._areaRegion.polygon) {
                polygon = this._areaRegion.polygon;
                polygon.setPaths(paths);
            }
            else {
                //Create the invisible polygon object.
                polygon = new google.maps.Polygon({
                    paths: paths, map: this._map, visible: false
                });
            }
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon,"bounds":bounds};
            this._regionMapping[this.realm] = this._areaRegion;
            //Pan the map on the new region.
            this._zoomOnRegion();
        },

        /**
         * Zooms on the realm region.
         * @private
         */
        _zoomOnRegion: function() {
            if (this._areaRegion && this._areaRegion.bounds && !this._skipRegionPanning) {
                this._map.fitBounds(this._areaRegion.bounds);
                this._map.panToBounds(this._areaRegion.bounds);
                //Zooming on the region will cause the map to be panned out far so we'll force a zoom to the street level.
                this._map.setZoom(14);
            }
        },

        /**
         * Draws the passed alert or alert template on the map.
         * @param templateJSON - The JSON to build the alert template from.
         * @param latLngCentroid - An optional LatLng object specifying the centroid of the template. When this is not
         *                         provided we will calculate the centroid based on the template's stack coordinates.
         * @private
         */
        _drawAndLoadAlertTemplate: function(templateJSON,latLngCentroid) {
            var properties, zoneGeometries, zones, zoneStacks = [], zIndex, stackMarker;
            //Add the zone stacks if we have a geo property. Without this it means we only have the fallback zone defined.
            if (templateJSON.geo) {
                var zoneStackGeometries = templateJSON.geo.geometries.reduce(function(stackGroups, item) {
                    stackGroups[item.stackId] = stackGroups[item.stackId] || [];
                    stackGroups[item.stackId].push(item);
                    return stackGroups;
                },{});
                for (var stackId in zoneStackGeometries) {
                    if (!zoneStackGeometries.hasOwnProperty(stackId)) { continue; }
                    zoneGeometries = zoneStackGeometries[stackId];
                    zones = [];
                    zIndex = 49;
                    for (var i=0; i<zoneGeometries.length; i++) {
                        properties = templateJSON.properties[zoneGeometries[i].id];
                        if (this.nodeName === 'VOYENT-ALERT-VIEW' && !this._showAllZones) {
                            //For alert detail view in preview mode only show the requested zone.
                            if (this._zoneIdToDisplay) {
                                if (this._foundZoneIdMatch) {
                                    this._foundZoneIdMatch = false;
                                    break;
                                }
                                if (this._zoneIdToDisplay === zoneGeometries[i].id) {
                                    this._foundZoneIdMatch = true;
                                }
                                else { continue; }
                            }
                            else {
                                //For alert detail view in non-preview mode only show the inner zone of each stack.
                                if (i >= 1) { break; }
                                //And the alert name for the zone label.
                                properties.name = templateJSON.name;
                            }
                        }
                        if (properties.shape === 'circle') {
                            zones.push(new this._CircularAlertZone(
                                zoneGeometries[i].id, properties.radius, properties.name, properties.opacity,
                                properties.colour, properties.messageTemplate, properties.notificationFilter, zIndex
                            ));
                        }
                        else {
                            //Generate the ordered sequence of coordinates that completes the Polygon shape.
                            zones.push(new this._PolygonalAlertZone(
                                zoneGeometries[i].id,
                                this._AlertTemplate.calculatePathsFromCoordinates(zoneGeometries[i].coordinates), properties.name,
                                properties.opacity, properties.colour, properties.messageTemplate, properties.notificationFilter, zIndex)
                            );
                        }
                        zIndex--;
                    }
                    //Build the stack marker, calculate the position using by building JSON that represents only the stack.
                    if (zones.length) {
                        stackMarker = new google.maps.Marker({
                            position: this._AlertTemplate.calculateCentroidFromJSON({
                                "geo": {
                                    "type": "GeometryCollection",
                                    "geometries": zoneGeometries
                                }
                            }),
                            map: this._map, draggable: true, zIndex: 50,
                            visible: this.nodeName !== 'VOYENT-ALERT-VIEW'
                        });

                        zoneStacks.push(new this._AlertZoneStack(stackMarker, zones));
                    }
                }
            }
            else { //No stacks, fallback zone only.
                zoneStacks = [];
            }
            var parentId = templateJSON.properties.parentAlertId || null;
            //We only want to create a template marker if we have more than
            //one stack, otherwise the stack marker will just be used.
            var templateMarker;
            if (zoneStacks.length > 1) {
                templateMarker = new google.maps.Marker({
                    position: (latLngCentroid ? latLngCentroid : this._AlertTemplate.calculateCentroidFromJSON(templateJSON)),
                    map: this._map, draggable: true, zIndex: 50,
                    icon: this.pathtoimages+'/img/alert_marker.png',
                    visible: this.nodeName !== 'VOYENT-ALERT-VIEW'
                });
            }
            this.set('_loadedAlert', {
                template: new this._AlertTemplate(
                    templateJSON._id, parentId, templateJSON.name, templateJSON.badge, templateMarker, zoneStacks, templateJSON.state, !!templateJSON.properties.center, templateJSON.schedule
                ),
                selectedStack: zoneStacks.length === 1 ? zoneStacks[0] : null
            });
            //If we were provided a centroid for the template then we need to move the centroid of the zones from the current
            //position to the new one. To do this we will first calculate their current position based on the template and then
            //move them to the new coordinate while maintaining the distance and bearing they were from the original position.
            if (latLngCentroid) {
                this._loadedAlert.template.calculateRelativeStackPositions(this._AlertTemplate.calculateCentroidFromJSON(templateJSON));
                this._loadedAlert.template.moveStacksRelativeToPosition(latLngCentroid);
                //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                this._loadedAlert.template.initializePolygonStackPathListeners();
            }
            //Draw the fallback zone but only if we have properties
            //other then enabled set (checking name exists is sufficient).
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                var fallbackZoneProperties = templateJSON.properties[this._FALLBACK_ZONE_ID];
                if (fallbackZoneProperties && fallbackZoneProperties.name) {
                    this._fallbackZone = new this._FallbackAlertZone(
                        fallbackZoneProperties.enabled,
                        fallbackZoneProperties.name,
                        fallbackZoneProperties.opacity,
                        fallbackZoneProperties.colour,
                        fallbackZoneProperties.messageTemplate,
                        fallbackZoneProperties.notificationFilter,
                        fallbackZoneProperties.zIndex
                    );
                }
            }
            this._adjustBoundsAndPan();
        },

        /**
         * Validates the currently loaded alert template.
         * @returns {boolean}
         * @private
         */
        _validateTemplate: function() {
            if (!this._loadedAlert || !this._loadedAlert.template ||
                (!this._loadedAlert.template.zoneStacks || !this._loadedAlert.template.zoneStacks.length) &&
                (!this._fallbackZone || !this._fallbackZone.enabled)) {
                this.fire('message-error','Please define at least one zone');
                return false;
            }
            return true;
        },

        /**
         * Initialize the listeners for drawing a new alert template on the map.
         * @private
         */
        _setupDrawingListeners: function() {
            var _this = this, zone;
            google.maps.event.addListener(this._drawingManager, 'overlaycomplete', function (oce) {
                //Check if they drew a self-intersecting polygon and if so remove it from the map and notify them.
                if (oce.type === 'polygon') {
                    var kinks = turf.kinks({
                        "type": "Feature",
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": _this._AlertTemplate.calculateCoordinatesFromPaths(oce.overlay.getPaths())
                        }
                    });
                    if (kinks.features.length) {
                        _this.fire('message-error','The zone cannot self-intersect');
                        oce.overlay.setMap(null);
                        return;
                    }
                }
                _this._openDialog('Please enter the zone name','',null,false,function() {
                    //Build our stack marker, the position will be added later.
                    var stackMarker = new google.maps.Marker({
                        map: _this._map, draggable: true, zIndex: 50
                    });
                    if (oce.type === 'circle') { //Circular template.
                        stackMarker.setPosition(oce.overlay.getCenter());
                        zone = new _this._CircularAlertZone(null, oce.overlay.getRadius(),_this._dialogInput);
                    }
                    else { //Polygonal template.
                        //If cancelled via esc, Google will still draw the polygon so we need to remove it from the map.
                        if (_this._drawingCanceled) {
                            oce.overlay.setMap(null);
                            _this._drawingCanceled = false;
                            return;
                        }
                        var paths = oce.overlay.getPaths();
                        stackMarker.setPosition(_this._AlertTemplate.calculateCentroidFromPaths(paths));
                        zone = new _this._PolygonalAlertZone(null,paths,_this._dialogInput);
                    }
                    var zoneStack = new _this._AlertZoneStack(stackMarker, [zone]);
                    //Add the stack and fire the zone added event.
                    _this._loadedAlert.template.addZoneStack(zoneStack);
                    _this.fire('voyent-alert-zone-added',{"id":zone.id,"zone":zone,"stack":zoneStack,"isFallbackZone":false});
                    //Toggle the accordion closed for the current stack and load the new one.
                    _this._toggleProperties(-1);
                    _this.set('_loadedAlert.selectedStack',zoneStack);
                    _this._toggleProperties(0);
                    //When we have only one stack we don't have a template marker, just the marker for the zone stack.
                    //So once we have two zone stacks we need to create the marker and if we have more than two (the
                    //marker exists already) then we'll update it's position.
                    if (_this._loadedAlert.template.zoneStacks.length === 2) {
                        _this._loadedAlert.template.setMarker(new google.maps.Marker({
                            position: _this._AlertTemplate.calculateCentroidFromJSON(_this._loadedAlert.template.json),
                            draggable: true, zIndex: 50,
                            map: _this._map,
                            icon: _this.pathtoimages+'/img/alert_marker.png'
                        }));
                    }
                    else if (_this._loadedAlert.template.zoneStacks.length > 2) {
                        _this._loadedAlert.template.updateJSONAndCentroid();
                    }
                    //To keep things simple we'll always use our custom classes for
                    //drawing the shapes so remove the google-drawn shape from the map.
                    oce.overlay.setMap(null);
                    //Re-punch out the fallback zone.
                    if (_this._fallbackZone) {
                        _this._fallbackZone.punchOutOverlay();
                    }
                    _this._disableDrawingMode();
                    _this._adjustBoundsAndPan();
                },function() {
                    oce.overlay.setMap(null);
                });
            });
            //When the escape key is pressed exit drawing mode.
            window.addEventListener('keydown', function (event) {
                if (event.which === 27) {
                    if (_this.nodeName === 'VOYENT-ALERT-EDITOR' && _this._showTemplateListPane) {
                        _this._revertCursor();
                    }
                    if (_this._drawingManager.getDrawingMode() !== null) {
                        //Flag so overlaycomplete listener won't be allowed
                        //to proceed after cancelling a polygon mid-draw.
                        _this._drawingCanceled = true;
                        _this._disableDrawingMode();
                    }
                }
            });
        },

        /**
         * Clears the map of overlays associated with the currently loaded alert template.
         */
        _removeAlertTemplateFromMap: function() {
            //Remove the entire template from the map.
            if (this._loadedAlert) {
                this._loadedAlert.template.removeFromMap();
                this._loadedAlert = null;
            }
            if (this._fallbackZone) {
                this._fallbackZone.removeFromMap();
            }
        },

        /**
         * Determines the northern most coordinate of the passed coordinates array,
         * used to calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns []
         * @private
         */
        _determineNorthernCoordinate: function(coordinates) {
            var northernCoordinate =[-100,null,-100];
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > northernCoordinate[1]) {
                    northernCoordinate = coordinates[i];
                }
            }
            return northernCoordinate;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         * @private
         */
        _calcMapSize: function() {
            var _this = this;
            //Do this async so the container has time to load and properly calculate it's size.
            setTimeout(function() {
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight !== null && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (height === null) {
                        height = _this.$$('#container').clientHeight;
                    }
                    //If we still don't have a valid height default to a minimum
                    if (height < 50) {
                        height = 500;
                    }
                }
                _this.customStyle['--height-var'] = height + 'px';

                //If the width is specified then set it
                if (_this.width && _this.width !== null && _this.width > 0) {
                    _this.customStyle['--width-var'] = _this.width + 'px';
                }
                else { //Otherwise the map will take up as much space as possible.
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' ||
                        _this.nodeName === 'VOYENT-ALERT-EDITOR') {
                        //-20px for map borders and padding
                        _this.customStyle['--width-var'] = (_this.querySelector('#container').offsetWidth -
                            _this.querySelector('#sidePanel').offsetWidth - 20) + 'px';
                    }
                    else {
                        _this.customStyle['--width-var'] = _this.querySelector('#container').offsetWidth + 'px';
                    }

                }
                //Apply the styles
                _this.updateStyles();
            },0);
        },

        /**
         * Adds the button for creating new circular zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addCircleButton: function(listener,cb) {
            this._addDrawButton(this._CIRCLE_BUTTON_ID,listener,cb);
        },

        /**
         * Adds the button for creating new polygonal zone stacks.
         * @param listener
         * @param cb
         * @private
         */
        _addPolygonButton: function(listener,cb) {
            this._addDrawButton(this._POLYGON_BUTTON_ID,listener,cb);
        },

        /**
         * Adds adding the button for toggling the fallback zone.
         * @param listener
         * @param cb
         * @private
         */
        _addFallbackZoneButton: function(listener,cb) {
            this._addDrawButton(this._FALLBACK_ZONE_BUTTON_ID,listener,cb);
        },

        /**
         * Adds the circle, polygon and fallback zone buttons.
         * @private
         */
        _addAlertTemplateButtons: function() {
            var _this = this;
            //The controls API doesn't like it when we try to inject controls too quickly so we'll use a callback chain to
            //add each button after the other one has been added successfully. Without this Google adds the buttons but
            //they end up all stacked up on top of each other, likely because the styling doesn't have time to update.
            this._addCircleButton(this._circleButtonListener.bind(this),function() {
                _this._addPolygonButton(_this._polygonButtonListener.bind(_this),function() {
                    _this._addFallbackZoneButton(_this._fallbackZoneButtonListener.bind(_this));
                });
            });
        },

        /**
         * Adds drawing buttons.
         * @param id - The id of the button to create.
         * @param listener - The click listener.
         * @param cb - An optional callback that will be executed after the button has been added.
         * @private
         */
        _addDrawButton: function(id,listener,cb) {
            var _this = this;
            this._mapIsReady().then(function() {
                //Use our saved button reference to check if the button already exists.
                if (!_this['_'+id]) {
                    _this['_'+id] = _this.$$('#'+id).cloneNode(true);
                    //Add the onclick, save and show the button.
                    _this['_'+id].onclick = listener;
                    _this._map.controls[google.maps.ControlPosition.TOP_RIGHT].push(_this['_'+id]);
                    _this['_'+id].hidden = false;
                    //Call our callback function, if provided.
                    if (cb && typeof cb === 'function') { cb(); }
                }
            });
        },

        /**
         * Handles removing the button for creating new circular zone stacks.
         * @private
         */
        _removeCircleButton: function() {
            this._removeDrawButton(this._CIRCLE_BUTTON_ID);
        },

        /**
         * Handles removing the button for creating new polygonal zone stacks.
         * @private
         */
        _removePolygonButton: function() {
            this._removeDrawButton(this._POLYGON_BUTTON_ID);
        },

        /**
         * Handles removing the button for toggling the fallback zone.
         * @private
         */
        _removeFallbackZoneButton: function() {
            this._removeDrawButton(this._FALLBACK_ZONE_BUTTON_ID);
        },

        /**
         * Handles removing the circle, polygon and fallback zone buttons.
         * @private
         */
        _removeAlertTemplateButtons: function() {
            this._removeCircleButton();
            this._removePolygonButton();
            this._removeFallbackZoneButton();
        },

        /**
         * Removes drawing buttons
         * @param id - The id of the button to remove.
         * @private
         */
        _removeDrawButton: function(id) {
            if (!this._map || !this._map.controls) { return; }
            var index = this._map.controls[google.maps.ControlPosition.TOP_RIGHT].indexOf(this['_'+id]);
            if (index > -1) {
                this._map.controls[google.maps.ControlPosition.TOP_RIGHT].removeAt(index);
                this['_'+id] = null;
            }
        },

        /**
         * The listener to fire when the circle button is clicked.
         * @private
         */
        _circleButtonListener: function() {
            this._deselectDrawingButtons();
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID);
            if (circleButton) {
                this.toggleClass('selected', true, circleButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the polygon button is clicked.
         * @private
         */
        _polygonButtonListener: function() {
            this._deselectDrawingButtons();
            this._drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID);
            if (polygonButton) {
                this.toggleClass('selected', true, polygonButton.querySelector('.customMapBttn'));
            }
        },

        /**
         * The listener to fire when the fallback zone button is clicked.
         * @private
         */
        _fallbackZoneButtonListener: function() {
            this._disableDrawingMode();
            if (this._fallbackZone && this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(false);
            }
            else if (this._fallbackZone && !this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(true);
            }
            else {
                this._fallbackZone = new this._FallbackAlertZone(true);
                this._deselectStacksOnClick(this._fallbackZone.shapeOverlay);
            }
        },

        /**
         * Removes Google's "Stop drawing" hand button from the top-right corner.
         * @private
         */
        _removeStopDrawingButton: function() {
            if (!this._stopDrawingButtonRemoved) {
                var _this = this;
                function waitForStopDrawingButton() {
                    var stopDrawingButton = document.querySelector('div[title="Stop drawing"]');
                    if (!stopDrawingButton) {
                        setTimeout(waitForStopDrawingButton, 10);
                        return;
                    }
                    stopDrawingButton.parentNode.removeChild(stopDrawingButton);
                    _this._stopDrawingButtonRemoved = true;
                }
                waitForStopDrawingButton();
            }
        },

        /**
         * Updates the map bounds so all the map overlays are in view and then pans the map.
         * @private
         */
        _adjustBoundsAndPan: function() {
            // Don't adjust the map if the user is allowed to pan and zoom it as they may be actively doing so.
            if (this.nodeName === 'VOYENT-ALERT-VIEW' && this._mapIsEditable) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            if (this._loadedAlert || (this.nodeName === 'VOYENT-ALERT-VIEW' && (this._userLocationMarker || this._locationMarkers))) {
                var i;
                if (this._loadedAlert) {
                    var zoneStacks = this._loadedAlert.template.zoneStacks;
                    //If we have no zoneStacks then we only have a fallback zone so just pan to the region.
                    if (!zoneStacks.length) {
                        //Make sure we force pan the region as this flag will be true in cases such as when loading an alert
                        //or template. This fixes an issue where when we load a fallback zone only template after a stacked
                        //template the map wouldn't pan.
                        this._skipRegionPanning = false;
                        this._zoomOnRegion();
                        return;
                    }
                    for (i=0; i<zoneStacks.length; i++) {
                        var largestZone = zoneStacks[i].getLargestZone();
                        if (largestZone) {
                            if (largestZone.getShape() === 'circle') {
                                bounds.extend(largestZone.shapeOverlay.getBounds().getNorthEast());
                                bounds.extend(largestZone.shapeOverlay.getBounds().getSouthWest());
                            }
                            else {
                                for (var j=0; j<largestZone.shapeOverlay.getPath().length; j++) {
                                    bounds.extend(largestZone.shapeOverlay.getPath().getAt(j));
                                }
                            }
                        }
                    }
                }
                if (this._userLocationMarker) {
                    bounds.extend(this._userLocationMarker.getPosition());
                }
                if (this._locationMarkers) {
                    for (i=0; i<this._locationMarkers.length; i++) {
                        bounds.extend(this._locationMarkers[i].getPosition());
                    }
                }
                this._map.fitBounds(bounds);
                this._map.panToBounds(bounds);
            }
            else {
                this._zoomOnRegion();
            }
        },

        /**
         * Set up a click listener on the passed map entity that when clicked will de-select the currently selected stack.
         * @param mapEntity
         * @private
         */
        _deselectStacksOnClick: function(mapEntity) {
            var _this = this;
            google.maps.event.addListener(mapEntity, 'click', function() {
                if (_this._loadedAlert &&  _this._loadedAlert.selectedStack) {
                    _this._loadedAlert.selectedStack.deactivateZoneOverlays();
                    _this.set('_loadedAlert.selectedStack',null);
                    _this.fire('voyent-alert-zone-selected',{
                        "id": null,
                        "zone": null
                    });
                }
            });
        },

        /**
         * Listens to whether are are loading an alert entity and
         * toggles our flag for skipping region panning accordingly.
         * @param isAlertLoading
         * @private
         */
        _isAlertLoading: function(isAlertLoading) {
            this._skipRegionPanning = isAlertLoading;
        },

        /**
         * Disables drawing mode and selected button states.
         * @private
         */
        _disableDrawingMode: function() {
            if (this._drawingManager) {
                this._drawingManager.setDrawingMode(null);
            }
            this._deselectDrawingButtons();
        },

        /**
         * Ensure that all the drawing buttons are styled as de-selected.
         * @private
         */
        _deselectDrawingButtons: function() {
            var bttnClass = '.customMapBttn';
            var polygonButton = this.querySelector('#'+this._POLYGON_BUTTON_ID);
            if (polygonButton) {
                this.toggleClass('selected', false, polygonButton.querySelector(bttnClass));
            }
            var circleButton = this.querySelector('#'+this._CIRCLE_BUTTON_ID);
            if (circleButton) {
                this.toggleClass('selected', false, circleButton.querySelector(bttnClass));
            }
            var fallbackZoneButton = this.querySelector('#'+this._FALLBACK_ZONE_ID);
            if (fallbackZoneButton) {
                this.toggleClass('selected', false, fallbackZoneButton.querySelector(bttnClass));
            }
        },

        /**
         * A promise that when resolved indicates that google maps is ready. Can be used in public facing functions
         * to avoid race conditions where the function tries to execute map related calls before the map is ready.
         * @returns {*}
         * @private
         */
        _mapIsReady: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._map) {
                    resolve();
                }
                else {
                    waitForMap();
                    function waitForMap() {
                        if (!_this._map) {
                            setTimeout(function(){waitForMap();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * Manages component state between realm changes.
         * @param newRealm
         * @private
         */
        _realmChanged: function(newRealm) {
            //We don't render the region on the map for the alert view.
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                //Only proceed if we have a valid realm and the map is initialized.
                if (!newRealm || !this._map) { return; }
                //First clear the current region from the map.
                if (this._areaRegion && this._areaRegion.polygon) {
                    this._areaRegion.polygon.setMap(null);
                    this._areaRegion = null;
                }
                //Check if we have the realm region cached otherwise fetch it.
                var areaRegion = this._regionMapping && this._regionMapping[newRealm] ?
                    this._regionMapping[newRealm] : null;
                if (areaRegion && areaRegion.polygon) {
                    areaRegion.polygon.setMap(this._map);
                    this._areaRegion = areaRegion;
                }
                else {
                    this._fetchRealmRegion();
                }
            }
            //Clear the map entirely.
            this.clearMap();
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                //Refresh the map with the latest data.
                this.fetchAlertTemplates();
            }
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Manages the stack marker icons.
         * @param selectedStack
         * @private
         */
        _selectedStackChanged: function(selectedStack) {
            if (this._loadedAlert) {
                if (this._loadedAlert.template.zoneStacks.length === 1) {
                    var image = {
                        url: this.getBadgeUrl(this._loadedAlert.template.badge),
                        scaledSize: new google.maps.Size(32,32)
                    };
                    this._loadedAlert.template.zoneStacks[0].marker.setIcon(image);
                }
                else {
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        this._loadedAlert.template.zoneStacks[i].marker.setIcon(null);
                    }
                    if (selectedStack) {
                        selectedStack.marker.setIcon(this.pathtoimages+'/img/green-marker.png');
                    }
                }
            }
        },

        /**
         * Manages selected styling on fallback zone button.
         * @param enabled
         * @private
         */
        _fallbackZoneEnabledChanged: function(enabled) {
            var fallbackZoneButton = this.querySelector('#'+this._FALLBACK_ZONE_BUTTON_ID);
            if (fallbackZoneButton) {
                this.toggleClass('selected', !!enabled, fallbackZoneButton.querySelector('.customMapBttn'));
                var childDiv = fallbackZoneButton.children[0];
                if (childDiv) {
                    childDiv.setAttribute('title',enabled ? 'Disable Entire Region Zone' : 'Enable Entire Region Zone')
                }
            }
        }
    };
</script>