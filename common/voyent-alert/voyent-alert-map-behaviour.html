<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by map-based `voyent-alert-*` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        /**
         * Fires when the alert template is successfully saved. Does not include any data.
         * @event voyent-alert-template-saved
         */

        /**
         * Fires when the alert template name changes. Includes a `name` property that contains the new value.
         * @event voyent-alert-template-name-changed
         */

        /**
         * Fires when an alert zone name changes. Includes a `name` property that contains
         * the new value and an `id` property that indicates which zone was modified.
         * @event voyent-alert-zone-name-changed
         */

        /**
         * Fires when a new alert zone is added to the template. Includes an `id` property
         * which identifies the zone and a `zone` property that contains the associated data.
         * @event voyent-alert-zone-added
         */

        /**
         * Fired when an alert zone is removed from the template. Includes an `id` property which identifies the zone.
         * @event voyent-alert-zone-removed
         */

        /**
         * Fires when the selected alert zone changes. Includes an `index` property in relation to the list, `id` property
         * which identifies the zone and a `zone` property containing the associated data. If no zone is selected then the
         * index value will be -1 and the other properties will be null.
         * @event voyent-alert-zone-selected
         */

        /**
         * Fires when the fallback zone name changes. Includes a `name` property that contains
         * the new value and an `id` property that contains the id of the fallback zone.
         * @event voyent-fallback-zone-name-changed
         */

        /**
         * Fires when the fallback zone is added to the template. Includes an `id` property
         * which identifies the zone and a `zone` property that contains the associated data.
         * @event voyent-fallback-zone-enabled
         */

        /**
         * Fired when the fallback zone is removed from the template. Includes an `id` property which identifies the zone.
         * @event voyent-fallback-zone-disabled
         */

        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the alert template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String, observer: '_realmChanged' },
            /**
             * A boolean indicating whether the component should load the Google Maps API. When `false`
             * it is expected that the API is included manually in the application.
             * @default false
             */
            loadGoogleMaps: { type: Boolean, value: false },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: Number,
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: Number,
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             * @default -1
             */
            autoheight: { type: Number, value: -1, notify: true },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             * @default '.'
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' }
        },

        observers: ['_selectedStackChanged(_loadedAlert.selectedStack)'],

        ready: function() {
            var _this = this;
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            window.initializeLocationsMap = function () {
                var mapOptions = {
                    zoom: 10,
                    center: new google.maps.LatLng(51.08427,-114.13062),
                    streetViewControl: false,
                    fullscreenControl: false,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.LEFT_TOP
                    },
                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.LARGE,
                        position: google.maps.ControlPosition.LEFT_CENTER
                    }
                };
                //Alert view map is readonly.
                if (_this.nodeName === 'VOYENT-ALERT-VIEW') {
                    mapOptions.mapTypeControl =  mapOptions.scrollwheel =
                    mapOptions.zoomControl =  mapOptions.draggable = false;
                    mapOptions.disableDoubleClickZoom = true;
                }
                _this._map = new google.maps.Map(_this.$.map,mapOptions);
                //Calculate the map size.
                _this._calcMapSize();
                if (_this.nodeName !== 'VOYENT-ALERT-VIEW') {
                    //Setup ui and listeners for adding new marker based entities.
                    _this._drawingManager = new google.maps.drawing.DrawingManager({
                        map:_this._map,
                        drawingControlOptions: {
                            position: google.maps.ControlPosition.TOP_RIGHT,
                            drawingModes: []
                        },
                        //This settings only apply to entities created with
                        //the drawing API, not when creating manually.
                        markerOptions: { draggable:true, zIndex:50 }
                    });
                    _this._setupDrawingListeners();
                }
                _this._regionMapping = {}; //Map of region data so we can toggle between them.
                _this._isLoggedIn = false; //Toggle for side panel.
                //Custom initialization for each component after login.
                if (voyent.auth.isLoggedIn()) {
                    _this._onAfterLogin();
                }
                else {
                    //We only want to do this on initial login and not access_token refreshes so we'll
                    //save a reference to the listener so we can remove it the first time it fires.
                    var onAfterLoginListener = function() {
                        _this._onAfterLogin();
                        window.removeEventListener('voyent-login-succeeded',onAfterLoginListener);
                    }.bind(_this);
                    window.addEventListener('voyent-login-succeeded',onAfterLoginListener);
                }
                //Make sure the map is always sized correctly when the window size changes.
                window.addEventListener('resize', function() { _this.resizeMap(); });
                //De-select any selected zone stack on map click.
                _this._deselectStacksOnClick(_this._map);
            };
            if (!('google' in window) || !('maps' in window.google)) {
                if (this.loadGoogleMaps) {
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyAZVsIO4CmSqqE7qbSO8pB0JPVUkO5bOd8&v=3&' +
                        'libraries=places,geometry,visualization,drawing&callback=initializeLocationsMap';
                    this.$.container.appendChild(script);
                }
                else {
                    var msg = 'Error initializing ' + this.nodeName.toLowerCase() + ': The attribute `load-google-maps` ' +
                              'is false but the Google Maps API cannot be found. Please load the component before ' +
                              'loading the API or set the attribute to true.';
                    this.fire('message-error',msg);
                    console.error(msg);
                }
            }
            else {
                initializeLocationsMap();
            }
        },

        /**
         * Recalculates the map size, fires the Google Map resize event and pans the map.
         */
        resizeMap: function() {
            var _this = this;
            this._mapIsReady().then(function() {
                _this._calcMapSize();
                //Async so the new dimensions render first.
                setTimeout(function() {
                    google.maps.event.trigger(_this._map, 'resize');
                    if (_this._areaRegion && _this._areaRegion.bounds &&
                        !_this._skipRegionPanning) {
                        _this._map.fitBounds(_this._areaRegion.bounds);
                        _this._map.panToBounds(_this._areaRegion.bounds);
                    }
                },0);
            });
        },

        /**
         * Saves or updates the current alert template.
         */
        saveAlertTemplate: function () {
            //Use this flag to avoid excessive calls if the user mashes the "Activate Now" and "Back" buttons.
            if (this._savingAlertTemplate) { return; }
            this._savingAlertTemplate = true;
            var _this = this, msg;
            //Pull the latest JSON from each of the stacks and specify that we want to punch out the circular templates.
            this._loadedAlert.template.updateJSON(true);
            var requestOpts = {realm: this.realm, account: this.account, alertTemplate: this._loadedAlert.template.json};
            var func = 'createAlertTemplate';
            //If we have an id then the template was already saved.
            if (this._loadedAlert.template.id) {
                func = 'updateAlertTemplate';
                requestOpts.id = this._loadedAlert.template.id
            }
            voyent.locate[func](requestOpts).then(function (uri) {
                _this._savingAlertTemplate = false;
                if (func === 'createAlertTemplate') {
                    //Grab the generated ID from the return URI and setup change listeners
                    _this._loadedAlert.template.setId(uri.split('/').pop());
                    msg = 'Alert template successfully created';
                }
                else {
                    msg = 'Alert template successfully updated';
                }
                if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                    _this.fire('message-info', msg);
                }
                else if (_this._loadedAlert.template.parentId) {
                    _this._updateAlertLocation();
                }
                _this.fire('voyent-alert-template-saved',{});
            }).catch(function(e) {
                msg = 'Issue saving alert ' + (this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' ? 'template: ' : ': ');
                _this.fire('message-error', msg + (e.responseText || e.message || e));
                _this._savingAlertTemplate = false;
            });
        },

        /**
         * Clears the map of the loaded alert and conditionally also the drawn Alerts.
         * @param skipBttnDraw
         */
        clearMap: function(skipBttnDraw) {
            //Always re-zoom the bounds on the area's region if available.
            if (this._areaRegion && this._areaRegion.bounds && !this._skipRegionPanning) {
                this._map.fitBounds(this._areaRegion.bounds);
                this._map.panToBounds(this._areaRegion.bounds);
            }
            //Clear loaded alert template.
            if (this._loadedAlert) {
                this._removeAlertTemplateFromMap();
            }
            //Clear fallback zone.
            if (this._fallbackZone) {
                this._fallbackZone.removeFromMap();
            }
            //Clear the user marker.
            if (this.nodeName === 'VOYENT-ALERT-VIEW' && this._userLocationMarker) {
                this._userLocationMarker.setMap(null);
                this._userLocationMarker = null;
            }
            //Clear the movement inputs.
            this._alertDirection = this._alertSpeed = null;
            //Re-draw the alert button.
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                if (!skipBttnDraw) {
                    this._addAlertButton(this._alertButtonListener.bind(this));
                }
                this._enableDefaultPane();
            }
        },

        /**
         * Sets the message template based onto the zone associated with the zoneIndex.
         * @param messageTemplate
         * @param zoneIndex
         * @param stackIndex
         */
        setMessageTemplate: function(messageTemplate, zoneIndex, stackIndex) {
            if (typeof zoneIndex === 'number' && zoneIndex >= 0) {
                if (typeof stackIndex === 'number' && stackIndex >= 0) {
                    this._loadedAlert.template.zoneStacks[stackIndex].zones[zoneIndex].messageTemplate = messageTemplate;
                }
                else {
                    this._loadedAlert.selectedStack.zones[zoneIndex].messageTemplate = messageTemplate;
                }
            }
        },

        /**
         * Sets the message template for the fallback zone.
         * @param messageTemplate
         */
        setFallbackMessageTemplate: function(messageTemplate) {
            if (this._fallbackZone) {
                this._fallbackZone.messageTemplate = messageTemplate;
            }
        },

        //******************PRIVATE API******************

        /**
         * Fetches the region boundary for the realm.
         * @returns {Promise}
         * @private
         */
        _fetchRealmRegion: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findRegions({realm:_this.realm, account:_this.account,
                                           query:{"_id":_this.realm+"_region"}
                }).then(function (regions) {
                    if (!regions) { return resolve(); }
                    //Filter out the alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions.filter(function(region) {
                        return !region.location.properties || !region.location.properties.alertId;
                    })[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches an alert template that matches the passed id.
         * @param id
         * @private
         */
        _fetchAlertTemplate: function(id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.findAlertTemplates({
                    realm: this.realm,
                    account: this.account,
                    query: {"_id":id}
                }).then(function (results) {
                    if (!results || !results.length) {
                        _this.fire('message-error', 'Alert template not found');
                        return reject('Alert template not found');
                    }
                    resolve(results[0]);
                }).catch(function (error) {
                    _this.fire('message-error', 'Error fetching alert template: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Fetches the most recent User or alert location depending on whether we are passed an alertId.
         * @param alertId
         * @private
         */
        _fetchLocationRecord: function(alertId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var query = {};
                if (alertId && typeof alertId === 'string') {
                    query = {"location.properties.alertId":alertId};
                }
                else {
                    query = {
                        "location.properties.alertId": {"$exists":false},
                        "location.properties.vras.name":{"$exists":false},
                        "location.properties.vras.type":{"$exists":false},
                        "location.properties.vras.id":{"$exists":false}
                    };
                    query.username = voyent.auth.getLastKnownUsername();
                }
                //Only get the last location.
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,query:query,
                    options:{"sort":{"lastUpdated":-1},"limit":1}}).then(function(location) {
                    //Only error out for alerts.
                    if (alertId) {
                        if ((!location || !location[0])) {
                            return reject('Alert location cannot be found');
                        }
                    }
                    else {
                        if ((!location || !location[0])) {
                            _this.fire('message-info','User location cannot be found');
                            return resolve();
                        }
                        _this._drawUser(location[0]);
                    }
                    resolve(location[0]);
                }).catch(function(error) {
                    reject(error);
                });
            });
        },

        /**
         * Fetches existing fixed location records, groups them by id and keeps only the latest.
         * @returns {Promise}
         * @private
         */
        _fetchMyLocations: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var query = {"location.properties.alertId":{"$exists":false},
                             "location.properties.vras.name":{"$exists":true},
                             "location.properties.vras.type":{"$exists":true},
                             "location.properties.vras.id":{"$exists":true},
                             "username":voyent.auth.getLastKnownUsername()};
                var fields = {"_id":0,"username":0};
                voyent.locate.findLocations({realm:_this.realm,account:_this.account,
                                             query:query,fields:fields}).then(function(locations) {
                    //Clear the map and draw the locations.
                    _this._clearMyLocations();
                    _this._drawMyLocations(locations);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching location records: ' + (error.responseText || error.message || error));
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed locations on the map.
         * @param locations
         * @private
         */
        _drawMyLocations: function(locations) {
            for (var i=0; i<locations.length; i++) {
                this._myLocations.push(new this._MyLocation(
                    locations[i].location.properties.vras.id,
                    locations[i].location.properties.vras.name,
                    locations[i].location.properties.vras.type === 'residential',
                    new google.maps.Marker({
                        position: new google.maps.LatLng(
                            locations[i].location.geometry.coordinates[1],
                            locations[i].location.geometry.coordinates[0]
                        ),
                        map: this._map,
                        draggable: this.nodeName === 'VOYENT-MY-LOCATIONS'
                    }),
                    null
                ));
            }
        },

        /**
         * Clears the map of all drawn locations.
         * @private
         */
        _clearMyLocations: function() {
            for (var i=0; i<this._myLocations.length; i++) {
                this._myLocations[i].removeFromMap();
            }
            this._myLocations = [];
        },

        /**
         * Draws the passed region on the map as an invisible polygon. We'll use the polygon
         * for setting the map bounds or favouring autocomplete results to it's area.
         * @param region - The region to be drawn, in GeoJSON format.
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            var bounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path;
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j=0; j<coords.length; j++) {
                path = [];
                for (var k=0; k<coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    bounds.extend(googlePoint);
                }
                paths.push(path);
            }
            var polygon;
            //If we have an existing polygon then just modify it.
            if (this._areaRegion && this._areaRegion.polygon) {
                polygon = this._areaRegion.polygon;
                polygon.setPaths(paths);
            }
            else {
                //Create the invisible polygon object.
                polygon = new google.maps.Polygon({
                    paths: paths, map: this._map, visible: false
                });
            }
            if (!this._skipRegionPanning) {
                //Zoom on the newly drawn Region.
                this._map.fitBounds(bounds);
                this._map.panToBounds(bounds);
            }
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon,"bounds":bounds};
            this._regionMapping[this.realm] = this._areaRegion;
        },

        /**
         * Draws the passed alert or alert template on the map.
         * @param templateJSON - The JSON to build the alert template from.
         * @param latLngCentroid - An optional LatLng object specifying the centroid of the template. When this is not
         *                         provided we will calculate the centroid based on the template's zone coordinates.
         * @private
         */
        _drawAndLoadAlertTemplate: function(templateJSON,latLngCentroid) {
            var properties, zoneGeometries, zones, zoneStacks = [], zIndex, stackMarker;
            var zoneStackGeometries = templateJSON.geo.geometries.reduce(function(stackGroups, item) {
                stackGroups[item.stackId] = stackGroups[item.stackId] || [];
                stackGroups[item.stackId].push(item);
                return stackGroups;
            },{});
            for (var stackId in zoneStackGeometries) {
                if (!zoneStackGeometries.hasOwnProperty(stackId)) { continue; }
                zoneGeometries = zoneStackGeometries[stackId];
                zones = [];
                zIndex = 49;
                for (var i=0; i<zoneGeometries.length; i++) {
                    properties = templateJSON.properties[zoneGeometries[i].id];
                    if (properties.shape === 'circle') {
                        zones.push(new this._CircularAlertZone(
                            properties.radius, properties.name, properties.opacity,
                            properties.colour, properties.messageTemplate, zIndex
                        ));
                    }
                    else {
                        //Generate the ordered sequence of coordinates that completes the Polygon shape.
                        zones.push(new this._PolygonalAlertZone(
                            this._AlertTemplate.calculatePathsFromCoordinates(zoneGeometries[i].coordinates),
                            properties.name, properties.opacity, properties.colour, properties.messageTemplate, zIndex)
                        );
                    }
                    zIndex--;
                }
                //Build the stack marker, calculate the position using by building JSON that represents only the stack.
                stackMarker = new google.maps.Marker({
                    position: this._AlertTemplate.calculateCentroidFromJSON({
                        "geo": {
                            "type": "GeometryCollection",
                            "geometries": zoneGeometries
                        }
                    }),
                    map: this._map, draggable: true, zIndex: 50,
                    visible: this.nodeName !== 'VOYENT-ALERT-VIEW'
                });

                zoneStacks.push(new this._AlertZoneStack(stackMarker, zones));
            }
            var parentId = templateJSON.properties.parentAlertId || null;
            //We only want to create a template marker if we have more than
            //one stack, otherwise the stack marker will just be used.
            var templateMarker;
            if (zoneStacks.length > 1) {
                templateMarker = new google.maps.Marker({
                    position: (latLngCentroid ? latLngCentroid : this._AlertTemplate.calculateCentroidFromJSON(templateJSON)),
                    map: this._map, draggable: true, zIndex: 50,
                    icon: this.pathtoimages+'/img/alert_marker.png',
                    visible: this.nodeName !== 'VOYENT-ALERT-VIEW'
                });
            }
            this.set('_loadedAlert', {
                template: new this._AlertTemplate(
                    templateJSON._id, parentId, templateJSON.name, templateMarker, zoneStacks
                ),
                selectedStack: null
            });
            //If we were provided a centroid for the template then we need to move the centroid of the zones from the current
            //position to the new one. To do this we will first calculate their current position based on the template and then
            //move them to the new coordinate while maintaining the distance and bearing they were from the original position.
            if (latLngCentroid) {
                this._loadedAlert.template.calculateRelativeStackPositions(this._AlertTemplate.calculateCentroidFromJSON(templateJSON));
                this._loadedAlert.template.moveStacksRelativeToPosition(latLngCentroid);
                //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                this._loadedAlert.template.initializePolygonStackPathListeners();
            }
            //Draw the fallback zone but only if we have properties
            //other then enabled set (checking name exists is sufficient).
            var fallbackZoneProperties = templateJSON.properties[this._FALLBACK_ZONE_ID];
            if (fallbackZoneProperties && fallbackZoneProperties.name) {
                this._fallbackZone = new this._FallbackAlertZone(
                    fallbackZoneProperties.enabled,
                    fallbackZoneProperties.name,
                    fallbackZoneProperties.opacity,
                    fallbackZoneProperties.colour,
                    fallbackZoneProperties.messageTemplate,
                    fallbackZoneProperties.zIndex
                );
            }
            //Disable further alert instance creations - only allowed one at a time.
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                this._removeAlertButton();
            }
        },

        /**
         * Clears the map of overlays associated with the currently loaded alert template.
         */
        _removeAlertTemplateFromMap: function() {
            //Remove the entire template from the map.
            this._loadedAlert.template.removeFromMap();
            this.fire('voyent-alert-zone-selected', {
                'index': -1,
                'id': null,
                'zone': null
            });
            this._loadedAlert = null;
        },

        /**
         * Determines the northern most coordinate of the passed coordinates array,
         * used to calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns []
         * @private
         */
        _determineNorthernCoordinate: function(coordinates) {
            var northernCoordinate =[-100,null,-100];
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > northernCoordinate[1]) {
                    northernCoordinate = coordinates[i];
                }
            }
            return northernCoordinate;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         * @private
         */
        _calcMapSize: function() {
            var _this = this;
            //Do this async so the container has time to load and properly calculate it's size.
            setTimeout(function() {
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight !== null && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (height === null) {
                        height = _this.$$('#container').clientHeight;
                    }
                    //If we still don't have a valid height default to a minimum
                    if (height < 50) {
                        height = 500;
                    }
                }
                _this.customStyle['--height-var'] = height + 'px';

                //If the width is specified then set it
                if (_this.width && _this.width !== null && _this.width > 0) {
                    _this.customStyle['--width-var'] = _this.width + 'px';
                }
                else { //Otherwise the map will take up as much space as possible.
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' ||
                        _this.nodeName === 'VOYENT-ALERT-EDITOR') {
                        //-20px for map borders and padding
                        _this.customStyle['--width-var'] = (_this.querySelector('#container').offsetWidth -
                            _this.querySelector('#sidePanel').offsetWidth - 20) + 'px';
                    }
                    else {
                        _this.customStyle['--width-var'] = _this.querySelector('#container').offsetWidth + 'px';
                    }

                }
                //Apply the styles
                _this.updateStyles();
            },0);
        },

        /**
         * Handles adding the button for creating new locations.
         * @param listener
         * @private
         */
        _addMarkerButton: function(listener) {
            this._addDrawButton('markerBttn',listener);
        },

        /**
         * Handles adding the button for creating new circle alert templates.
         * @param listener
         * @private
         */
        _addCircleButton: function(listener) {
            this._addDrawButton('circleBttn',listener);
        },

        /**
         * Handles adding the button for creating new polygonal alert templates.
         * @param listener
         * @private
         */
        _addPolygonButton: function(listener) {
            this._addDrawButton('polygonBttn',listener);
        },

        /**
         * Handles adding the button for displaying the fallback zone.
         * @param listener
         * @private
         */
        _addFallbackZoneButton: function(listener) {
            this._addDrawButton('fallbackZoneBttn',listener);
        },

        /**
         * Handles adding the button for creating new locations.
         * @param listener
         * @private
         */
        _addAlertButton: function(listener) {
            this._addDrawButton('alertBttn',listener);
        },

        /**
         * Handles adding drawing buttons.
         * @param id - The id of the button to create.
         * @param listener - The click listener.
         * @private
         */
        _addDrawButton: function(id,listener) {
            var _this = this;
            this._mapIsReady().then(function() {
                //We have an additional flag to prevent race conditions when
                //onAfterLogin and clearMap are called at nearly identical times.
                if (!_this['_drawing'+id] &&
                    !_this.querySelector('#'+id+':not([hidden])')) {
                    _this['_drawing'+id] = true;
                    var bttn = _this.$[id].cloneNode(true);
                    bttn.onclick = listener;
                    _this._map.controls[google.maps.ControlPosition.TOP_RIGHT].push(bttn);
                    //Delay so that the button isn't shown on
                    //the page before being moved into the map.
                    setTimeout(function () {
                        bttn.hidden = false;
                        _this['_drawing'+id] = false;
                    },100);
                }
            });
        },

        /**
         * Handles removing the button for creating new alerts.
         * @private
         */
        _removeAlertButton: function() {
            var alertBttn = this.querySelector('#alertBttn');
            if (alertBttn) { alertBttn.parentNode.removeChild(alertBttn); }
        },

        /**
         * Handles removing the button for toggling the fallback zone.
         * @private
         */
        _removeFallbackZoneButton: function() {
            var fallbackZoneBttn = this.querySelector('#fallbackZoneBttn');
            if (fallbackZoneBttn) { fallbackZoneBttn.parentNode.removeChild(fallbackZoneBttn); }
        },

        /**
         * The listener to fire when the fallback zone button is clicked.
         * @private
         */
        _fallbackZoneButtonListener: function() {
            if (this._fallbackZone && this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(false);
            }
            else if (this._fallbackZone && !this._fallbackZone.enabled) {
                this._fallbackZone.setEnabled(true);
            }
            else {
                this._fallbackZone = new this._FallbackAlertZone(true);
                this._deselectStacksOnClick(this._fallbackZone.shapeOverlay);
            }
        },

        /**
         * Opens the dialog and sets various properties to be used later.
         * @param message
         * @param input
         * @param confirmFunc
         * @param cancelFunc
         * @private
         */
        _openDialog: function(message,input,confirmFunc,cancelFunc) {
            this._dialogMessage = message;
            this._dialogInput = input;
            this._showDialogInput = (typeof input !== 'undefined' && input !== null);
            this._dialogConfirmFunc = confirmFunc;
            this._dialogCancelFunc = cancelFunc;
            var dialog = this.querySelector('#modalDialog');
            if (dialog) {
                dialog.open();
                //If there's no input rendered in the dialog then focus on the dialog so
                //we can capture the user's key presses. The input will focus automatically.
                if (!this._showDialogInput) {
                    setTimeout(function() {
                        dialog.focus();
                    },200);
                }
            }
        },

        /**
         * Handles dialog input validation and calling the confirmation function if available.
         * @private
         */
        _confirmDialog: function() {
            //Validate the input.
            if (this._showDialogInput && (!this._dialogInput ||
                !this._dialogInput.trim())) {
                return;
            }
            //We allow for passing the confirm function directly or as a string.
            if (this._dialogConfirmFunc) {
                if (typeof this._dialogConfirmFunc === 'string') { this[this._dialogConfirmFunc](); }
                else { this._dialogConfirmFunc(); }
            }
            //Close the dialog after.
            this._closeDialog(true);
        },

        /**
         * Handles closing the dialog and calling the cancel function if available.
         * @param confirmed
         * @private
         */
        _closeDialog: function(confirmed) {
            //Only call the cancel function if this is triggered by a cancel.
            //We allow passing the confirm function directly or as a string.
            if (!confirmed && this._dialogCancelFunc) {
                if (typeof this._dialogCancelFunc === 'string') { this[this._dialogCancelFunc](); }
                else { this._dialogCancelFunc(); }
            }
            this.querySelector('#modalDialog').close();
        },

        /**
         * Handles enter and escape key presses when the dialog is focused.
         * @param e
         * @private
         */
        _dialogKeyUp: function(e) {
            if (e.keyCode === 13) { //Enter
                this._confirmDialog();
            }
            else if (e.keyCode === 27) { //Escape
                this._closeDialog();
            }
        },

        /**
         * Fixes an issue with paper-dialog modal stacking context when the dialog is inside an app-drawer.
         * @param e
         * @private
         */
        _fixModalStacking: function (e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },

        /**
         * Set up a click listener on the passed map entity that when clicked will de-select the currently selected stack.
         * @param mapEntity
         * @private
         */
        _deselectStacksOnClick: function(mapEntity) {
            var _this = this;
            google.maps.event.addListener(mapEntity, 'click', function() {
                if (_this._loadedAlert &&  _this._loadedAlert.selectedStack) {
                    _this._loadedAlert.selectedStack.deactivateZoneOverlays();
                    _this.set('_loadedAlert.selectedStack',null);
                }
            });
        },

        /**
         * A promise that when resolved indicates that google maps is ready. Can be used in public facing functions
         * to avoid race conditions where the function tries to execute map related calls before the map is ready.
         * @returns {*}
         * @private
         */
        _mapIsReady: function() {
            var _this = this;
            return new Promise(function (resolve) {
                if (this._map) {
                    resolve();
                }
                else {
                    waitForMap();
                    function waitForMap() {
                        if (!_this._map) {
                            setTimeout(function(){waitForMap();},100);
                            return;
                        }
                        resolve();
                    }
                }
            });
        },

        /**
         * Manages component state between realm changes.
         * @param newRealm
         * @private
         */
        _realmChanged: function(newRealm) {
            //We don't render the region on the map for the alert view.
            if (this.nodeName !== 'VOYENT-ALERT-VIEW') {
                //Only proceed if we have a valid realm and the map is initialized.
                if (!newRealm || !this._map) { return; }
                //First clear the current region from the map.
                if (this._areaRegion && this._areaRegion.polygon) {
                    this._areaRegion.polygon.setMap(null);
                    this._areaRegion = null;
                }
                //Check if we have the realm region cached otherwise fetch it.
                var areaRegion = this._regionMapping && this._regionMapping[newRealm] ?
                    this._regionMapping[newRealm] : null;
                if (areaRegion && areaRegion.polygon) {
                    areaRegion.polygon.setMap(this._map);
                    this._areaRegion = areaRegion;
                }
                else {
                    this._fetchRealmRegion();
                }
            }
            //Clear the map entirely.
            this.clearMap();
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                //Refresh the map with the latest data.
                this.fetchAlertTemplates();
            }
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Manages the stack marker icons.
         * @param selectedStack
         * @private
         */
        _selectedStackChanged: function(selectedStack) {
            if (this._loadedAlert) {
                if (this._loadedAlert.template.zoneStacks.length === 1) {
                    this._loadedAlert.template.zoneStacks[0].marker.setIcon(this.pathtoimages+'/img/alert_marker.png');
                }
                else {
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        this._loadedAlert.template.zoneStacks[i].marker.setIcon(null);
                    }
                    if (selectedStack) {
                        selectedStack.marker.setIcon(this.pathtoimages+'/img/green-marker.png');
                    }
                }
            }
        }
    };
</script>