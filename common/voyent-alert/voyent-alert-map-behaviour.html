<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="../../../paper-button/paper-button.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common map-related functionality required by `voyent-alert-template-editor` and `voyent-alert-editor` components.
     *
     * @polymerBehavior AlertMapBehaviour
     */
    Voyent.AlertMapBehaviour = {
        properties: {
            /**
             * The Voyent account used for authentication.
             * @default voyent.auth.getLastKnownAccount()
             */
            account: { type: String },
            /**
             * The Voyent realm to create the Alert Template in.
             * @default voyent.auth.getLastKnownRealm()
             */
            realm: { type: String },
            /**
             * The height of the google map to be created, as an integer. If left empty we will default to the height
             * of the parent container. If a height cannot be found then a default minimum of 500 will be used.
             */
            height: Number,
            /**
             * The width of the google map to be created, as an integer. If left empty we will default to the width of the
             * parent container minus the width of the side panel.
             */
            width: Number,
            /**
             * Enable a percent of the full page height to automatically fill with the map. To disable use a value of -1.
             * Height = "h*autoheight" so 0.8 corresponds to 80% of the page height. 1.2 would be 120%, etc.
             */
            autoheight: { type: Number, value: -1, notify: true },
            /**
             * The relative path to the `img` resource directory. This may be
             * necessary when using the component as part of a custom build.
             */
            pathtoimages: { type: String, value: '.', observer: '_pathtoimagesChanged' }
        },

        ready: function() {
            var _this = this;
            //Default to the last realm and account if one is not set.
            if (!this.realm) {
                this.realm = voyent.auth.getLastKnownRealm();
            }
            if (!this.account) {
                this.account = voyent.auth.getLastKnownAccount();
            }
            window.initializeLocationsMap = function () {
                _this._map = new google.maps.Map(_this.$.map, {
                    zoom: 10,
                    center: new google.maps.LatLng(51.08427,-114.13062),
                    streetViewControl: false,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.RIGHT_TOP
                    },
                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.LARGE,
                        position: google.maps.ControlPosition.LEFT_CENTER
                    }
                });
                //Calculate the map size.
                _this._calcMapSize();
                //Setup ui and listeners for adding new alert templates.
                _this._drawingManager = new google.maps.drawing.DrawingManager({
                    map:_this._map,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        drawingModes: []
                    },
                    markerOptions: {draggable:true, 'zIndex':50}
                });
                _this._setupDrawingListeners();
                _this._isLoggedIn = false; //Toggle for side panel.
                //More initialization for each component after login.
                if (voyent.auth.isLoggedIn()) {
                    _this._onAfterLogin();
                }
                window.addEventListener('voyent-login-succeeded',function() {
                    _this._onAfterLogin();
                });
                //Make sure the map is sized correctly when the window size changes.
                google.maps.event.addListener(window, 'resize', function () {
                    _this.resizeMap();
                });
            };
            if (!('google' in window) || !('maps' in window.google)) {
                var script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyAZVsIO4CmSqqE7qbSO8pB0JPVUkO5bOd8&v=3.27&' +
                    'libraries=places,geometry,visualization,drawing&callback=initializeLocationsMap';
                this.$.container.appendChild(script);
            }
            else {
                initializeLocationsMap();
            }
        },

        /**
         * Re-calculates the map size and fires the Google Map resize event.
         */
        resizeMap: function() {
            if (('google' in window) && this._map) {
                this._calcMapSize();
                google.maps.event.trigger(this._map, 'resize');
            }
        },

        /**
         * Saves or updates the current Alert Template.
         * @param alertTemplateData - Optional
         */
        saveAlertTemplate: function (alertTemplateData) {
            //Use this flag to avoid race conditions if the user mashes the "Activate Now" and "Back" buttons.
            if (this._savingAlert) { return; }
            this._savingAlert = true;
            if (this._loadedAlertTemplateData) {
                alertTemplateData = this._loadedAlertTemplateData;
            }
            if (!alertTemplateData) { return; }
            var _this = this;
            var func = !alertTemplateData.isPersisted ? 'createTracker' : 'updateTracker';
            //Clone the object and remove the tmpProperties we use in the template.
            var alertTemplate = JSON.parse(JSON.stringify(alertTemplateData.alertTemplate));
            delete alertTemplate.tmpProperties;
            for (var i=0; i<alertTemplate.zones.features.length; i++) {
                delete alertTemplate.zones.features[i].tmpProperties;
            }
            voyent.locate[func]({
                realm: this.realm,
                account: this.account,
                tracker: alertTemplate,
                id: alertTemplate._id //Not valid if 'createTracker' but no harm in passing it anyway.
            }).then(function (uri) {
                _this._savingAlert = false;
                if (func === 'createTracker') {
                    //Grab the generated ID from the return URI and setup change listeners
                    _this.set('_loadedAlertTemplateData.alertTemplate._id',uri ? uri.split('/').pop() : alertTemplateData.alertTemplate._id);
                    alertTemplateData.isPersisted = true;
                    if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                        _this.fire('message-info', 'Alert Template successfully created.');
                    }
                }
                else if (_this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                    _this.fire('message-info', 'Alert Template successfully updated.');
                }
                //Update our local copy of the persisted Alert Template.
                alertTemplateData.persistedAlertTemplate = JSON.parse(JSON.stringify(alertTemplate));
                //Fire an event for anyone interested.
                _this.fire('voyent-alert-template-saved',{});
            }).catch(function (error) {
                _this._savingAlert = false;
                if (func === 'createTracker') {
                    //If the initial creation fails then remove it from the map.
                    alertTemplateData.marker.setMap(null);
                    for (var i = 0; i < alertTemplateData.circles.length; i++){
                        alertTemplateData.circles[i].setMap(null);
                    }
                }
                _this.fire('message-error', 'Issue saving Alert Template ' + error.responseText || error.message);
                console.error('Issue saving Alert Template', error.responseText || error.message);
            });
        },

        /**
         * Clears the map of the loaded Alert and conditionally also the drawn Alerts.
         * @param clearAlerts
         */
        clearMap: function(clearAlerts) {
            //Always re-zoom the bounds on the area's region if available.
            if (this._regionBounds) {
                this._map.fitBounds(this._regionBounds);
                this._map.panToBounds(this._regionBounds);
            }
            //Clear loaded Alert Template.
            if (this._loadedAlertTemplateData) {
                deleteAlertEntity(this._loadedAlertTemplateData);
                this._loadedAlertTemplateData = null;
            }
            //Clear all Alerts.
            if (clearAlerts && this._alerts) {
                for (var i=0; i<this._alerts.length; i++) {
                    deleteAlertEntity(this._alerts[i]);
                }
            }
            //Re-draw the buttons.
            if (this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                this._drawingManager.setOptions({
                    "drawingControlOptions":{
                        "drawingModes":['marker'],
                        "position":google.maps.ControlPosition.TOP_RIGHT}
                });
            }
            else {
                this._addAlertButton();
            }
            function deleteAlertEntity(alertTemplateData) {
                //Remove the marker, circles and zoneOverlays from the map.
                alertTemplateData.marker.setMap(null);
                for (var i=0; i<alertTemplateData.circles.length; i++) {
                    alertTemplateData.circles[i].setMap(null);
                    alertTemplateData.zoneOverlays[i].setMap(null);
                }
            }
        },

        //******************PRIVATE API******************

        /**
         * Retrieves all the regions for the realm.
         * @returns {*}
         * @private
         */
        _fetchRegions: function() {
            var _this = this;
            return new Promise(function (resolve, reject) {
                voyent.locate.getAllRegions({realm:_this.realm,account:_this.account}).then(function (regions) {
                    //Filter out the Alert regions and we should only be left with the static area Region.
                    _this._drawRegion(regions.filter(function(region) {
                        return !region.location.properties || !region.location.properties.trackerId;
                    })[0]);
                    resolve();
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue fetching or drawing Region ' + error.responseText || error.message || error);
                    console.error('Issue fetching or drawing Region', error.responseText || error.message || error);
                    reject(error);
                });
            });
        },

        /**
         * Draws the passed polygon region on the map.
         * @param region
         * @private
         */
        _drawRegion: function(region) {
            if (!region || !region.location || !region.location.geometry || !region.location.geometry.coordinates) {
                return;
            }
            this._regionBounds = new google.maps.LatLngBounds();
            var coords = region.location.geometry.coordinates,
                googlePoint, paths = [], path = [];
            //Generate the ordered sequence of coordinates that completes the Polygon shape.
            for (var j = 0; j < coords.length; j++) {
                for (var k = 0; k < coords[j].length; k++) {
                    googlePoint = new google.maps.LatLng(coords[j][k][1], coords[j][k][0]);
                    path.push(googlePoint);
                    //Extend our bounds object so we can pan the map later.
                    this._regionBounds.extend(googlePoint);
                }
                paths.push(path);
            }
            //Draw the Polygon.
            var polygon = new google.maps.Polygon({
                'paths': paths,
                'map': this._map,
                'editable': false,
                'clickable': false //Necessary to get the Alert cursor to display correctly.
            });
            //Zoom on the newly drawn Region.
            this._map.fitBounds(this._regionBounds);
            this._map.panToBounds(this._regionBounds);
            //Save a reference to the region JSON and map polygon for later.
            this._areaRegion = {"region":region,"polygon":polygon};
        },

        /**
         * Draws the passed Alert or Alert Template on the map and sets up the properties panel or Alert list.
         * @param alertTemplate
         * @param alertLocation - If an Alert then this is the location data associated with it.
         * @private
         */
        _drawAlertEntity: function(alertTemplate,alertLocation) {
            var alertTemplateData = null;
            //Create the marker and build the alertTemplateData.
            var marker = new google.maps.Marker({
                position: new google.maps.LatLng(alertTemplate.anchor.geometry.coordinates[1],alertTemplate.anchor.geometry.coordinates[0]),
                map: this._map,
                draggable: true,
                zIndex: 50,
                icon: this.nodeName === 'VOYENT-ALERT-EDITOR' ? this.pathtoimages+'/img/alert_marker.png' : null
            });
            //This is triggered from alert-template-editor when drawing templates or from alert-editor when drawing Alerts.
            if (!this._loadedAlertTemplateData || alertLocation) {
                alertTemplateData = {"alertTemplate":alertTemplate,
                    "persistedAlertTemplate":JSON.parse(JSON.stringify(alertTemplate)),
                    "marker":marker,"circles":[],"zoneOverlays":[],"highestLats":[],"isPersisted":true};
                if (alertLocation) { alertTemplateData.alertInstance = alertLocation; }
                //Load immediately since it's a template.
                else { this._loadedAlertTemplateData = alertTemplateData; }
            }
            //This will be triggered from alert-editor when drawing child templates only
            else {
                //Alert template data already initialized as a child template so just set the marker.
                alertTemplateData = this._loadedAlertTemplateData;
                alertTemplateData.marker = marker;
            }

            //Add the tmpProperties to the Alert Template (used by the view).
            alertTemplateData.alertTemplate.tmpProperties = this._getAlertTemplateTmpProperties();

            //Generate the circles and bind them to the marker.
            var zones = alertTemplateData.alertTemplate.zones.features,circle, properties;
            alertTemplateData.highestLats = [];
            for (var i=0; i<zones.length; i++) {
                //Add the tmpProperties to the Zone (used by the view).
                zones[i].tmpProperties = this._getZoneTmpProperties();
                //Set the properties of the circle based on the alertTemplate JSON.
                properties = this._getCircleProperties();
                //Don't allow editing Alert zone sizes unless the Alert is active.
                properties.editable = alertLocation ? false : zones[i].properties.Editable;
                properties.radius = zones[i].properties.googleMaps.radius;
                properties.fillColor = '#'+ zones[i].properties.Color;
                properties.fillOpacity = zones[i].properties.Opacity;
                properties.zIndex = zones[i].properties.googleMaps.zIndex;
                //Create the circle and bind it.
                circle = new google.maps.Circle(properties);
                circle.bindTo('center', marker, 'position');
                alertTemplateData.circles.push(circle);
                //Determine where to draw the Proximity Zone label overlay and draw it.
                alertTemplateData.highestLats.push(this._determineHighestLat(zones[i].geometry.coordinates[0]));
                alertTemplateData.zoneOverlays.push(new this._ProximityZoneOverlay(alertTemplateData,i));
            }
            //Set the alertTemplateData or alerts array depending on what we are drawing
            if (alertLocation) {
                this.push('_alerts',alertTemplateData);
                //Update the template coordinates to correctly calculate the positions of the labels.
                this._updateAlertTemplateJSON(alertTemplateData);
            }
            //Add the change listeners to the marker and circles.
            this._setupChangeListeners(alertTemplateData);
            if (this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR') {
                //Disable further Alert Template creations - only allowed one at a time.
                this._drawingManager.setOptions({
                    "drawingControlOptions":{
                        "drawingModes":[],
                        "position":google.maps.ControlPosition.TOP_RIGHT}
                });
            }
            else { //VOYENT-ALERT-EDITOR
                if (!alertLocation) {
                    //Disable further Alert creations - only allowed one at a time.
                    var alertBttn = this.querySelector('#alertBttn');
                    alertBttn.parentNode.removeChild(alertBttn);
                }
            }
        },

        /**
         * Determines the highest latitude of the passed coordinates array, used to
         * calculate where to render the Proximity Zone overlay label.
         * @param coordinates
         * @returns {number}
         * @private
         */
        _determineHighestLat: function(coordinates) {
            var highestLat = -100;
            for (var i=0; i<coordinates.length; i++) {
                if (coordinates[i][1] > highestLat) {
                    highestLat = coordinates[i][1];
                }
            }
            return highestLat;
        },

        /**
         * Determine the map size to use. This will leverage this.height and this.width if available. Otherwise the parent
         * container size will be used. If this.autoheight is specified than it will override this.height.
         */
        _calcMapSize: function() {
            var _this = this;
            //Do this async so the container has time to load and properly calculate it's size.
            setTimeout(function() {
                var height = _this.height;
                //If we have a valid autoheight specified we override with that
                if (_this.autoheight && _this.autoheight !== null && _this.autoheight > 0) {
                    var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                    if (h) {
                        height = Math.round(h * _this.autoheight);
                    }
                }
                else {
                    //If we don't have a height try the parent
                    if (height == null) {
                        height = _this.$$('#container').clientHeight;
                    }
                    //If we still don't have a valid height default to a minimum
                    if (height < 50) {
                        height = 500;
                    }
                }
                _this.customStyle['--height-var'] = height + 'px';

                //If the width is specified then set it
                if (_this.width && _this.width !== null && _this.width > 0) {
                    _this.customStyle['--width-var'] = _this.width + 'px';
                }
                else { //Otherwise the map will take up as much space as possible (-4px for map borders)
                    _this.customStyle['--width-var'] = (_this.querySelector('#container').offsetWidth -
                        _this.querySelector('#sidePanel').offsetWidth - 4) + 'px';
                }
                //Apply the styles
                _this.updateStyles();
            },0);
        },

        /**
         * Validates the new attribute value and fires the `pathtoimagesChanged` event.
         * @param newPath
         * @private
         */
        _pathtoimagesChanged: function(newPath) {
            if (newPath.charAt[newPath.length-1] === '/') {
                this.path = newPath.slice(0,-1);
                return;
            }
            this.fire('pathtoimagesChanged',{'path':newPath});
        },

        /**
         * Returns temporary Alert Template properties used by the view.
         * @returns {{renaming: boolean, newName: string}}
         * @private
         */
        _getAlertTemplateTmpProperties: function() {
            return {
                "renaming":false,
                "newName":''
            }
        }
    };
</script>