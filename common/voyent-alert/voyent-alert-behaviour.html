<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {

        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'}
        },

        ready: function() {
            this._loadedAlertTemplateData = null;
        },

        observers: ['_zonesUpdated(_loadedAlertTemplateData.alertTemplate.zones.features.splices)'],

        /**
         * Initialize google map listeners for moving, resizing and clicking of Alert Templates.
         * @param alertTemplateData
         * @private
         */
        _setupMapListeners: function(alertTemplateData) {
            var _this = this;
            if (alertTemplateData.marker) {
                //Clear any previously added listeners (since we call this function again for newly added zones).
                google.maps.event.clearInstanceListeners(alertTemplateData.marker);
                //Handle dragging by the marker.
                google.maps.event.addListener(alertTemplateData.marker,'dragstart',function() {
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the marker so we'll use this flag to ignore those events.
                    _this._ignoreCenterChanges = true;
                });
                google.maps.event.addListener(alertTemplateData.marker,'dragend',function() {
                    alertEntityMoved(alertTemplateData);
                    _this._ignoreCenterChanges = false;
                });
                //Add click listener to marker.
                google.maps.event.addListener(alertTemplateData.marker,'click',function() {
                    //Toggle all the accordions closed.
                    if (_this._loadedAlertTemplateData) {
                        _this._toggleAccordion(-1);
                    }
                    //Load the clicked template data in case it's a different template.
                    _this._loadedAlertTemplateData = alertTemplateData;
                });
                //Prevent the Alert entity from being dragged outside of the region.
                google.maps.event.addListener(alertTemplateData.marker,'drag',function(e) {
                    if (!google.maps.geometry.poly.containsLocation(e.latLng,_this._areaRegion.polygon)) {
                        alertTemplateData.marker.setPosition(_this._previousDragPosition);
                        return;
                    }
                    _this._previousDragPosition = e.latLng;
                });
            }
            var zones = alertTemplateData.alertTemplate.zones.features;
            for (var i=0; i<zones.length; i++) {
                (function(zone) {
                    //Clear any previously added listeners (since we call this function again for newly added zones).
                    google.maps.event.clearInstanceListeners(zone.tmpProperties.circle);
                    //Handles updating the position of an Alert entity when
                    //dragging by the inner-most circle's drag point.
                    google.maps.event.addListener(zone.tmpProperties.circle,'center_changed',function() {
                        //Ignore when dragging by marker and only proceed for one zone.
                        if (_this._ignoreCenterChanges || alertTemplateData.alertTemplate.zones.features.indexOf(zone) !== 0) { return; }
                        alertEntityMoved(alertTemplateData);
                    });
                    //Add resize listener to circle.
                    google.maps.event.addListener(zone.tmpProperties.circle,'radius_changed',function() {
                        //Update the JSON since the size of a zone changed.
                        _this._updateAlertTemplateJSON(alertTemplateData);
                        //Adjust the position of the Proximity Zone label since the radius changed.
                        _this._redrawZoneOverlay(alertTemplateData,alertTemplateData.alertTemplate.zones.features.indexOf(zone));
                        //Sort the zones list.
                        _this._sortZonesBySize();
                    });
                    //Add click listener to circle.
                    google.maps.event.addListener(zone.tmpProperties.circle,'click',function() {
                        var zoneIndex = alertTemplateData.alertTemplate.zones.features.indexOf(zone);
                        //If we have a currently loaded Alert Template or Alert...
                        if (_this._loadedAlertTemplateData) {
                            //If they click a zone for the currently active
                            //Alert Template or Alert then toggle the accordion.
                            if (_this._loadedAlertTemplateData === alertTemplateData) {
                                _this._toggleAccordion(zoneIndex);
                            }
                            else {
                                //Toggle the accordion for the previously selected Alert Template.
                                _this._toggleAccordion(-1);
                                //Load the new one and toggle the selected zone.
                                _this._loadedAlertTemplateData = alertTemplateData;
                                _this._toggleAccordion(zoneIndex);
                            }
                        }
                        else { //If we have no loaded data then always load the template and toggle the selected zone.
                            _this._loadedAlertTemplateData = alertTemplateData;
                            _this._toggleAccordion(zoneIndex);
                        }
                    });
                })(zones[i]);
            }
            /**
             * Handles drags by the anchor or the inner-most zone's drag point.
             * @param alertTemplateData
             */
            function alertEntityMoved(alertTemplateData) {
                //Update the template coordinates (always required to maintain label positions).
                _this._updateAlertTemplateJSON(alertTemplateData);
                if (alertTemplateData.alertInstance) {
                    //Update the Alert's location.
                    _this._updateAlertLocation(alertTemplateData);
                }
                //Adjust the position of the Proximity Zone labels since all of
                //their positions changed. We pass in the necessary alertTemplateData
                //since it's possible they dragged an Alert without it being active.
                _this._redrawZoneOverlay(alertTemplateData);
            }
        },

        /**
         * Updates the current Alert Location using the passed data or the current Alert Template data.
         * @param alertTemplateData
         * @private
         */
        _updateAlertLocation: function(alertTemplateData) {
            var _this = this, coordinates, zoneNamespace, activatingAlert = this._activatingAlert;
            if (activatingAlert) {
                //We don't have existing Alert data yet so base the location
                //off the template position an set a new zoneNamespace.
                alertTemplateData = this._loadedAlertTemplateData;
                coordinates = alertTemplateData.alertTemplate.anchor.geometry.coordinates;
                zoneNamespace = new Date().getTime().toString();
                //Disable activation mode and show the existing Alerts again. Do this immediately for a responsive UI.
                this._toggleActivatingAlert();
                this._toggleActiveAlerts(true);
            }
            else {
                //We have a existing Alert data so base the location off
                //the marker position an use the existing zoneNamespace.
                var pos = alertTemplateData.marker.getPosition();
                coordinates = [pos.lng(),pos.lat()];
                zoneNamespace = alertTemplateData.alertInstance.location.properties.zoneNamespace;
            }
            //Create the new Alert location.
            var location = {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : coordinates },
                    "properties": {
                        "trackerId": alertTemplateData.alertTemplate._id,
                        "zoneNamespace": zoneNamespace,
                        "vras": {
                            "isNewAlert": activatingAlert
                        }
                    }
                }
            };
            voyent.locate.updateTrackerLocation({location: location}).then(function(data) {
                //Always update our stored instance location.
                _this.set('_loadedAlertTemplateData.alertInstance',location);
                if (activatingAlert) {
                    //Update our list of Alerts and keep the overlay alert index in sync.
                    _this.push('_alerts',alertTemplateData);
                    //Restore the create button.
                    _this._addAlertButton();
                    _this.fire('message-info', 'New Alert Activated!');
                }
            }).catch(function (error) {
                _this.fire('message-error', 'Issue creating new Alert: ' + location.location.properties.zoneNamespace);
            });
        },

        /**
         * Syncs the Alert Template JSON with the current state of the map entities.
         * @param alertTemplateData
         * @private
         */
        _updateAlertTemplateJSON: function (alertTemplateData) {
            if (!alertTemplateData) {
                alertTemplateData = this._loadedAlertTemplateData;
            }
            if (!alertTemplateData) { return; }
            //Sync the marker coordinates (if available) with the alertTemplate
            //anchor in case the alertTemplate position has moved.
            if (alertTemplateData.marker) {
                alertTemplateData.alertTemplate.anchor.geometry.coordinates = [alertTemplateData.marker.getPosition().lng(),alertTemplateData.marker.getPosition().lat()];
            }
            var features = alertTemplateData.alertTemplate.zones.features;
            var N = 50; //The number of coordinates the circle approximation will have.
            var degreeStep = 360 / N; //The number of degrees in which each coordinate will be spaced apart.
            for (var i=0; i<features.length; i++) {
                if (!features[i].tmpProperties) { features[i].tmpProperties = this._getZoneTmpProperties(); }
                features[i].tmpProperties.highestLat = -100;
                //Sync the alertTemplate zone properties with the zones drawn on the map (if available).
                if (features[i].tmpProperties.circle) {
                    features[i].properties.googleMaps.radius = features[i].tmpProperties.circle.getRadius();
                    features[i].properties.googleMaps.center = [features[i].tmpProperties.circle.getCenter().lat(),features[i].tmpProperties.circle.getCenter().lng()];
                    features[i].properties.Color = features[i].tmpProperties.circle.get('fillColor').substring(1); //Remove the '#'.
                    features[i].properties.googleMaps.zIndex = features[i].tmpProperties.circle.get('zIndex');
                }
                features[i].geometry.coordinates = [[]];
                for (var j=0; j<N; j++) {
                    //Calculate and save the next coordinate.'
                    var latLng = google.maps.geometry.spherical.computeOffset(
                        new google.maps.LatLng(features[i].properties.googleMaps.center[0],features[i].properties.googleMaps.center[1]),
                        features[i].properties.googleMaps.radius,
                        degreeStep * j);
                    features[i].geometry.coordinates[0].push([latLng.lng(), latLng.lat()]);
                    //Look for the northern most point of the circle so we know
                    //where to render the Proximity Zone overlay label.
                    if (latLng.lat() > features[i].tmpProperties.highestLat) {
                        features[i].tmpProperties.highestLat = latLng.lat();
                    }
                }
                //In addition to N coordinates we also need to copy the
                //first one to the last one to complete the circle.
                features[i].geometry.coordinates[0].push(features[i].geometry.coordinates[0][0]);
            }
        },

        /**
         * Toggles the accordion panels. This is used to toggle the accordion
         * for both accordion pane and proximity zone clicks.
         * @param eOrI
         * @private
         */
        _toggleAccordion: function(eOrI) {
            //This function will either be passed an event (from the ui) or a direct index (from the JS).
            var index = eOrI.model ? eOrI.model.get('index') : eOrI;
            //If they toggle the currently toggled accordion pane then we'll close it.
            if (index !== -1 && this._loadedAlertTemplateData.alertTemplate.zones.features[index].tmpProperties.visible) {
                index = -1;
            }
            //Hide the accordions, remove the selected styling and editable zones.
            var zones = this._loadedAlertTemplateData.alertTemplate.zones.features;
            for (var i=0; i<zones.length; i++) {
                this.set('_loadedAlertTemplateData.alertTemplate.zones.features.'+i+'.tmpProperties.visible',false);
                zones[i].tmpProperties.circle.setOptions({"strokeWeight":0});
                zones[i].tmpProperties.circle.setEditable(false);
            }
            //Show the accordion contents for the selected zone, add the selected styling and set
            //the editable value. If the index is -1 then we'll de-toggle all Accordion panes.
            if (index !== -1) {
                this.set('_loadedAlertTemplateData.alertTemplate.zones.features.'+index+'.tmpProperties.visible',true);
                zones[index].tmpProperties.circle.setOptions({"strokeWeight":3});
                zones[index].tmpProperties.circle.setEditable(zones[index].properties.Editable);
            }
            //Fire an event indicating which zone was loaded (-1 means no zone is loaded).
            this.fire('voyent-zone-toggled', {
                'alertTemplate': this._loadedAlertTemplateData.alertTemplate,
                'selectedZoneIndex': index
            });
        },

        /**
         * Redraws a specific Proximity Zone overlay based on the passed index or redraws them all if no index is available.
         * @param alertTemplateData
         * @param i
         * @private
         */
        _redrawZoneOverlay: function(alertTemplateData,i) {
            var zones = alertTemplateData.alertTemplate.zones.features;
            if (typeof i !== 'undefined') {
                zones[i].tmpProperties.zoneOverlay.draw();
            }
            else {
                for (i=0; i<zones.length; i++) {
                    zones[i].tmpProperties.zoneOverlay.draw();
                }
            }
        },

        /**
         * Our simple implementation of Google's OverlayView Class. Used to display Proximity Zone labels on the map.
         * @private
         */
        _initializeProximityZoneOverlayView: function() {
            var _outer = this;

            //Constructor
            this._ProximityZoneOverlay = function(zone) {
                //Link this Proximity Zone overlay with the passed zone and our map object.
                this.zone = zone;
                this.setMap(_outer._map);
            };

            //Set the custom overlay object's prototype to a new instance of OverlayView.
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();

            //Called automatically when the map is ready for the overlay to be attached.
            this._ProximityZoneOverlay.prototype.onAdd = function () {
                //Begin to setup the div.
                this.div = document.createElement('div');
                this.div.style.borderStyle = 'none';
                this.div.style.borderWidth = '0px';
                this.div.style.position = 'absolute';
                // Add the element to the "overlayLayer" pane.
                this.getPanes().overlayLayer.appendChild(this.div);
            };

            //Handles visually displaying the overlay on the map. Called when the object is first displayed
            //and again whenever we want to redraw the overlay, like when the positon changes.
            this._ProximityZoneOverlay.prototype.draw = function () {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(this.zone.tmpProperties.highestLat,this.zone.tmpProperties.circle.getCenter().lng())
                );
                //Set the div content.
                this.div.innerHTML = this.zone.properties.zoneId;
                //Center the label above the zone.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-20 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#'+this.zone.properties.Color;
                this.div.style.color = this.returnColorBasedOnBackground(this.zone.properties.Color);
                this.div.style.padding = '5px';
                this.div.style.fontSize = '8px';
                this.div.style.zIndex = 10000;
                this.div.style.opacity = 0.8;
                this.div.style.borderRadius = '25px';
            };

            //Cleans up the overlay whenever the overlays map property is set to null.
            this._ProximityZoneOverlay.prototype.onRemove = function () {
                this.div.parentNode.removeChild(this.div);
                this.div = null;
            };

            //Returns #000 or #FFF depending on the passed HEX value.
            this._ProximityZoneOverlay.prototype.returnColorBasedOnBackground = function(hex) {
                //Convert 3 digits to 6.
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                //Just return black if we receive an invalid colour.
                if (hex.length !== 6) {
                    return '#000';
                }
                //Calculate
                var r = parseInt(hex.slice(0, 2), 16),
                    g = parseInt(hex.slice(2, 4), 16),
                    b = parseInt(hex.slice(4, 6), 16);
                return (r * 0.299 + g * 0.587 + b * 0.114) > 186
                    ? '#000'
                    : '#FFF';
            };
        },

        /**
         * Sorts the Proximity Zones based on their radius.
         * @private
         */
        _sortZonesBySize: function() {
            var _this = this;
            //Async so the template updates properly.
            setTimeout(function() {
                //Sort.
                _this._loadedAlertTemplateData.alertTemplate.zones.features.sort(_this._sortZones);
                //Force the template-repeat to re-render.
                var repeat = document.querySelector('#zones-repeat');
                if (repeat) { repeat.render(); }
                //The zoneIndex might have changed for the loaded zone so determine the index and re-fire the event.
                var selectedZoneIndex = -1;
                for (var i=0;i<_this._loadedAlertTemplateData.alertTemplate.zones.features.length; i++) {
                    if (_this._loadedAlertTemplateData.alertTemplate.zones.features[i].tmpProperties.visible) {
                        selectedZoneIndex = i;
                        break;
                    }
                }
                _this.fire('voyent-zone-toggled', {
                    'alertTemplate': _this._loadedAlertTemplateData.alertTemplate,
                    'selectedZoneIndex': selectedZoneIndex
                });
                //Update the z-indexes so we can always click the zones.
                _this._adjustZIndexes();
            },0)
        },

        /**
         * Template helper for sorting the Proximity Zones by size and managing the z-index of the zones.
         * @param a
         * @param b
         * @private
         */
        _sortZones: function(a,b) {
            if (a.properties.googleMaps.radius < b.properties.googleMaps.radius) { return -1; }
            else if (a.properties.googleMaps.radius > b.properties.googleMaps.radius) { return 1; }
            return 0;
        },

        /**
         * Maintains the correct z-index for each Proximity Zone.
         * @private
         */
        _adjustZIndexes: function() {
            var zIndex=49, zones = this._loadedAlertTemplateData.alertTemplate.zones.features;
            for (var i=0; i<zones.length; i++) {
                zones[i].tmpProperties.circle.setOptions({'zIndex':zIndex});
                zIndex--;
            }
        },

        /**
         * Monitors changes to the zones list for sorting purposes.
         * @private
         */
        _zonesUpdated: function() {
            var _this = this;
            if (_this._loadedAlertTemplateData &&
                _this._loadedAlertTemplateData.alertTemplate.zones.features.length) {
                this._sortZonesBySize();
            }
        },

        /**
         * All components need a reference to the the OverlayView class so once the map is set we'll initialize it.
         */
        _mapChanged: function(map) {
            if (map) {
                //Initialize our custom OverlayView class.
                this._initializeProximityZoneOverlayView();
            }
        },

        /**
         * Returns the default JSON structure of a Proximity Zone.
         * @returns {{type: string, geometry: {type: string, coordinates: [*]}, properties: {googleMaps: {shape: string, radius: number, zIndex: number}, Editable: string, Color: string}}}
         * @private
         */
        _getZoneJSON: function() {
            return {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[]]
                },
                "properties": {
                    "googleMaps": {
                        "shape": "circle",
                        "center": [],
                        "radius": 500,
                        "zIndex": 49 //49 for the first zone and -1 for each following zone
                    },
                    "Editable": true,
                    "Color": "000000",
                    "zoneId": "Zone_1",
                    "Opacity": 0.30
                },
                //These properties are used by the view and will be removed before saving the alertTemplate.
                "tmpProperties": this._getZoneTmpProperties()
            };
        },

        /**
         *
         * @returns {{renaming: boolean, newName: string, visible: boolean, highestLat: number}}
         * @private
         */
        _getZoneTmpProperties: function() {
            return {
                "renaming": false,
                "newName":'',
                "visible":false,
                "highestLat":-100,
                "circle": null,
                "zoneOverlay":null
            }
        },

        /**
         * Returns the default properties for building a google maps circle, the entity that represents a Proximity Zone.
         * @returns {{editable: boolean, draggable: boolean, radius: number, fillColor: string, strokeWeight: number, zIndex: number, map: (*|google.maps.Map|null)}}
         * @private
         */
        _getCircleProperties: function() {
            return {
                editable: false, draggable: false,
                radius: 500, fillColor: '#000000',
                fillOpacity: 0.30,
                strokeWeight:0, zIndex: 49,
                map: this._map
            };
        }
    };
</script>