<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {
        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'},
            /**
             * The location host for convenience of linking.
             */
            locationHost: { type: String, value: window.location.host }
        },

        ready: function() {
            this._loadedAlert = null;
            //Define some constants.
            //The number of coordinates circular polygons will have.
            this._NUM_CIRCULAR_POLY_SIDES = 100;
            //The number of degrees in which each coordinate will be spaced apart.
            this._CIRCULAR_POLY_DEGREE_STEP = 360 / this._NUM_CIRCULAR_POLY_SIDES;
            //The id of the fallback zone under the properties section.
            this._FALLBACK_ZONE_ID = 'fallback_zone';
            //My Location icons.
            this._MY_LOCATION_ICON_INACTIVE = this.pathtoimages+'/img/green_marker_circle.png';
            this._MY_LOCATION_ICON_ACTIVE = this.pathtoimages+'/img/green_marker_star.png';
            //Messages.
            this._OVERLAP_WITHIN_STACK_MSG = 'The zone cannot overlap other zones in the stack';
        },

        getBadgeUrl: function(badgeName) {
            var url = window.location.protocol + '//' + this.locationHost + '/vras/images/badges/';
            if (badgeName && typeof badgeName === 'string') {
                url += badgeName;
            }
            else {
                url += 'info.png';
            }
            return url;
        },

        /**
         * Displays the zone properties for the zone matching the passed id.
         */
        selectZoneById: function(zoneId) {
            if (!this._loadedAlert || !this._loadedAlert.template.zoneStacks) { return; }
            for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                var zoneStack = this._loadedAlert.template.zoneStacks[i];
                var zone = zoneStack.getZoneById(zoneId);
                if (zone) {
                    if (!zone.active) {
                        if (zoneStack !== this._loadedAlert.selectedStack) {
                            this._toggleProperties(null);
                            this.set('_loadedAlert.selectedStack',zoneStack);
                        }
                        this._toggleProperties(zone);
                        return;
                    }
                }
                else {
                    if (this._fallbackZone && this._fallbackZone.id === zoneId && !this._fallbackZone.active) {
                        this._toggleFallbackZoneProperties();
                        return;
                    }
                }
            }
        },

        /**
         * Validates the currently loaded alert template and returns all errors and warnings in the response.
         * @returns {Object} - {"errors": [], "warnings": []}
         */
        validate: function() {
            var results = {"errors": [], "warnings": []};
            if (!this._loadedAlert || !this._loadedAlert.template ||
                (!this._loadedAlert.template.zoneStacks || !this._loadedAlert.template.zoneStacks.length) &&
                (!this._fallbackZone || !this._fallbackZone.enabled)) {
                results.errors.push('Must define at least one zone');
            }
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                //Ensure we have both movement parameters or none at all.
                if (this._alertSpeed && (!this._alertDirection && this._alertDirection !== 0)) {
                    results.errors.push('Moving alerts must have both a speed and direction defined (direction is missing)');
                }
                if (!this._alertSpeed && (this._alertDirection || this._alertDirection === 0)) {
                    results.errors.push('Moving alerts must have both a speed and direction defined (speed is missing)');
                }
                //Restrict moving alerts to a maximum of two zones, excluding the fallback zone.
                if (this._alertSpeed && (this._alertDirection || this._alertDirection === 0)) {
                    var zoneCount = 0;
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        zoneCount += this._loadedAlert.template.zoneStacks[i].zones.length;
                    }
                    if (zoneCount > 2) {
                        results.errors.push('Moving alerts are restricted to a maximum of two zones');
                    }
                }
            }
            return results;
        },

        /**
         * Saves or updates the current alert template.
         */
        saveAlertTemplate: function() {
            this._saveAlertTemplate().catch(function(e){})
        },

        /**
         * Wrapped function for `saveAlertTemplate` that returns a Promise for internal component use.
         * @returns {Promise}
         * @private
         */
        _saveAlertTemplate: function () {
            var _this = this, msg;
            return new Promise(function (resolve, reject) {
                if (_this._savingAlertTemplate) { return reject('already saving template'); }
                //Prompt the user if no categories are defined for the template.
                if (!_this._skipCategoryValidation &&
                    (!_this._loadedAlert.template.categories || !_this._loadedAlert.template.categories.length)) {
                    _this._openUncategorizedTemplateDialog();
                    return reject('no categories provided');
                }
                _this._savingAlertTemplate = true;

                _this._loadedAlert.template.updateJSON(true);
                var requestOpts = {realm: _this.realm, account: _this.account, alertTemplate: _this._loadedAlert.template.json};
                var func = 'createAlertTemplate';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlertTemplate';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlertTemplate = false;
                    if (func === 'createAlertTemplate') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                        _this.fire('message-info', 'Alert template successfully created');
                    }
                    else {
                        _this.fire('message-info', 'Alert template successfully updated');
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    _this._savingAlertTemplate = false;
                    _this.fire('message-error', 'Issue saving alert template: ' + (e.responseText || e.message || e));
                    reject(msg);
                });
            });
        },

        /**
         * Wrapper for `_saveAlertTemplate` that disables prompt for unspecified template categories.
         * @private
         */
        _saveAlertTemplateWithoutCategory: function() {
            var _this = this;
            this._skipCategoryValidation = true;
            this._closeUncategorizedTemplateDialog();
            this._saveAlertTemplate().then(function() {
                _this._skipCategoryValidation = false;
            });
        },

        /**
         * Builds the location JSON for the currently loaded alert.
         * @private
         */
        _buildAlertLocationJSON: function() {
            var pos;
            //If we have a template with at least two stacks it means we have a template centroid.
            if (this._loadedAlert.template.zoneStacks.length >= 2) {
                pos = this._loadedAlert.template.marker.getPosition();
            } //One stack means we only have a stack centroid.
            else if (this._loadedAlert.template.zoneStacks.length === 1) {
                pos = this._loadedAlert.template.zoneStacks[0].marker.getPosition()
            }
            else { //No stacks means we have no centroid, fallback zone only.
                pos = new google.maps.LatLng(0,0);
            }
            return {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : [pos.lng(),pos.lat()] },
                    "properties": {
                        "alertId": this._loadedAlert.template.id
                    },
                    "type": "Feature"
                }
            };
        },

        /**
         * Returns the rectangular path around the bounds of the polygon path.
         * @param path
         * @returns {google.maps.MVCArray}
         * @private
         */
        _getRectangularPathFromPolygonPath: function(path) {
            var bounds = new google.maps.LatLngBounds();
            path.forEach(function (element) {
                bounds.extend(element);
            });
            var ne = bounds.getNorthEast();
            var sw = bounds.getSouthWest();

            return new google.maps.MVCArray([new google.maps.MVCArray([ne,new google.maps.LatLng(sw.lat(),ne.lng()),sw,new google.maps.LatLng(ne.lat(),sw.lng())])]);
        },

        /**
         * Toggles the zone properties section from the side panel.
         * @param e
         * @private
         */
        _togglePropertiesFromSidePanel: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            var zone = zoneStack.getZoneAt(e.model.get('zoneIndex'));

            //If they click a zone for the currently active stack then toggle the accordion.
            if (this._loadedAlert.selectedStack && this._loadedAlert.selectedStack === zoneStack) {
                this._toggleProperties(zone);
            }
            else {
                //Toggle the accordion for the previously selected stack.
                this._toggleProperties(null);
                //Load the selected stack and toggle the selected zone.
                this.set('_loadedAlert.selectedStack',zoneStack);
                this._toggleProperties(zone);
            }
        },

        /**
         * Toggles the zone properties section. This is triggered directly when selecting a proximity
         * zone or from a wrapper function when clicking the accordion pane. In addition to toggling
         * the panes this will also trigger styling updates to zones overlays on the map.
         * @param zone - The zone to toggle properties for.
         * @private
         */
        _toggleProperties: function(zone) {
            if (!this._loadedAlert || !this._loadedAlert.template) { return; }

            // If they toggle the currently toggled accordion pane then we'll close it
            if (zone && zone.active) {
                zone = null;
            }
            // If the fallback zone is active then deactivate it
            if (this._fallbackZone && this._fallbackZone.active) {
                this._toggleFallbackZoneProperties(true);
            }
            else { // Otherwise deactivate all zone overlays
                this._loadedAlert.template.deactivateZoneStackOverlays();
            }
            // Fire the appropriate events
            if (zone) {
                zone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": zone.id,
                    "zone": zone,
                    "isFallbackZone": false
                });
                this._scrollToActivePane();
            }
            else {
                this.fire('voyent-alert-zone-selected',{
                    "id": null,
                    "zone": null
                });
            }
        },

        /**
         * Toggles the fallback zone properties section.
         * @param skipEvent
         * @private
         */
        _toggleFallbackZoneProperties: function(skipEvent) {
            if (this._fallbackZone.active) {
                this._fallbackZone.setActive(false);
                if (typeof skipEvent !== 'boolean' || !skipEvent) {
                    this.fire('voyent-alert-zone-selected',{
                        "id": null,
                        "zone": null
                    });
                }
            }
            else {
                if (this._loadedAlert && this._loadedAlert.selectedStack) {
                    this._loadedAlert.selectedStack.deactivateZoneOverlays();
                }
                this._fallbackZone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": this._fallbackZone.id,
                    "zone": this._fallbackZone,
                    "isFallbackZone": true
                });
                this._scrollToTop();
            }
        },

        /**
         * Toggles the movement properties section.
         * @private
         */
        _toggleMovement: function() {
            this._showMovement = !this._showMovement;
            this._scrollToBottom();
        },

        /**
         * Scrolls the properties panel to the currently active pane.
         * @private
         */
        _scrollToActivePane: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        var propertiesComp = propertiesPanel.querySelector('voyent-alert-properties');
                        if (propertiesComp) {
                            var activeZone = propertiesComp.querySelector('.header.active');
                            if (activeZone) {
                                propertiesPanel.scrollTop = activeZone.offsetTop;
                            }
                        }
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Scrolls the properties panel to the top.
         * @private
         */
        _scrollToTop: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        propertiesPanel.scrollTop = 0;
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Scrolls the properties panel to the bottom.
         * @private
         */
        _scrollToBottom: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        propertiesPanel.scrollTop = propertiesPanel.scrollHeight;
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Toggles the badge properties section.
         * @private
         */
        _toggleBadge: function() {
            this._showBadge = !this._showBadge;
        },

        /**
         * Add mouseover styling to zone when mousing over it in side panel.
         * @param e
         * @private
         */
        _mouseoverZoneProperties: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            this._mouseoverZone(zoneStack.getZoneAt(e.model.get('zoneIndex')));
        },

        /**
         * Adds mouseover styling for the passed zone.
         * @param zone
         * @private
         */
        _mouseoverZone: function(zone) {
            zone.highlightOverlay();
        },

        /**
         * Removes mouseover styling from a zone when mousing over it in side panel.
         * @param e
         * @private
         */
        _mouseoutZoneProperties: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            this._mouseoutZone(zoneStack.getZoneAt(e.model.get('zoneIndex')));
        },

        /**
         * Removes mouseover styling from the passed zone.
         * @param zone
         * @private
         */
        _mouseoutZone: function(zone) {
            zone.unHighlightOverlay();
        },

        /**
         * Creates and configures the styling for the overlay div, used for zone and location name labels.
         * @param isZone
         * @private
         */
        _buildOverlayDiv: function(isZone) {
            var div = document.createElement('div');
            div.style.fontSize = '12px';
            div.style.fontWeight = 'bold';
            div.style.borderStyle = 'none';
            div.style.borderColor = 'black';
            div.style.borderWidth = '0px';
            div.style.position = 'absolute';
            div.style.padding = '5px';
            div.style.zIndex = '10000';
            div.style.opacity = '1.0';
            // Slightly different styling to distinguish zone and location labels
            if (isZone) {
                div.style.borderRadius = '7px';
            }
            else {
                div.style.borderRadius = '25px';
            }
            div.style.letterSpacing = '1px';
            div.style.whiteSpace = 'nowrap';
            return div;
        },

        /**
         * Opens the dialog and sets various properties to be used later.
         * @param title
         * @param message
         * @param inputVal
         * @param inputMsg
         * @param toggleLabel
         * @param showBadge
         * @param showCategoryPicker
         * @param confirmFunc
         * @param cancelFunc
         * @private
         */
        _openDialog: function(title,message,inputVal,inputMsg,toggleLabel,showBadge,showCategoryPicker,confirmFunc,cancelFunc) {
            var dialog = this.querySelector('#modalDialog');
            if (!dialog) { return; }
            // Store all dialog properties so the dialog renders properly
            this._dialogTitle = title;
            this._dialogMessage = message;
            this._dialogInput = inputVal;
            this._showDialogInput = (typeof inputVal !== 'undefined' && inputVal !== null);
            this._dialogInputMsg = inputMsg || 'Enter a value';
            this._dialogToggleLabel = toggleLabel;
            this._showDialogToggle = !!toggleLabel;
            this._dialogToggle = false;
            this._showDialogBadge = !!showBadge;
            if (this._showDialogBadge) {
                this._dialogBadge = "info.png";
                if (this._loadedAlert && this._loadedAlert.template && this._loadedAlert.template.badge) {
                    this._dialogBadge = this._loadedAlert.template.badge;
                }
                // When using the badge chooser we need to be sure to resize and center the dialog
                // after the badges have loaded so the dialog renders in the correct position
                if (!this._dialogBadgeListener) {
                    this._dialogBadgeListener = document.addEventListener('voyent-alert-badge-chooser-ready',function() {
                        dialog.notifyResize();
                        dialog.center();
                    });
                }
            }
            this._dialogConfirmFunc = confirmFunc;
            this._dialogCancelFunc = cancelFunc;
            // Open the dialog
            dialog.open();
            // Ensure that our dialog is sized and positioned correctly
            if (!this._showDialogBadge) {
                setTimeout(function() {
                    dialog.notifyResize();
                    dialog.center();
                },0);
            }
            // If there's no input rendered in the dialog then focus on the dialog so we
            // can capture the user's key presses. The input will focus automatically
            if (!this._showDialogInput) {
                setTimeout(function() {
                    dialog.focus();
                },200);
            }
        },

        /**
         * Handles dialog input validation and calling the confirmation function if available.
         * @private
         */
        _confirmDialog: function() {
            //Validate the input.
            if (this._showDialogInput && (!this._dialogInput ||
                    !this._dialogInput.trim())) {
                this.fire('message-error', this._dialogInputMsg);
                return;
            }
            //We allow for passing the confirm function directly or as a string.
            if (this._dialogConfirmFunc) {
                if (typeof this._dialogConfirmFunc === 'string') { this[this._dialogConfirmFunc](); }
                else { this._dialogConfirmFunc(); }
            }
            //Close the dialog after.
            this.closeDialog(true);
        },

        /**
         * Handles closing the dialog and calling the cancel function if available.
         * @param confirmed
         * @private
         */
        closeDialog: function(confirmed) {
            confirmed = typeof confirmed === 'boolean' ? confirmed : false;

            //Only call the cancel function if this is triggered by a cancel.
            //We allow passing the confirm function directly or as a string.
            if (!confirmed && this._dialogCancelFunc) {
                if (typeof this._dialogCancelFunc === 'string') { this[this._dialogCancelFunc](); }
                else { this._dialogCancelFunc(); }
            }

            if (this.querySelector('#modalDialog')) {
                this.querySelector('#modalDialog').close();
            }
        },

        /**
         * Handles enter and escape key presses when the dialog is focused.
         * @param e
         * @private
         */
        _dialogKeyUp: function(e) {
            //Prevent the event from bubbling.
            e.stopPropagation();
            if (e.key === 'Enter') { //Enter
                this._confirmDialog();
            }
            else if (e.key === 'Escape') { //Escape
                this.closeDialog();
            }
        },

        /**
         * Opens the category picker dialog.
         * @private
         */
        _openCategorySelector: function() {
            var _this = this;
            var dialog = this.querySelector('#categoryManager');
            if (dialog) {
                dialog.open();
                this.set('_categorySearchQuery','');
                this.set('_filteredTemplateCategories',_this._templateCategories.slice(0));
                this.set('_selectedCategories',this._loadedAlert ?
                    function(categories) {
                        var selectedCategories = [];
                        for (var i=0; i<_this._templateCategories.length; i++) {
                            if (categories.indexOf(_this._templateCategories[i].name) > -1) {
                                selectedCategories.push(_this._templateCategories[i]);
                            }
                        }
                        return selectedCategories;
                    }(this._loadedAlert.template.categories) :
                    []
                );
                setTimeout(function() {
                    var categoryWrapper = document.querySelector('.category-wrapper');
                    if (categoryWrapper) {
                        categoryWrapper.scrollTop = 0;
                    }
                },0);
            }
        },

        /**
         * Closes the category picker dialog.
         */
        closeCategorySelector: function() {
            this.set('_showCategoryManager',false);
            var dialog = this.querySelector('#categoryManager');
            if (dialog) {
                dialog.close();
            }
        },

        /**
         * Confirms category selection changes made in the category picker dialog.
         * @private
         */
        _confirmCategorySelector: function() {
            this._loadedAlert.template.setCategories(this._selectedCategories.map(function(categoryObj) {
                return categoryObj.name;
            }));
            if (this._templateSavePending) {
                this.saveAlertTemplate();
                this._templateSavePending = false;
            }
            this.closeCategorySelector();
        },

        /**
         * Opens a prompt message during a save when no categories are specified for a template.
         * @private
         */
        _openUncategorizedTemplateDialog: function() {
            var dialog = this.querySelector('#uncategorizedTemplate');
            if (dialog) {
                dialog.open();
            }
        },

        /**
         * Closes the prompt message displayed during a save when no categories are specified for a template.
         * @private
         */
        _closeUncategorizedTemplateDialog: function() {
            var dialog = this.querySelector('#uncategorizedTemplate');
            if (dialog) {
                dialog.close();
            }
        },

        /**
         * Opens the category picker dialog so the user can define template categories before saving.
         * @private
         */
        _openCategorySelectorBeforeSave: function() {
            this._templateSavePending = true;
            this._closeUncategorizedTemplateDialog();
            this._openCategorySelector();
        },

        /**
         * Force the paper-dialog to modal the entire page properly regardless of stacking context
         * See https://github.com/PolymerElements/paper-dialog/issues/7
         */
        _patchOverlay: function (e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },

        /**
         * Handles displaying the zone overlap message and ensuring we don't display it too frequently.
         * @private
         */
        _displayOverlapMsg: function() {
            var currentTime = new Date().getTime();
            //Only allow displaying this message once every 5 seconds.
            if (this._displayedZoneOverlapMsgAt &&
                currentTime - this._displayedZoneOverlapMsgAt <= 5000) {
                return;
            }
            this.fire('message-error',this._OVERLAP_WITHIN_STACK_MSG);
            this._displayedZoneOverlapMsgAt = new Date().getTime();
        },

        /**
         * All components need a reference to the classes so once the map is set we'll initialize them.
         */
        _mapChanged: function(map) {
            if (map) {
                this._initializeClasses();
            }
        },

        /**
         * Generates a uid using the current time in ms and a random number
         * in the trillions (each are 13 characters separated by a dash).
         * @returns {string}
         * @private
         */
        _generateUid: function() {
            return new Date().getTime()+'-'+Math.floor(Math.random()*(9000000000000)+1000000000000);
        },

        /**
         * Prefixes a missing # character to the passed param if it is a valid string.
         * @param colour
         * @private
         */
        _formatColour: function(colour) {
            if (colour && typeof colour === 'string' && colour.charAt(0) !== '#') {
                return '#' + colour;
            }
            return colour;
        },

        /**
         * Updates the map bounds so that only the passed zone is in view and then pans the map.
         * Restricts the panning to every 500ms to avoid excessive map panning while resizing zones.
         * @param zone
         * @param forcePan
         * @private
         */
        _panToZone: function(zone, forcePan) {
            var currentTime = new Date().getTime();
            if (forcePan || !this._lastPanZoneTime || currentTime - this._lastPanZoneTime > 500) {
                var bounds = this._AlertZone.getBoundingBox(zone);
                this._map.fitBounds(bounds);
                this._map.panToBounds(bounds);
                this._lastPanZoneTime = new Date().getTime();
            }
        },

        /**
         * Notifies the polymer path for AlertTemplate properties.
         * @param propName
         * @private
         */
        _notifyPropertyPathForAlert: function(propName) {
            if (this._loadedAlert && this._loadedAlert.template) {
                this.notifyPath('_loadedAlert.template.'+propName);
            }
        },

        /**
         * Notifies the polymer path for AlertZone properties.
         * @param zone
         * @param propName
         * @private
         */
        _notifyPropertyPathForZone: function(zone,propName) {
            if (!zone || !propName) { return; }
            if (this._loadedAlert && this._loadedAlert.template && this._loadedAlert.selectedStack) {
                var stackIndex = this._loadedAlert.template.getZoneStackIndex(this._loadedAlert.selectedStack);
                var zoneIndex = this._loadedAlert.selectedStack.zones.indexOf(zone);
                if (stackIndex > -1 && zoneIndex > -1) {
                    this.notifyPath('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones.'+zoneIndex+'.'+propName);
                }
            }
        },

        /**
         * Notifies the polymer path for FallbackAlertZone properties.
         * @param propName
         * @private
         */
        _notifyPropertyPathForFallbackZone: function(propName) {
            if (this._fallbackZone) {
                this.notifyPath('_fallbackZone.'+propName);
            }
        },

        /**
         * Returns whether the current component is one of the alert editors.
         * @private
         */
        _isAnAlertEditor: function() {
            return this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' || this.nodeName === 'VOYENT-ALERT-EDITOR';
        },

        /**
         * Initialize all our custom "classes" that are required for the various components.
         * @private
         */
        _initializeClasses: function() {
            var _outer = this;
            /**
             * Common code for inheriting a parent's prototype on the child's.
             * @param child
             * @param parent
             * @private
             */
            this._inheritPrototype = function(child,parent) {
                var parentPrototypeClone = Object.create(parent.prototype);
                parentPrototypeClone.constructor = child;
                child.prototype = parentPrototypeClone;
            };
            /**
             * A class that represents an alert template, both the drawn map entity and the json.
             * @param id - The unique identifier.
             * @param parentId - The parent template id, only relevant for child templates.
             * @param alertFamilyId - The alert family id, only relevant for child templates.
             * @param name - The user-defined name.
             * @param badge - The user chosen alert badge icon.
             * @param marker - The associated map marker for the entire template, centered between the various stacks.
             * @param zoneStacks - A list of _AlertZoneStack objects, the list of zone stacks belonging with the template.
             * @param state - The current state of the alert, only relevant for child templates.
             * @param savePosition - Whether the position of the template should be stored in the json.
             * @param schedule - The schedule details, only relevant for child templates.
             * @param categories - Zero or more categories that this template belongs to.
             * @private
             */
            this._AlertTemplate = function(id,parentId,alertFamilyId,name,badge,marker,zoneStacks,state,savePosition,schedule,categories) {
                this.setId(id || null);
                this.setParentId(parentId || null);
                this.setAlertFamilyId(alertFamilyId || null);
                this.setName(name || 'Unnamed');
                this.setBadge(badge || 'info.png');
                this.setMarker(marker || null);
                this.setZoneStacks(zoneStacks && zoneStacks.length ? zoneStacks : []);
                this.setState(state || null);
                this.setSavePosition(!!savePosition);
                this.setIsSampleTemplate(categories && categories.indexOf('Sample') > -1);
                this.setSchedule(schedule);
                this.setCategories(categories || []);
            };
            /**
             * Used to calculate the bounds of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateBoundsFromJSON = function(json) {
                var geometries = json.geo.geometries;
                var coordinates, bounds = new google.maps.LatLngBounds();
                for (var i=0; i<geometries.length; i++) {
                    coordinates = geometries[i].coordinates[0];
                    for (var j=0; j<coordinates.length; j++) {
                        bounds.extend(new google.maps.LatLng(coordinates[j][1],coordinates[j][0]));
                    }
                }
                return bounds;
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromJSON = function(json) {
                return this.calculateBoundsFromJSON(json).getCenter();
            };
            /**
             * Used to calculate the rectangular paths around the provided json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateBoundingPathsFromJSON = function(json) {
                var bounds = this.calculateBoundsFromJSON(json);
                var ne = bounds.getNorthEast();
                var sw = bounds.getSouthWest();
                return [ne,new google.maps.LatLng(sw.lat(),ne.lng()),sw,new google.maps.LatLng(ne.lat(),sw.lng()),ne];
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed paths array.
             * @param paths - An array of arrays of LatLng objects that define the zone.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromPaths = function(paths) {
                var bounds = new google.maps.LatLngBounds();
                for (var i=0; i<paths.length; i++) {
                    var innerPath = paths.getAt ? paths.getAt(i) : paths[i]; // MVCArray or []
                    for (var j=0; j<innerPath.length; j++) {
                        bounds.extend(paths.getAt ? paths.getAt(i).getAt(j) : paths[i][j]); // MVCArray or []
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Calculate the shape overlay paths using the passed coordinates arrays.
             * @param coordinates
             * @static
             */
            this._AlertTemplate.calculatePathsFromCoordinates = function(coordinates) {
                var latLng, paths = [], path;
                for (var i=0; i<coordinates.length; i++) {
                    path = [];
                    //In GeoJSON we must complete the shape by duplicating the coordinate at index 0 at the last index
                    //but Google Maps API states: "Paths are closed automatically; do not repeat the first vertex of
                    //the path as the last vertex.". So we'll exclude the last coordinate when converting to paths.
                    for (var j=0; j<coordinates[i].length-1; j++) {
                        latLng = new google.maps.LatLng(coordinates[i][j][1],coordinates[i][j][0]);
                        path.push(latLng);
                    }
                    paths.push(path);
                }
                return paths;
            };
            /**
             * Calculate the GeoJSON coordinates using the passed shape overlay paths.
             * @param paths
             * @param func - The function to be executed after the inner path has being modified.
             * @static
             */
            this._AlertTemplate.calculateCoordinatesFromPaths = function(paths,func) {
                var latLng, outer = [], inner;
                for (var i=0; i<paths.length; i++) {
                    inner = [];
                    var innerPath = paths.getAt ? paths.getAt(i) : paths[i]; // MVCArray or []
                    for (var j=0; j<innerPath.length; j++) {
                        //Retrieve each coordinate from the shape and save it.
                        latLng = innerPath.getAt ? innerPath.getAt(j) : innerPath[j]; // MVCArray or []
                        inner.push(latLng.lng ? [latLng.lng(), latLng.lat()] : latLng); // LatLng or [lng,lat]
                        if (func) {
                            func(latLng)
                        }
                    }
                    //In GeoJSON we must copy the first coordinate to the last one
                    //to complete the shape. Do this for each coordinate array.
                    inner.push(inner[0]);
                    outer.push(inner);
                }
                return outer;
            };
            this._AlertTemplate.calculatePathsFromCircleProperties = function(center, radius) {
                var latLng, coordinates=[];
                for (var k=0; k<_outer._NUM_CIRCULAR_POLY_SIDES; k++) {
                    //Calculate and save the next coordinate.
                    latLng = google.maps.geometry.spherical.computeOffset(
                        center, radius, _outer._CIRCULAR_POLY_DEGREE_STEP * k
                    );
                    coordinates.push(latLng);
                }
                return [coordinates];
            };
            /**
             * A static function that returns the default JSON structure.
             * @static
             */
            this._AlertTemplate.getJSONStructure = function () {
                return {
                    "name": "Unnamed",
                    "badge": "info.png",
                    "geo": {
                        "type": "GeometryCollection",
                        "geometries": []
                    },
                    "properties": {}
                };
            };
            /**
             * _AlertTemplate prototype (instance) functions.
             */
            this._AlertTemplate.prototype = {
                constructor: _outer._AlertTemplate,
                /**
                 * Sets the id and notifies the polymer path.
                 * @param id
                 */
                setId: function (id) {
                    this.id = id;
                    _outer._notifyPropertyPathForAlert('id');
                },
                /**
                 * Sets the parentId and notifies the polymer path.
                 * @param parentId
                 */
                setParentId: function(parentId) {
                    this.parentId = parentId;
                    _outer._notifyPropertyPathForAlert('parentId');
                },
                /**
                 * Sets the alertFamilyId and notifies the polymer path.
                 * @param alertFamilyId
                 */
                setAlertFamilyId: function(alertFamilyId) {
                    this.alertFamilyId = alertFamilyId;
                    _outer._notifyPropertyPathForAlert('alertFamilyId');
                },
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    _outer._notifyPropertyPathForAlert('name');
                },
                /**
                 * Sets the alert badge icon and notifies the polymer path.
                 * @param badge
                 */
                setBadge: function(badge) {
                    this.badge = badge;
                    _outer._notifyPropertyPathForAlert('badge');
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    //When we create a new AlertTemplate with only one stack we don't need a marker for
                    //the template since the stack has it's own so always check if we were passed one.
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Sets the zone stacks and triggers required processing.
                 * @param zoneStacks
                 */
                setZoneStacks: function (zoneStacks) {
                    this.zoneStacks = [];
                    for (var i=0; i<zoneStacks.length; i++) {
                        this.addZoneStack(zoneStacks[i]);
                    }
                },
                /**
                 * Sets the alert state.
                 * @param state
                 */
                setState: function(state) {
                    this.state = state;
                },
                /**
                 * Sets whether we should save the template position.
                 * @param savePosition
                 */
                setSavePosition: function(savePosition) {
                    this.savePosition = savePosition;
                },
                /**
                 * Sets whether this is a sample template.
                 * @param isSampleTemplate
                 */
                setIsSampleTemplate: function(isSampleTemplate) {
                    this.isSampleTemplate = isSampleTemplate;
                },
                /**
                 * Sets the schedule for the alert.
                 * @param schedule
                 */
                setSchedule: function(schedule) {
                    this.schedule = schedule;
                },
               /**
                * Returns a boolean indicating whether the alert has a schedule.
                */
                hasSchedule: function() {
                    return this.schedule;
                },
                /**
                 * Sets the categories that this alert belongs to.
                 * @param categories
                 */
                setCategories: function(categories) {
                    this.categories = categories;
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.fire('voyent-alert-categories-changed', {"categories":this.categories});
                    }
                },
                /**
                 * Add the passed zone stack.
                 * @param zoneStack
                 */
                addZoneStack: function (zoneStack) {
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.push('_loadedAlert.template.zoneStacks',zoneStack);
                    }
                    else {
                        this.zoneStacks.push(zoneStack);
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Remove the passed zone stack.
                 * @param zoneStack
                 */
                removeZoneStack: function (zoneStack) {
                    zoneStack.removeFromMap();
                    var zoneStackIndex = this.getZoneStackIndex(zoneStack);
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.splice('_loadedAlert.template.zoneStacks',zoneStackIndex,1);
                        if (_outer._loadedAlert.selectedStack === zoneStack) {
                            _outer.set('_loadedAlert.selectedStack',null);
                        }
                    }
                    else {
                        this.zoneStacks.splice(zoneStackIndex,1);
                    }
                    this.updateJSONAndCentroid();
                    if (this.zoneStacks.length === 1) {
                        this.marker.setMap(null);
                        this.setMarker(null);
                    }
                },
                /**
                 * Returns the zone stack at the specified index.
                 * @param index
                 */
                getZoneStackAt: function (index) {
                    return this.zoneStacks[index];
                },
                /**
                 * Returns the index of the passed zone stack.
                 * @param zoneStack
                 */
                getZoneStackIndex: function (zoneStack) {
                    return this.zoneStacks.indexOf(zoneStack);
                },
                /**
                 * Deactivates all zone overlays for this stack.
                 */
                deactivateZoneStackOverlays: function() {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].deactivateZoneOverlays();
                    }
                },
                /**
                 * Triggers reinitialization of edit listeners for each polygonal zone stack.
                 */
                initializePolygonStackPathListeners: function() {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        if (!this.zoneStacks[i].zones[0].isCircle) {
                            this.zoneStacks[i].initializePolygonPathListeners();
                        }
                    }
                },
                /**
                 * Updates the json to reflect the current state of the template. Since each stack of zones maintains
                 * their own json we update their json and then simply merge the geometries and properties section from
                 * each stack into one.
                 */
                updateJSON: function () {
                    var json = this.constructor.getJSONStructure();
                    //Add template-level properties.
                    json.name = this.name;
                    json.badge = 'info.png';
                    if (this.badge) {
                        json.badge = this.badge;
                    }
                    if (this.parentId) {
                        json.properties.parentAlertId = this.parentId;
                        if (this.alertFamilyId) {
                            json.properties.alertFamilyId = this.alertFamilyId;
                        }
                        if (this.state) {
                            json.state = this.state;
                        }
                        if (this.schedule) {
                            json.schedule = this.schedule;
                        }
                        if (_outer._alertDirection || _outer._alertDirection === 0) {
                            json.properties.direction = Number(_outer._alertDirection);
                        }
                        if (_outer._alertSpeed) {
                            json.properties.speed = Number(_outer._alertSpeed);
                            json.properties.speedUnit = _outer._alertSpeedUnit || 'kph';
                        }
                    }
                    else {
                        json.categories = this.categories;
                    }
                    //Add fallback zone, we'll always add it the properties.
                    json.properties[_outer._FALLBACK_ZONE_ID] = {
                        "enabled": false
                    };
                    if (_outer._fallbackZone) {
                        json.properties[_outer._FALLBACK_ZONE_ID] = {
                            "enabled":_outer._fallbackZone.enabled,
                            "name": _outer._fallbackZone.name
                            /*"opacity": _outer._fallbackZone.opacity,*/ // Fixed opacity
                            /*"colour": _outer._fallbackZone.colour*/ // Fixed colour
                        };
                        if (_outer._fallbackZone.messageTemplate) {
                            json.properties[_outer._FALLBACK_ZONE_ID].messageTemplate = _outer._fallbackZone.messageTemplate;
                        }
                        if (_outer._fallbackZone.notificationFilter) {
                            json.properties[_outer._FALLBACK_ZONE_ID].notificationFilter = _outer._fallbackZone.notificationFilter;
                        }
                        if (_outer._fallbackZone.acknowledgement) {
                            json.properties[_outer._FALLBACK_ZONE_ID].acknowledgement = _outer._fallbackZone.acknowledgement;
                        }
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        //First update the json for the stack.
                        this.zoneStacks[i].updateJSON();
                        //Merge the geometries arrays.
                        json.geo.geometries = json.geo.geometries.concat(this.zoneStacks[i].json.geo.geometries);
                        //Merge the properties objects.
                        for (var zoneId in this.zoneStacks[i].json.properties) {
                            if (this.zoneStacks[i].json.properties.hasOwnProperty(zoneId)) {
                                json.properties[zoneId] = this.zoneStacks[i].json.properties[zoneId];
                            }
                        }
                    }
                    //Check if this is a "fixed location" template and store it.
                    delete json.properties.center;
                    if (!this.parentId && this.savePosition) {
                        if (this.marker) {
                            json.properties.center = this.marker.getPosition().toJSON();
                        }
                        else if (this.zoneStacks.length && this.zoneStacks[0].marker) {
                            json.properties.center = this.zoneStacks[0].marker.getPosition().toJSON();
                        }
                    }
                    //If we have no geometries defined then delete the geo property entirely.
                    if (!json.geo.geometries.length) { delete json.geo; }

                    this.json = json;
                },
                /**
                 * Updates the position of the template marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    if (this.marker) {
                        this.marker.setPosition(
                            this.constructor.calculateCentroidFromJSON(this.json)
                        );
                    }
                },
                /**
                 * Removes the template from the map.
                 */
                removeFromMap: function() {
                    if (this.marker) {
                        this.marker.setMap(null);
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].removeFromMap();
                    }
                },
                /**
                 * Initializes marker listeners for the alert.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    // As of Feb 6, 2019 the marker is invisible so we won't setup these listeners
                    /*if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the template marker so we'll add a flag to ignore those events.
                    google.maps.event.addListener(this.marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeStackPositions();
                    });
                    google.maps.event.addListener(this.marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                        _this.initializePolygonStackPathListeners();
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(this.marker, 'drag', function () {
                        _this.moveStacksRelativeToPosition();
                        _this.updateJSON();
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                        _this.manageAlertBoundary(true);
                    });
                    google.maps.event.addListener(this.marker, 'dragend', function () {
                        _this.manageAlertBoundary(false);
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(this.marker, 'click', function () {
                        //Toggle all the accordion panes closed and de-select all stacks.
                        _outer._toggleProperties(null);
                        _outer.set('_loadedAlert.selectedStack',null);
                    });
                    //Add mouseover and mouseout listeners to highlight the alert boundary for multi-stack alerts.
                    google.maps.event.addListener(this.marker, 'mouseover', function () {
                        _this.manageAlertBoundary(true);
                    });
                    google.maps.event.addListener(this.marker, 'mouseout', function () {
                        _this.manageAlertBoundary(false);
                    });*/
                },
                /**
                 * Calculates the current zone positions (distance and bearing)
                 * in each stack relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeStackPositions: function(latLng) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].calculateRelativeZonePositions(position);
                    }
                },
                /**
                 * Moves zone stacks from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 */
                moveStacksRelativeToPosition: function (latLng) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].moveZonesRelativeToPosition(position);
                    }
                },
                /**
                 * Handles creating, positioning and toggling the visibility of the alert boundary
                 * which is displayed on alert marker mouseover for multi-stack alerts.
                 * @param visible
                 */
                manageAlertBoundary: function(visible) {
                    if (visible) {
                        this.updateJSON();
                        if (!this._alertBoundary) {
                            this._alertBoundary = new google.maps.Polyline({
                                path: _outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json),
                                map: _outer._map,
                                strokeWeight: 1
                            });
                        }
                        else {
                            this._alertBoundary.setMap(_outer._map);
                            this._alertBoundary.setPath(_outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json));
                        }
                    }
                    else if (this._alertBoundary) {
                        this._alertBoundary.setMap(null);
                    }
                }
            };
            Object.seal(this._AlertTemplate);

            /**
             * A class that represents an alert template proximity zone stack.
             * @param id - The unique id that identifies the zone stack, if one is not provided it will be generated.
             * @param marker - The associated map marker for the stack.
             * @param zones - A list of _AlertZone objects, the list of zones belonging with the stack.
             * @private
             */
            this._AlertZoneStack = function (id,marker,zones) {
                this.id = id && typeof id === 'string' ? id : _outer._generateUid();
                this.setMarker(marker || null);
                this.setZones(zones && zones.length ? zones : []);
                this.updateJSON();
            };
            /**
             * Returns the colour of the zone at the passed index, assuming
             * a default order of `red`, `yellow`, `blue`, `green`.
             * @param index
             * @static
             */
            this._AlertZoneStack.getZoneColourAtIndex = function(index) {
                if (this._isZoneAtIndexColour(index,'red')) {
                    return '#FF0000'
                }
                else if (this._isZoneAtIndexColour(index,'orange')) {
                    return '#FFB000';
                }
                else if (this._isZoneAtIndexColour(index,'yellow')) {
                    return '#FFFF00';
                }
                else if (this._isZoneAtIndexColour(index,'green')) {
                    return '#00FF00';
                }
                else if (this._isZoneAtIndexColour(index,'blue')) {
                    return '#0000FF';
                }
                else if (this._isZoneAtIndexColour(index,'cyan')) {
                    return '#00EEFF';
                }
                else if (this._isZoneAtIndexColour(index,'pink')) {
                    return '#FF00DD';
                }
            };
            /**
             * Determines if the zone at the index is the colour.
             * @param index - The index of the zone.
             * @param colour - The colour to check.
             * @static
             * @private
             */
            this._AlertZoneStack._isZoneAtIndexColour = function(index,colour) {
                var zoneNumber = index+1;
                //Only generate the minimum amount of numbers in the sequence that we need to determine a match.
                var count = Math.ceil((zoneNumber)/7);
                //Determine the starting point for our sequence.
                var sequence = [];
                if (colour === 'red') { sequence.push(1); }
                else if (colour === 'orange') { sequence.push(2); }
                else if (colour === 'yellow') { sequence.push(3); }
                else if (colour === 'green') { sequence.push(4); }
                else if (colour === 'blue') { sequence.push(5); }
                else if (colour === 'cyan') { sequence.push(6); }
                else { sequence.push(7); }
                //Generate the sequence and return whether we have a match.
                for (var i=1; i<=count; i++) {
                    sequence.push(sequence[sequence.length-1]+7);
                }
                return sequence.indexOf(zoneNumber) > -1;
            };
            /**
             * _AlertZoneStack prototype (instance) functions.
             */
            this._AlertZoneStack.prototype = {
                constructor: _outer._AlertZoneStack,
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Adds the passed zones to the stack.
                 * @param zones
                 */
                setZones: function (zones) {
                    this.zones = [];
                    for (var i=0; i<zones.length; i++) {
                        this.addZone(zones[i]);
                    }
                },
                /**
                 * Returns the zone at the specified index.
                 * @param index
                 */
                getZoneAt: function (index) {
                    return this.zones[index];
                },
                /**
                 * Returns the index of the passed zone.
                 * @param zone
                 */
                getZoneIndex: function (zone) {
                    return this.zones.indexOf(zone);
                },
                /**
                 * Returns the zone with the specified zoneId.
                 * @param zoneId
                 */
                getZoneById: function (zoneId) {
                    for (var i=0; i<this.zones.length; i++) {
                        if (this.zones[i].id === zoneId) {
                            return this.zones[i];
                        }
                    }
                    return null;
                },
                /**
                 * Returns the largest zone.
                 */
                getLargestZone: function() {
                    return this.getZoneAt(this.zones.length-1);
                },
                /**
                 * Deactivates all zones.
                 */
                deactivateZoneOverlays: function () {
                    for (var i = 0; i < this.zones.length; i++) {
                        this.zones[i].setActive(false);
                    }
                },
                /**
                 * Add the passed zone and notifies the polymer path.
                 * @param zone
                 */
                addZone: function (zone) {
                    var pushed = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.push('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',zone);
                            pushed = true;
                        }
                    }
                    if (!pushed) {
                        this.zones.push(zone);
                    }
                    // Set the zone colour based on the zone position
                    if (!zone.colour) {
                        zone.setColour(this.constructor.getZoneColourAtIndex(this.zones.length-1));
                    }
                    this.updateJSONAndCentroid();
                    this._punchOutShape(this.zones.length-1);
                    this._setupZoneListeners(zone);
                },
                /**
                 * Inserts the passed zone at the passed index and notifies the polymer path.
                 * @param zone
                 * @param index
                 */
                insertZone: function (zone, index) {
                    var spliced = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.splice('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',index,0,zone);
                            spliced = true;
                        }
                    }
                    if (!spliced) {
                        this.zones.splice(index,0,zone);
                    }
                    // Set the zone colour based on the number of zones
                    if (!zone.colour) {
                        zone.setColour(this.constructor.getZoneColourAtIndex(this.zones.length-1));
                    }
                    this.updateJSONAndCentroid();
                    // Punch out our new shape with the next closest inner shape
                    this._punchOutShape(index);
                    // Punch out the next closest outer shape
                    this._punchOutShape(index+1);
                    this._setupZoneListeners(zone);
                },
                /**
                 * Remove the passed zone and notifies the polymer path.
                 * @param zone
                 */
                removeZone: function (zone) {
                    zone.removeFromMap();
                    var zoneIndex = this.getZoneIndex(zone);
                    var spliced = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.splice('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',zoneIndex,1);
                            spliced = true;
                        }
                    }
                    if (!spliced) {
                        this.zones.splice(zoneIndex,1);
                    }
                    //Update the JSON so we have a fresh set of coordinates for the punch out logic.
                    this.updateJSON();
                    //The zoneIndex actually points to the closest outer zone now since the array was just spliced.
                    var closestOuterZone = this.zones[zoneIndex];
                    if (zoneIndex === 0) {
                        if (closestOuterZone) {
                            //The inner-most zone was removed so we must fill in the hole with the
                            //closest outer zone. To do this we will take the outer boundary of the
                            //zone and set it as the only path, producing a geometry with no holes.
                            closestOuterZone.setPaths(closestOuterZone.shapeOverlay.getPaths().getAt(0));
                        }
                    }
                    else {
                        //A middle or outer zone was removed so just re-punch out the closest outer zone if there is one.
                        if (closestOuterZone) {
                            this._punchOutShape(zoneIndex);
                        }
                    }
                    //Refresh the JSON again and update the centroid position in case the outer zone was removed.
                    this.updateJSONAndCentroid();
                },
                /**
                 * Updates the json to reflect the current state of the stack. Also updates
                 * the northernCoordinate which adjusts the position of the zone name overlays.
                 */
                updateJSON: function () {
                    var zone, northernCoordinate, overlay,
                        json = _outer._AlertTemplate.getJSONStructure();

                    for (var i=0; i<this.zones.length; i++) {
                        zone = this.zones[i];
                        northernCoordinate = [null, -100];
                        overlay = zone.shapeOverlay;
                        json.properties[zone.id] = {
                            "name": zone.name,
                            "stackId": this.id,
                            "shape": zone.isCircle ? 'circle' : 'polygon',
                            /*"opacity": zone.opacity,*/ // Fixed opacity
                            "colour": zone.colour,
                            "innermost": i===0
                        };
                        if (zone.messageTemplate) {
                            json.properties[zone.id].messageTemplate = zone.messageTemplate;
                        }
                        if (zone.notificationFilter) {
                            json.properties[zone.id].notificationFilter = zone.notificationFilter;
                        }
                        if (zone.acknowledgement) {
                            json.properties[zone.id].acknowledgement = zone.acknowledgement;
                        }
                        json.geo.geometries.push({
                            "id": zone.id,
                            "stackId": this.id,
                            "type": "Polygon",
                            "coordinates": [[]]
                        });
                        json.geo.geometries[i].coordinates =
                            _outer._AlertTemplate.calculateCoordinatesFromPaths(overlay.getPaths(),function(latLng) {
                                //Look for the northern most point of the polygon so we know
                                //where to render the Proximity Zone overlay label.
                                if (latLng.lat() > northernCoordinate[1]) {
                                    northernCoordinate = [latLng.lng(), latLng.lat()];
                                }
                            });
                        zone.setNorthernCoordinate(northernCoordinate);
                    }
                    this.json = json;
                },
                /**
                 * Updates the position of the stack marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    this.marker.setPosition(
                        _outer._AlertTemplate.calculateCentroidFromJSON(this.json)
                    );
                },
                /**
                 * Loops the zone coordinates in the JSON and triggers punching out the smaller
                 * from the larger, starting from the largest and excluding the smallest.
                 */
                punchOutShapes: function() {
                    for (var i=this.json.geo.geometries.length-1; i>0; i--) {
                        this._punchOutShape(i);
                    }
                },
                /**
                 * Punches out the zone at the passed index with it's closest smallest zone.
                 * @param index - The index of the zone to be punched out.
                 * @private
                 */
                _punchOutShape: function(index) {
                    //Don't proceed if the index of the smallest zone (0) is passed.
                    if (!index) { return; }
                    var doughnut = turf.difference({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index].coordinates[0]]
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index-1].coordinates[0]]
                            }
                        }
                    );
                    var coordinates = doughnut.geometry.coordinates;
                    //Calculate and set the new punched out paths so the changes get reflected on the map immediately.
                    var punchedOutPaths = _outer._AlertTemplate.calculatePathsFromCoordinates(coordinates);
                    this.zones[index].setPaths(punchedOutPaths);
                    //Re-initialize the polygon path listeners for the edited zone.
                    this.initializePolygonPathListeners(this.zones[index]);
                    //Replace the old json coordinates with our new punched out zone.
                    this.json.geo.geometries[index].coordinates = coordinates;
                },
                /**
                 * Calculates the current zone positions (distance and bearing) relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeZonePositions: function(latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions=[];
                        var paths = this.zones[i].shapeOverlay.getPaths(), innerPositions;
                        for (var j=0; j<paths.length; j++) {
                            innerPositions = [];
                            for (var k=0; k<paths.getAt(j).length; k++) {
                                //Calculate the distance and bearing from the position to the each vertex.
                                innerPositions.push({
                                    "distance":google.maps.geometry.spherical.computeDistanceBetween(latLng,paths.getAt(j).getAt(k)),
                                    "bearing":google.maps.geometry.spherical.computeHeading(latLng,paths.getAt(j).getAt(k))
                                });
                            }
                            positions.push(innerPositions);
                        }
                        this.zones[i]._relativePositions = positions;
                    }
                },
                /**
                 * Moves zones from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 */
                moveZonesRelativeToPosition: function (latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions = this.zones[i]._relativePositions, paths = [], path, newCenter;
                        for (var j=0; j<positions.length; j++) {
                            path = [];
                            for (var k=0; k<positions[j].length; k++) {
                                path.push(google.maps.geometry.spherical.computeOffset(
                                    latLng,
                                    positions[j][k].distance,
                                    positions[j][k].bearing)
                                );
                            }
                            paths.push(path);
                        }
                        this.zones[i].setPaths(paths);
                        //Update the centroid.
                        this.marker.setPosition((
                            newCenter || _outer._AlertTemplate.calculateCentroidFromPaths(this.zones[i].shapeOverlay.getPaths())
                        ));
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Removes the stack of zones from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    for (var i=0; i<this.zones.length; i++) {
                        this.zones[i].removeFromMap();
                    }
                },
                /**
                 * Initializes marker listeners for the zone stack.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the stack marker so we'll add a flag to ignore those events.
                    var marker = this.marker;
                    google.maps.event.addListener(marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeZonePositions(_this.marker.getPosition());
                        _outer._dragStartPosition = _this.marker.getPosition();
                    });
                    google.maps.event.addListener(marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        //Re-initialize the polygon path listeners for all zones.
                        _this.initializePolygonPathListeners();
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(marker, 'drag', function () {
                        _this.moveZonesRelativeToPosition(_this.marker.getPosition());
                        _outer._loadedAlert.template.updateJSONAndCentroid();
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                        //_this.manageStackBoundary(true);
                    });
                    /*google.maps.event.addListener(marker, 'dragend', function () {
                        _this.manageStackBoundary(false);
                    });*/
                    //Add click listener to marker.
                    google.maps.event.addListener(marker, 'click', function () {
                        //Toggle all the accordion panes closed.
                        _outer._toggleProperties(null);
                        _outer.set('_loadedAlert.selectedStack',_this);
                    });
                    /*//Add mouseover and mouseout listeners to highlight the stack boundary.
                    google.maps.event.addListener(marker, 'mouseover', function () {
                        _this.manageStackBoundary(true);
                    });
                    google.maps.event.addListener(marker, 'mouseout', function () {
                        _this.manageStackBoundary(false);
                    });*/
                },
                /**
                 * Initializes zone listeners.
                 * @param zone
                 * @private
                 */
                _setupZoneListeners: function (zone) {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    var overlay = zone.shapeOverlay;
                    //Add click listener to shapes.
                    google.maps.event.addListener(overlay, 'click', function () {
                        //If they click a zone for the currently active stack then toggle the accordion.
                        if (_outer._loadedAlert.selectedStack &&
                            _outer._loadedAlert.selectedStack === _this) {
                            _outer._toggleProperties(zone);
                        }
                        else {
                            //Toggle the accordion for the previously selected stack.
                            _outer._toggleProperties(null);
                            //Load the selected stack and toggle the selected zone.
                            _outer.set('_loadedAlert.selectedStack',_this);
                            _outer._toggleProperties(zone);
                        }
                    });
                    // Adjust zone styling when hovering over zone with mouse
                    google.maps.event.addListener(overlay, 'mouseover', function() {
                        _outer._mouseoverZone(zone);
                    });
                    google.maps.event.addListener(overlay, 'mouseout', function() {
                        _outer._mouseoutZone(zone);
                    });
                    //Store the previous vertex position when clicking
                    //on an existing vertex in case we need to revert.
                    if (!zone.isCircle) {
                        google.maps.event.addListener(overlay, 'mousedown', function(e) {
                            if (typeof e.vertex !== 'undefined') {
                                _outer._previousVertexPosition = e.latLng;
                            }
                        });
                        //Handle polygon edits.
                        _this.initializePolygonPathListeners(zone);
                    }
                },
                /**
                 * Initializes polygon edit listeners. When that paths of the overlay change significantly, such as when
                 * punching the shapes out, we need to call this function again to re-initialize the listeners.
                 * @param zone - The optional zone for which listeners will be initialized. If this is not provided then
                 *               all zones for the stack will be processed.
                 */
                initializePolygonPathListeners: function(zone) {
                    if (zone) {
                        if (!zone.isCircle) {
                            this._setupPolygonPathListeners(zone);
                        }
                    }
                    else {
                        for (var i=0; i<this.zones.length; i++) {
                            if (!this.zones[i].isCircle) {
                                this._setupPolygonPathListeners(this.zones[i]);
                            }
                        }
                    }
                },
                /**
                 * Processes individual zones sent from `initializePolygonPathListeners`.
                 * @param zone
                 * @private
                 */
                _setupPolygonPathListeners: function(zone) {
                    var _this = this;
                    //Just to be sure we don't duplicate listeners we will always clear existing ones first.
                    for (var i=0; i<zone.shapeOverlay.getPaths().length; i++) {
                        (function(pathIndex) {
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'insert_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'insert_at', function (vertexIndex) {
                                //Async so the vertex gets inserted before we operate on it.
                                setTimeout(function() {
                                    _this._polyAtListener('insert_at',zone,pathIndex,vertexIndex);
                                },0);
                            });
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'set_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'set_at', function (vertexIndex) {
                                if (_outer._revertedVertex) {
                                    _outer._revertedVertex = false;
                                    return;
                                }
                                _this._polyAtListener('set_at',zone,pathIndex,vertexIndex);
                            });
                        })(i);
                    }
                },
                /**
                 * Checks if the vertex change is valid when a polygonal zone is edited.
                 * @param eventName - The name of the event that is calling this function. One of `insert_at` or `set_at`.
                 * @param zone - The zone that the event fired on.
                 * @param pathIndex - The path that the event fired on.
                 * @param vertexIndex - The vertex that the event fired on.
                 * @private
                 */
                _polyAtListener: function (eventName,zone,pathIndex,vertexIndex) {
                    var errorMsg = null;
                    var zoneIndex = _outer._loadedAlert.selectedStack.getZoneIndex(zone);
                    var largestZone = _outer._loadedAlert.selectedStack.getLargestZone();
                    //Check if the polygon intersects itself. To do this we will use the turf library but we
                    //must first extract the new zone coordinates so they can be interpreted by turf as GeoJSON.
                    var newZoneCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(zone.shapeOverlay.getPaths());
                    var kinks = turf.kinks({
                        "type": "Feature",
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": newZoneCoordinates
                        }
                    });
                    if (kinks.features.length) {
                        errorMsg = 'The zone cannot self-intersect';
                    }
                    if (!errorMsg && _outer._loadedAlert.selectedStack.zones.length > 1) {
                        var vertex = zone.shapeOverlay.getPaths().getAt(pathIndex).getAt(vertexIndex);
                        //Check that the vertex is within our zone boundary. This handles the case
                        //where they drag an inner zone vertex past the boundaries of the stack.
                        if (zoneIndex !== _outer._loadedAlert.selectedStack.getZoneIndex(largestZone)) {
                            if (!google.maps.geometry.poly.containsLocation(vertex,new google.maps.Polygon({
                                    paths: [largestZone.shapeOverlay.getPaths().getAt(pathIndex)]}))) {
                                errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                            }
                        }
                        else {
                            //Check that the outer-most zone is touching it's closest inner zone. This
                            //handles the case where they drag a vertex on the outer-most zone to the
                            //opposite side of the shape, detaching it from the stack.
                            var outerBoundaryPolygonCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(
                                zone.shapeOverlay.getPaths()
                            );
                            var intersects = turf.intersect({
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    //The zone isn't punched out yet which means the previous inner zone boundary
                                    //will exist as a filled polygon so make sure we only select the edited zone.
                                    "coordinates": [outerBoundaryPolygonCoordinates[0]]
                                }
                            },
                            {
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    "coordinates": _outer._AlertTemplate.calculateCoordinatesFromPaths(
                                        _outer._loadedAlert.selectedStack.getZoneAt(zoneIndex-1).shapeOverlay.getPaths()
                                    )
                                }
                            });
                            if (!intersects.geometry) {
                                errorMsg = 'The zone cannot be detached from the stack';
                            }
                        }
                        //Check if the vertex overlaps zones beyond the adjacent zone on either side. Overlapping the
                        //adjacent zone is OK because we will just adjust the shape of that zone to accommodate.
                        if (!errorMsg && _outer._loadedAlert.selectedStack.zones.length > 2) {
                            var i;
                            //Test zones on the outer side of the edited zone, starting with two zones away.
                            for (i=zoneIndex+2; i<_outer._loadedAlert.selectedStack.zones.length; i++) {
                                if (google.maps.geometry.poly.containsLocation(
                                        vertex, _outer._loadedAlert.selectedStack.getZoneAt(i).shapeOverlay)) {
                                    errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                                    break;
                                }
                            }
                            if (!errorMsg) {
                                //Test zones on the inner side of the edited zone, starting with two zones away.
                                for (i=zoneIndex-2; i>=0; i--) {
                                    if (google.maps.geometry.poly.containsLocation(
                                        vertex, _outer._loadedAlert.selectedStack.getZoneAt(i).shapeOverlay)) {
                                        errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //Revert the position if there was a problem and display a message to the user.
                    if (errorMsg) {
                        if (eventName === 'set_at') {
                            _outer._revertedVertex = true;
                            zone.shapeOverlay.getPaths().getAt(pathIndex).setAt(vertexIndex, _outer._previousVertexPosition);
                        }
                        else { //insert_at
                            zone.shapeOverlay.getPaths().getAt(pathIndex).removeAt(vertexIndex);
                        }
                        _outer.fire('message-error',errorMsg);
                        return;
                    }
                    if (pathIndex > 0) {
                        //The inner boundary of a zone was pulled inwards or outwards so we must adjust the shape inside
                        //of it to fill the gap. To do this we will take the inner boundary of the adjusted shape and set
                        //it as the outer boundary of the inner shape. We must clone the boundary array so the two overlays
                        //will not be linked by reference.
                        var pathClone = [];
                        for (var j=0; j<zone.shapeOverlay.getPaths().getAt(pathIndex).length; j++) {
                            pathClone.push(zone.shapeOverlay.getPaths().getAt(pathIndex).getAt(j));
                        }
                        var editedZone = _outer._loadedAlert.selectedStack.getZoneAt(zoneIndex-1);
                        editedZone.setPaths(new google.maps.MVCArray(pathClone));
                        //Re-initialize the polygon path listeners for the edited zone.
                        _outer._loadedAlert.selectedStack.initializePolygonPathListeners(editedZone);
                    }
                    //Update the stack JSON and adjust the centroid position.
                    this.updateJSONAndCentroid();
                    //Always re-punch out the shapes. This will handle cases like filling
                    //in gaps when the outer boundary of an inner zone is pulled inwards.
                    this.punchOutShapes();
                    //Update the centroid for the template.
                    _outer._loadedAlert.template.updateJSONAndCentroid();
                    if (_outer._fallbackZone) {
                        _outer._fallbackZone.punchOutOverlay();
                    }
                    //Quickly toggle the overlay to fix a couple bugs with correctly displaying the polygons:
                    //1) Dragging a multi-zone polygon stack after editing will leave a line
                    //   where the edited vertex connects to its neighbouring vertices.
                    //2) Editing a polygon after resizing will leave some vertices behind.
                    zone.shapeOverlay.setMap(null);
                    setTimeout(function() {
                        zone.shapeOverlay.setMap(_outer._map);
                    },0);
                },
                /**
                 * Handles creating, positioning and toggling the visibility of the
                 * zone stack boundary which is displayed on stack marker mouseover.
                 * @param visible
                 */
                manageStackBoundary: function(visible) {
                    if (visible) {
                        this.updateJSON();
                        if (!this._stackBoundary) {
                            this._stackBoundary = new google.maps.Polyline({
                                path: _outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json),
                                map: _outer._map,
                                strokeWeight: 1
                            });
                        }
                        else {
                            this._stackBoundary.setMap(_outer._map);
                            this._stackBoundary.setPath(_outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json));
                        }
                    }
                    else if (this._stackBoundary) {
                        this._stackBoundary.setMap(null);
                    }
                }
            };
            Object.seal(this._AlertZoneStack);

            /**
             * A class that represents an alert zone, both the drawn map entity and the json.
             * @param id - The unique id that identifies the zone, if one is not provided it will be generated.
             * @param name - The user-defined name.
             * @param paths - The polygon paths, an array of arrays of LatLng objects.
             * @param isCircle - The shape of
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param notificationFilter - The notification data associated with this zone.
             * @param acknowledgement - The acknowledgement property associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @param isEditable - Whether the shapeOverlay of the zone is editable.
             * @private
             */
            this._AlertZone = function (id,name,paths,isCircle,opacity,colour,messageTemplate,notificationFilter,acknowledgement,zIndex,isEditable) {
                this.id = id && typeof id === 'string' ? id : _outer._generateUid();
                this.setName(name || 'Zone 1');
                this.setPaths(paths);
                this.isCircle = !!isCircle;
                this.setOpacity(/*opacity || */0.25); // Fixed opacity
                this.setColour(colour || null); //Default to null so the stack can manage the colours based on the number of zones.
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.messageTemplate = messageTemplate || null;
                this.notificationFilter = notificationFilter || null;
                this.acknowledgement = acknowledgement || null;
                this.isEditable = typeof isEditable !== 'boolean' ? true : isEditable; // Default to true
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
            };
            /**
             * Returns the LatLngBounds for the passed zone.
             * @param zone
             * @static
             */
            this._AlertZone.getBoundingBox = function(zone) {
                if (zone && zone.shapeOverlay) {
                    var bounds = new google.maps.LatLngBounds();
                    var outerPath = zone.shapeOverlay.getPaths().getAt(0);
                    outerPath.forEach(function (latLng) {
                        bounds.extend(latLng);
                    });
                    return bounds;
                }
                return null;
            };
            /**
             * _AlertZone prototype (instance) functions.
             */
            this._AlertZone.prototype = {
                constructor: _outer._AlertZone,
                /**
                 * Returns whether this Polygon was originally drawn as a circle.
                 */
                isCircle: function() {
                    return this.isCircle;
                },
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    _outer._notifyPropertyPathForZone(this,'name');
                },
                /**
                 * Sets the colour and notifies the polymer path.
                 * @param colour
                 */
                setColour: function(colour) {
                    colour = _outer._formatColour(colour);
                    this.colour = colour;
                    _outer._notifyPropertyPathForZone(this,'colour');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ 'fillColor': colour });
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity and notifies the polymer path.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    _outer._notifyPropertyPathForZone(this,'opacity');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets the paths and updates the shape overlay.
                 * @param paths
                 */
                setPaths: function(paths) {
                    this.paths = paths;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setPaths(paths);
                    }
                },
                /**
                 * Sets active, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    _outer._notifyPropertyPathForZone(this,'active');
                    active ? this.activateOverlay() : this.deactivateOverlay();
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the northern coordinate and draws the nameOverlay.
                 * @param northernCoordinate
                 */
                setNorthernCoordinate: function(northernCoordinate) {
                    this.northernCoordinate = northernCoordinate;
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        this.nameOverlay = new _outer._ProximityZoneOverlay(this);
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ "strokeWeight":3.0, "fillOpacity": 0.30 });
                        if (!this.isCircle && this.isEditable) {
                            this.shapeOverlay.setEditable(true);
                        }
                    }
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ "strokeWeight":0.50, "fillOpacity": 0.25 });
                        if (!this.isCircle && this.isEditable) {
                            this.shapeOverlay.setEditable(false);
                        }
                    }
                },
                /**
                 * Highlights the shape overlay by adding a border.
                 */
                highlightOverlay: function() {
                    if (this.shapeOverlay && !this.active) {
                        this.shapeOverlay.setOptions({ "strokeWeight": 2.0, "fillOpacity": 0.30 });
                    }
                    // Show the stack marker
                    if (this.isEditable) {
                        if (_outer._loadedAlert && _outer._loadedAlert.template && _outer._loadedAlert.template.zoneStacks) {
                            for (var i=0; i<_outer._loadedAlert.template.zoneStacks.length; i++) {
                                var stack = _outer._loadedAlert.template.zoneStacks[i];
                                if (stack.getZoneIndex(this) > -1 && stack.marker) {
                                    stack.marker.setOptions( { visible: true } );
                                }
                            }
                        }
                    }
                },
                /**
                 * Restores the original shape overlay border.
                 */
                unHighlightOverlay: function() {
                    if (this.shapeOverlay && !this.active) {
                        this.shapeOverlay.setOptions({ "strokeWeight":0.50, "fillOpacity": 0.25 });
                    }
                    // Hide the stack marker
                    if (this.isEditable) {
                        if (_outer._loadedAlert && _outer._loadedAlert.template && _outer._loadedAlert.template.zoneStacks) {
                            for (var i=0; i<_outer._loadedAlert.template.zoneStacks.length; i++) {
                                var stack = _outer._loadedAlert.template.zoneStacks[i];
                                if (stack.getZoneIndex(this) > -1 && stack.marker) {
                                    stack.marker.setOptions( { visible: false } );
                                }
                            }
                        }
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setMap(null);
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.setMap(null);
                    }
                },
                /**
                 * Returns the options for building a google maps polygon.
                 * @returns {*}
                 * @private
                 */
                _getShapeOverlayOpts: function() {
                    return {
                        clickable: _outer.nodeName !== 'VOYENT-ALERT-VIEW', draggable: false,
                        editable: false, fillColor: this.colour,
                        fillOpacity: this.opacity, map: _outer._map,
                        strokeWeight:0.50, zIndex:this.zIndex, paths:this.paths,
                        suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                    };
                }
            };
            Object.seal(this._AlertZone);

            /**
             * A class that represents the polygonal fallback alert zone.
             * @param enabled - Indicates whether the zone should be displayed immediately after initializing.
             * @param name - The user defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param notificationFilter - The notification filter associated with this zone.
             * @param acknowledgement - The acknowledgement data associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @private
             */
            this._FallbackAlertZone = function(enabled,name,opacity,colour,messageTemplate,notificationFilter,acknowledgement,zIndex) {
                this.id = _outer._FALLBACK_ZONE_ID;
                this.setPaths(this._buildWorldPolygon());
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
                this._setupOverlayClickListener();
                this.setName(name || 'Entire Region');
                this.setOpacity(/*opacity || */0.25); // Fixed opacity
                this.setColour(/*colour || */'9EAD9E'); // Fixed colour
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.messageTemplate = messageTemplate || null;
                this.notificationFilter = notificationFilter || null;
                this.acknowledgement = acknowledgement || null;
                this.nameOverlay = new _outer._FallbackZoneOverlay(this);
                this.setEnabled(enabled);
            };

            this._FallbackAlertZone.prototype = {
                /**
                 * Sets the paths and updates the shape overlay.
                 */
                setPaths: function(paths) {
                    this.paths = paths;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setPaths(paths);
                    }
                },
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    _outer._notifyPropertyPathForFallbackZone('name');
                },
                /**
                 * Sets the colour and notifies the polymer path.
                 * @param colour
                 */
                setColour: function(colour) {
                    colour = _outer._formatColour(colour);
                    this.colour = colour;
                    _outer._notifyPropertyPathForFallbackZone('colour');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ 'fillColor': colour });
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity and notifies the polymer path.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    _outer._notifyPropertyPathForFallbackZone('opacity');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets active, updates the overlay and notifies the polymer path.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    _outer._notifyPropertyPathForFallbackZone('active');
                    active ? this.activateOverlay() : this.deactivateOverlay();
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets enabled, updates the overlays and notifies the polymer path.
                 * @param enabled
                 */
                setEnabled: function(enabled) {
                    this.enabled = enabled;
                    _outer._notifyPropertyPathForFallbackZone('enabled');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'visible':enabled});
                    }
                    if (enabled) {
                        _outer.fire('voyent-alert-zone-added',{"id":this.id,"zone":this,"isFallbackZone":true});
                        this.punchOutOverlay();
                        if (this.nameOverlay) {
                            this.nameOverlay.draw();
                        }
                    }
                    else {
                        _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                        if (this.nameOverlay) {
                            this.nameOverlay.hide();
                        }
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ fillOpacity: 0.40 });
                    }
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ fillOpacity: 0.25 });
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    this.shapeOverlay.setMap(null);
                    if (this.nameOverlay) {
                        this.nameOverlay.hide();
                    }
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer._fallbackZone = null;
                    }
                    _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                },
                /**
                 * Punches out all of the stacks currently drawn on the map.
                 */
                punchOutOverlay: function() {
                    if (!this.enabled) { return; }
                    var paths = this._buildWorldPolygon();
                    if (_outer._loadedAlert) {
                        for (var i=0; i<_outer._loadedAlert.template.zoneStacks.length; i++) {
                            var largestZone = _outer._loadedAlert.template.zoneStacks[i].getLargestZone();
                            //Ideally we would just push the paths directly from the drawn polygon but Google expects
                            //a specific "winding order" of the coordinates. Whichever direction the coordinates
                            //are in for the outer zone, the coordinates for the inner "punched out" zones
                            //must be in the opposite direction. Google handles this ordering when using the Data Layer
                            //API, however, this is overly complex for our purposes. Instead we'll use turf to
                            //reorder the zones by punching them out and returning the newly sorted coordinates.

                            //Convert the array of fallback zone coordinates to a proper MVC paths array.
                            var fallbackPaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                new google.maps.MVCArray([new google.maps.MVCArray(paths[0])])
                            )[0]];
                            //Select only the outer ring of the largest zone in the stack.
                            var largestZonePaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                largestZone.shapeOverlay.getPaths()
                            )[0]];
                            //Do the punch out.
                            var doughnut = turf.difference({
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": fallbackPaths
                                    }
                                }, {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": largestZonePaths
                                    }
                                }
                            );
                            //The coordinates will now be in the correct order so we want to convert them back to paths
                            //and then use this to draw the Polygon. In this case, we don't use the punched out
                            //zone at all. This was only for the purposes of correctly ordering the coordinates list.
                            var orderedLargestZonePaths = _outer._AlertTemplate.calculatePathsFromCoordinates(
                                doughnut.geometry.coordinates
                            )[1];
                            paths.push(orderedLargestZonePaths);
                        }
                    }
                    //The path at index 0 will be the entire fallback zone and
                    //all of the other paths will be punched out stacks.
                    this.setPaths(paths);
                },
                /**
                 * Returns a rectangular polygon representing the entire world.
                 */
                _buildWorldPolygon: function() {
                    //Since Google Maps uses a special web version of the Mercator projection and it
                    //excludes the polar regions the maximum latitude is closer to 85 instead of 90.
                    var worldCoords = [
                        new google.maps.LatLng(85.05113, 180), new google.maps.LatLng(0, 180),
                        new google.maps.LatLng(-85.05113, 180), new google.maps.LatLng(-85.05113, 90),
                        new google.maps.LatLng(-85.05113, 0), new google.maps.LatLng(-85.05113, -90),
                        new google.maps.LatLng(-85.05113, -180), new google.maps.LatLng(0, -180),
                        new google.maps.LatLng(85.05113, -180), new google.maps.LatLng(85.05113, -90),
                        new google.maps.LatLng(85.05113, 0),new google.maps.LatLng(85.05113, 90),
                        new google.maps.LatLng(85.05113, 180)
                    ];
                    return [new google.maps.MVCArray(worldCoords).getArray()];
                },
                /**
                 * Initializes click listener for activating the overlay.
                 * @private
                 */
                _setupOverlayClickListener: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    google.maps.event.addListener(this.shapeOverlay, 'click', function () {
                        _outer._toggleFallbackZoneProperties();
                    });
                },
                /**
                 * Returns the options for building a google maps polygon.
                 * @returns {*}
                 * @private
                 */
                _getShapeOverlayOpts: function() {
                    return {
                        clickable: true, draggable: false,
                        editable: false, fillColor: this.colour,
                        fillOpacity: this.opacity, map: _outer._map,
                        strokeWeight:0, zIndex:this.zIndex, paths:this.paths,
                        suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                    };
                }
            };
            Object.seal(this._FallbackAlertZone);

            /**
             * A class that represents a user's fixed location record, both the drawn map entity and the json.
             * @param id - The system-generated id.
             * @param name - The user-defined name.
             * @param type - The type of location (`mobile`, `residential`, `other`).
             * @param marker - The associated map marker.
             * @param endpointType - The endpoint type (`apns`, `fcm`, `mailto`, `sms`, `voice`) that this location is associated with, if applicable.
             * @private
             */
            this._MyLocation = function(id,name,type,marker,endpointType) {
                this.isPersisted = !!id;
                this.id = id || _outer._generateUid();
                this.setName(name || '');
                this.setType(type || 'other');
                this.setMarker(marker);
                this.endpointType = endpointType;
            };
            this._MyLocation.prototype = {
                constructor: _outer._MyLocation,
                /**
                 * Sets the name, draws the nameOverlay and notifies the polymer path.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    _outer.notifyPath('_loadedLocation.name');
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        // Don't show the floating name overlay label when Viewing an Alert in certain modes
                        if (name && _outer.nodeName !== 'VOYENT-ALERT-VIEW' && (_outer.mode !== 'preview' || _outer.mode !== 'view' || _outer.mode !== 'response')) {
                            this.nameOverlay = new _outer._LocationOverlay(this);
                        }
                    }
                },
                /**
                 * Sets the type and notifies the polymer path.
                 * @param type
                 */
                setType: function(type) {
                    this.type = type;
                    _outer.notifyPath('_loadedLocation.type');
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function(marker) {
                    this.marker = marker;
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Adds the location to the map. Used to reverse `removeFromMap`.
                 */
                addToMap: function() {
                    this.marker.setMap(_outer._map);
                    if (this.nameOverlay) {
                        this.nameOverlay.displayAndDraw();
                    }
                },
                /**
                 * Removes the location from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    if (this.nameOverlay) {
                        this.nameOverlay.hide();
                    }
                },
                /**
                 * Updates the JSON to reflect the current state of the template.
                 * @private
                 */
                updateJSON: function() {
                    var markerPosition = this.marker.getPosition();
                    this.json = {
                        "location": {
                            "geometry": {
                                "type": "Point",
                                "coordinates": [markerPosition.lng(),markerPosition.lat()]
                            },
                            "properties": {
                                "vras": {
                                    "id": this.id,
                                    "name": this.name,
                                    "type": this.type
                                }
                            }
                        }
                    }
                },
                /**
                 * Initializes marker listeners for the location.
                 * @private
                 */
                _setupMarkerListeners: function() {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //Continuously re-draw the overlay as the location is dragged.
                    var marker = this.marker;
                    google.maps.event.addListener(marker,'drag',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.draw();
                        }
                    });
                    //Update the coordinates on the location record and flag the location for updating after it's dragged.
                    google.maps.event.addListener(marker,'dragend',function() {
                        _outer._saveLocation(_this,'moved');
                    });
                    //Display infoWindow on location marker click.
                    google.maps.event.addListener(marker,'click',function() {
                        _outer._toggleInfoWindow(_this);
                    });
                    //Adjust the stacking order of the name on mouseover and mouseout.
                    google.maps.event.addListener(marker,'mouseover',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.moveToTopPane();
                        }
                    });
                    google.maps.event.addListener(marker,'mouseout',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.moveToDefaultPane();
                        }
                    });
                }
            };
            Object.seal(this._MyLocation);

            /**
             * A class that represents the fallback zone control overlay.
             * @private
             */
            this._FallbackZoneOverlay = function(zone) {
                this.zone = zone;
                this.div = _outer._buildOverlayDiv(true);
                if (zone.enabled) {
                    this.draw();
                }
            };
            this._FallbackZoneOverlay.prototype = {
                /**
                 * Handles drawing and re-drawing of the fallback zone control overlay on the map.
                 */
                draw: function() {
                    //Set the div content, replacing spaces with non-breaking ones.
                    this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                    //Configure additional styling.
                    if (this.zone.active) {
                        this.div.style.fontSize = '14px';
                    }
                    else {
                        this.div.style.fontSize = '12px';
                    }
                    this.div.style.backgroundColor = this.zone.colour;
                    this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
                    if (!_outer._map.controls[google.maps.ControlPosition.TOP_CENTER].length) {
                        _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].push(this.div);
                    }
                },
                /**
                 * Hide the control overlay.
                 */
                hide: function() {
                    _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].clear();
                }
            };
            /**
             * A class that represents a zone name overlay.
             * @param zone - The zone for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._ProximityZoneOverlay = function(zone) {
                var _this = this;
                this.zone = zone;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv(true);
                // Bring the label to top on mouseover
                this.div.onmouseover = function () {
                    _this.moveToTopPane();
                };
                this.div.onmouseout = function () {
                    _this.moveToDefaultPane();
                };
            };
            /**
             * A class that represents a location name overlay.
             * @param location - The location for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._LocationOverlay = function(location) {
                var _this = this;
                this.loc = location;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv();
                this.div.style.cursor = 'pointer';
                if (_outer.nodeName === 'VOYENT-MY-LOCATIONS') {
                    // Add some listeners to support info window toggling via label selection
                    this.div.onmouseover = function () {
                        _this.moveToTopPane();
                    };
                    this.div.onmouseout = function () {
                        _this.moveToDefaultPane();
                    };
                    this.div.onclick = function() {
                        _outer._toggleInfoWindow(_this.loc);
                    };
                }
            };
            /**
             * A class representing the overlay displayed when holding the mouse down on the my locations map.
             * @param latLng - A google.maps.LatLng object indicating the position of the overlay.
             * @param pixelCoordinates - An object containing x and y coordinates of the mouse position relative to the map.
             * @extends google.maps.OverlayView
             * @private
             */
            this._MouseHoldOverlay = function(latLng,pixelCoordinates) {
                this.latLng = latLng;
                this.pixelCoordinates = pixelCoordinates;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv();
                //Setup our transition and opacity so we can fade this overlay in.
                this.div.style.opacity = '0';
                this.div.style.webkitTransition = 'opacity 0.5s';
                this.div.style.transition = 'opacity 0.5s';
            };
            //Inherit the prototype of google.maps.OverlayView.
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();
            this._LocationOverlay.prototype = new google.maps.OverlayView();
            this._MouseHoldOverlay.prototype = new google.maps.OverlayView();
            /**
             * Called automatically when the map is ready for the overlay to be attached.
             */
            this._ProximityZoneOverlay.prototype.onAdd =
            this._LocationOverlay.prototype.onAdd =
            this._MouseHoldOverlay.prototype.onAdd = function () {
                //Add the div to the floatShadow pane so it renders above the markers.
                this.getPanes().floatShadow.appendChild(this.div);
            };
            /**
             * Handles drawing and re-drawing of the proximity zone overlay on the map.
             */
            this._ProximityZoneOverlay.prototype.draw = function() {
                //This will be called before it's ready when loading Alerts so we'll return if the prototype isn't initialized.
                if (!this.getProjection()) { return; }
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var northernCoordinate = this.zone.northernCoordinate;
                var nc = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(northernCoordinate[1],northernCoordinate[0])
                );
                //Set the div content, replacing spaces with non-breaking ones.
                this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                //Configure additional styling.
                if (this.zone.active) {
                    this.div.style.fontSize = '14px';
                    this.div.style.top = nc.y-28 + 'px';
                }
                else {
                    this.div.style.fontSize = '12px';
                    this.div.style.top = nc.y-26 + 'px';
                }
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.backgroundColor = this.zone.colour;
                this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
            };
            /**
             * Handles drawing and re-drawing of the location overlay on the map.
             */
            this._LocationOverlay.prototype.draw = function () {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(this.loc.marker.getPosition());
                //Set the div content.
                this.div.innerHTML = this.loc.name;
                //Center the label above the location.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-64 + 'px';
                //Configure additional styling.
                this.div.style.backgroundColor = '#64FE86';
                this.div.style.color = '#000000';
            };
            /**
             * Handles drawing the mouse hold overlay on the my locations map.
             */
            this._MouseHoldOverlay.prototype.draw = function () {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(this.latLng);
                //Set the div content.
                this.div.innerHTML = 'Release ' + (_outer.isMobile ? 'Finger' : 'Mouse') +' to Create Location';
                //Generally we will render the overlay x pixels above where the user selects. If this position will be hidden
                //because they selected near the top of the map then we will render 10 pixels below instead. If they select on
                //the left or right edge then we will adjust the position to the side to ensure the entire overlay is within view.
                var halfWidth = this.div.offsetWidth/2;
                if (this.pixelCoordinates.x > halfWidth) {
                    //If the overlay is being rendered near the right edge of the map
                    //then we will have a renderRightOffset otherwise just use 0.
                    var renderRightOffset = (this.pixelCoordinates.x + halfWidth) - _outer._map.getDiv().clientWidth;
                    renderRightOffset = renderRightOffset > 0 ? renderRightOffset : 0;
                    this.div.style.left = (nc.x - halfWidth) - renderRightOffset + 'px';
                }
                else {
                    //If we fall into here it means we are drawing this overlay close to the left edge of
                    //the map. In this case we want to ensure that we render the overlay entirely in view.
                    var renderLeftOffset = halfWidth - this.pixelCoordinates.x;
                    this.div.style.left = (nc.x - halfWidth) + renderLeftOffset + 'px';
                }
                //Render further from coordinate on mobile since the user's finger is in the way.
                var generalPixelOffset = _outer.isMobile ? 45 : 10;
                var renderAboveOffset = this.div.offsetHeight+generalPixelOffset;
                this.div.style.top = (this.pixelCoordinates.y > renderAboveOffset ? nc.y-this.div.offsetHeight-generalPixelOffset : nc.y+generalPixelOffset) + 'px';
                //Configure additional styling.
                this.div.style.backgroundColor = '#88b7d5';
                this.div.style.border = '2px solid #c2e1f5';
                this.div.style.borderRadius = '20px';
                this.div.style.opacity = '0.9';
                this.div.style.padding = '5px';
            };
            /**
             * Cleans up the overlay whenever the overlays map property is set to null.
             */
            this._ProximityZoneOverlay.prototype.onRemove =
            this._LocationOverlay.prototype.onRemove =
            this._MouseHoldOverlay.prototype.onRemove = function () {
                if (this.div && this.div.parentNode) {
                    this.div.parentNode.removeChild(this.div);
                    this.div = null;
                }
            };
            /**
             * Hide the overlay.
             */
            this._LocationOverlay.prototype.hide = function() {
                this.div.style.display = 'none';
            };
            /**
             * Re-display the overlay.
             */
            this._LocationOverlay.prototype.displayAndDraw = function() {
                this.div.style.display = 'block';
                this.draw();
            };
            /**
             * Moves the zone overlay to a map pane with a higher stacking priority.
             */
            this._ProximityZoneOverlay.prototype.moveToTopPane = function() {
                // Move the overlay to a pane with a higher stacking priority
                this.getPanes().overlayMouseTarget.appendChild(this.div);
            };
            /**
             * Moves the zone overlay to the default map pane.
             */
            this._ProximityZoneOverlay.prototype.moveToDefaultPane = function() {
                // Move the overlay to the default pane
                this.getPanes().floatShadow.appendChild(this.div);
            };
            /**
             * Moves the location overlay to a map pane with a higher stacking priority.
             */
            this._LocationOverlay.prototype.moveToTopPane = function() {
                // Add a border and slightly adjust the position of the overlay
                // so it doesn't appear to shift due to the new border
                this.div.style.borderStyle = 'solid';
                this.div.style.borderWidth = '1px';
                var newTop = parseFloat(this.div.style.top.substr(0,this.div.style.top.indexOf('px'))) - 1;
                this.div.style.top = newTop + 'px';
                var newLeft = parseFloat(this.div.style.left.substr(0,this.div.style.left.indexOf('px'))) - 1;
                this.div.style.left = newLeft + 'px';
                // Move the overlay to a pane with a higher stacking priority + adjust marker z-index
                this.getPanes().overlayMouseTarget.appendChild(this.div);
                this.loc.marker.setZIndex(100);
                // Move the other overlays to a pane with a lower stacking priority so they will hide behind this overlay's marker
                for (var i=0; i<_outer._myLocations.length; i++) {
                    if (this !== _outer._myLocations[i].nameOverlay) {
                        this.getPanes().overlayLayer.appendChild(_outer._myLocations[i].nameOverlay.div);
                    }
                }
            };
            /**
             * Moves the location overlay to the default map pane.
             */
            this._LocationOverlay.prototype.moveToDefaultPane = function() {
                // Remove the border and positioning
                this.div.style.borderStyle = 'none';
                this.div.style.borderWidth = '0px';
                var newTop = parseFloat(this.div.style.top.substr(0,this.div.style.top.indexOf('px'))) + 1;
                this.div.style.top = newTop + 'px';
                var newLeft = parseFloat(this.div.style.left.substr(0,this.div.style.left.indexOf('px'))) + 1;
                this.div.style.left = newLeft + 'px';
                // Move the overlay to the default pane + adjust marker z-index
                this.getPanes().floatShadow.appendChild(this.div);
                this.loc.marker.setZIndex(50);
                // Move the other overlays to the default pane
                for (var i=0; i<_outer._myLocations.length; i++) {
                    if (this !== _outer._myLocations[i].nameOverlay) {
                        this.getPanes().floatShadow.appendChild(_outer._myLocations[i].nameOverlay.div);
                    }
                }
            };
            /**
             * Returns a font colour of black or white based on the zone colour.
             */
            this._FallbackZoneOverlay.prototype.returnColourBasedOnBackground =
            this._ProximityZoneOverlay.prototype.returnColourBasedOnBackground = function(hex) {
                // Chop any leading # character
                if (hex.charAt(0) === '#') {
                    hex = hex.substr(1);
                }
                return (
                    0.213 * parseInt(hex.slice(0, 2), 16) +
                    0.715 * parseInt(hex.slice(2, 4), 16) +
                    0.072 * parseInt(hex.slice(4, 6), 16) >
                    255 / 2
                ) ? '#000' : '#FFF';
            };
            Object.seal(this._FallbackZoneOverlay);
            Object.seal(this._ProximityZoneOverlay);
            Object.seal(this._LocationOverlay);
            Object.seal(this._MouseHoldOverlay);
        }
    };
</script>