<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">
<link rel="import" href="../imports/turf.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {

        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'}
        },

        ready: function() {
            this._loadedAlertTemplate = null;
        },

        observers: ['_zonesUpdated(_loadedAlertTemplate.zones.length)'],

        /**
         * Updates the current alert Location
         * @private
         */
        _updateAlertLocation: function() {
            var _this = this;
            var pos = this._loadedAlertTemplate.marker.getPosition();
            var location = {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : [pos.lng(),pos.lat()] },
                    "properties": {
                        "alertId": this._loadedAlertTemplate.id,
                        "vras": {
                            "isNewAlert": this._showConfirmingAlertPane
                        }
                    }
                }
            };
            voyent.locate.updateAlertLocation({realm:this.realm,account:this.account,location: location}).then(function() {
                if (_this._showConfirmingAlertPane) {
                    _this._proceedToPropertiesPane();
                    _this.fire('message-info', 'New alert activated!');
                }
            }).catch(function (e) {
                _this.fire('message-error', 'Issue creating ' + _this._loadedAlertTemplate.name +
                                            ': ' + (e.responseText || e.message || e))
            });
        },

        /**
         * Toggles the accordion panels. This is used to toggle the accordion
         * for both accordion pane and proximity zone clicks.
         * @param eOrI
         * @private
         */
        _toggleAccordion: function(eOrI) {
            //This function will either be passed an event (from the ui) or a direct index (from the JS).
            var index = eOrI.model ? eOrI.model.get('index') : eOrI;
            //If they toggle the currently toggled accordion pane then we'll close it.
            if (index > -1 && this._loadedAlertTemplate.getZoneAt(index).active) {
                index = -1;
            }
            this._loadedAlertTemplate.deactivateZoneOverlays();
            if (index > -1) {
                var zone = this._loadedAlertTemplate.getZoneAt(index);
                zone.setActive(true);
                this.fire('voyent-alert-zone-selected', {
                    'index': index,
                    'id': zone.id,
                    'zone': zone
                });
            }
            else {
                this.fire('voyent-alert-zone-selected', {
                    'index': -1,
                    'id': null,
                    'zone': null
                });
            }
        },

        /**
         * Sorts the Proximity Zones based on their radius.
         * @private
         */
        _sortZonesBySize: function() {
            var _this = this;
            //Async so the template updates properly.
            setTimeout(function() {
                _this._loadedAlertTemplate.zones.sort(_this._sortZones);
                //Force the template-repeat to re-render.
                var repeat = document.querySelector('#zones-repeat');
                if (repeat) { repeat.render(); }
                //The zoneIndex might have changed for the loaded zone so determine the index and re-fire the event.
                var selectedZoneIndex = -1;
                var zones = _this._loadedAlertTemplate.zones;
                for (var i=0;i<zones.length; i++) {
                    if (zones[i].active) {
                        selectedZoneIndex = i;
                        break;
                    }
                }
                if (selectedZoneIndex > -1) {
                    _this.fire('voyent-alert-zone-selected',{
                            'index': selectedZoneIndex,
                            'id': zones[selectedZoneIndex].id,
                            'zone': zones[selectedZoneIndex]
                    });
                }
                //Update the z-indexes so we can always click the zones.
                _this._adjustZIndexes();
            },0)
        },

        /**
         * Template helper for sorting the Proximity Zones by size and managing the z-index of the zones.
         * @param a
         * @param b
         * @private
         */
        _sortZones: function(a,b) {
            if (a.getShape() === 'circle') {
                if (a.radius < b.radius) { return -1; }
                else if (a.radius > b.radius) { return 1; }
                return 0;
            }
            else { //'polygon'
                if (google.maps.geometry.spherical.computeArea(a.shapeOverlay.getPaths()) <
                    google.maps.geometry.spherical.computeArea(b.shapeOverlay.getPaths())) {
                    return -1;
                }
                else if (google.maps.geometry.spherical.computeArea(a.shapeOverlay.getPaths()) >
                         google.maps.geometry.spherical.computeArea(b.shapeOverlay.getPaths())) {
                    return 1;
                }
                return 0;
            }
        },

        /**
         * Maintains the correct z-index for each Proximity Zone.
         * @private
         */
        _adjustZIndexes: function() {
            var zIndex=49, zones = this._loadedAlertTemplate.zones;
            for (var i=0; i<zones.length; i++) {
                zones[i].setZIndex(zIndex);
                zIndex--;
            }
        },

        /**
         * Monitors changes to the features.zones or all.properties list for sorting purposes.
         * @param length
         * @private
         */
        _zonesUpdated: function(length) {
            if (length) { this._sortZonesBySize(); }
        },

        /**
         * All components need a reference to the classes so once the map is set we'll initialize them.
         */
        _mapChanged: function(map) {
            if (map) {
                this._initializeClasses();
            }
        },

        /**
         * Generates a uid using the current time in ms and a random number in the hundred thousands.
         * @returns {string}
         * @private
         */
        _generateUid: function() {
            return new Date().getTime()+'-'+Math.floor(Math.random()*(900000)+100000);
        },

        /**
         * Initialize all our custom "classes" that are required for the various components.
         * @private
         */
        _initializeClasses: function() {
            var _outer = this;
            /**
             * Common code for inheriting a parent's prototype on the child's.
             * @private
             */
            this._inheritPrototype = function(child,parent) {
                var parentPrototypeClone = Object.create(parent.prototype);
                parentPrototypeClone.constructor = child;
                child.prototype = parentPrototypeClone;
            };
            /**
             * A class that represents an alert template, both the drawn map entity and the json.
             * @param id - The unique identifier.
             * @param name - The user-defined name.
             * @param marker - The associated map marker.
             * @param zones - A list of _AlertZone objects, the list of zones associated with the template.
             * @param parentId - The parent template id, only relevant for child templates.
             * @private
             */
            this._AlertTemplate = function (id,name,marker,zones,parentId) {
                this.setId(id || null);
                this.setParentId(parentId || null);
                this.setName(name || 'Unnamed');
                this.setMarker(marker || null);
                this.setZones(zones && zones.length ? zones : []);
                this.updateJSON();
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateCentroidUsingJSON = function(json) {
                var geometries = json.geo.geometries;
                var coordinates, bounds = new google.maps.LatLngBounds();
                for (var i=0; i<geometries.length; i++) {
                    coordinates = geometries[i].coordinates[0];
                    for (var j=0; j<coordinates.length; j++) {
                        bounds.extend(new google.maps.LatLng(coordinates[j][1],coordinates[j][0]));
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed paths array.
             * @param paths - An array of arrays of LatLng objects that define the zone.
             * @static
             */
            this._AlertTemplate.calculateCentroidUsingPaths = function(paths) {
                var bounds = new google.maps.LatLngBounds();
                for (var i=0; i<paths.length; i++) {
                    for (var j=0; j<paths.getAt(i).length; j++) {
                        bounds.extend(paths.getAt(i).getAt(j));
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Calculate the shape overlay paths using the passed coordinates arrays.
             * @param coordinates
             * @static
             */
            this._AlertTemplate.calculatePathsUsingCoordinates = function(coordinates) {
                var latLng, paths = [], path;
                for (var i=0; i<coordinates.length; i++) {
                    path = [];
                    for (var j=0; j<coordinates[i].length; j++) {
                        latLng = new google.maps.LatLng(coordinates[i][j][1],coordinates[i][j][0]);
                        path.push(latLng);
                    }
                    paths.push(path);
                }
                return paths;
            };
            /**
             * A static function that returns the default JSON structure.
             * @static
             */
            this._AlertTemplate.getJSONStructure = function () {
                return {
                    "name": "Unnamed",
                    "geo": {
                        "type": "GeometryCollection",
                        "geometries": []
                    },
                    "properties": {}
                };
            };
            /**
             * _AlertTemplate prototype (instance) functions.
             */
            this._AlertTemplate.prototype = {
                constructor: _outer._AlertTemplate,
                /**
                 * Sets the id, updates the json and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param id
                 */
                setId: function (id) {
                    this.id = id;
                    if (this.json) {
                        this.json._id = id;
                    }
                    if (_outer._loadedAlertTemplate === this) {
                        _outer.set('_loadedAlertTemplate.id', id);
                    }
                },
                /**
                 * Sets the parentId, updates the json and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param parentId
                 */
                setParentId: function(parentId) {
                    this.parentId = parentId;
                    if (this.json) {
                        this.json.properties.parentAlertId = parentId;
                    }
                    if (_outer._loadedAlertTemplate === this) {
                        _outer.set('_loadedAlertTemplate.parentId', parentId);
                    }
                },
                /**
                 * Sets the name, updates the json and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    if (this.json) {
                        this.json.name = name;
                    }
                    if (_outer._loadedAlertTemplate === this) {
                        _outer.set('_loadedAlertTemplate.name', name);
                    }
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    this._setupMarkerListeners();
                },
                /**
                 * Sets the zones and triggers required processing.
                 * @param zones
                 */
                setZones: function (zones) {
                    this.zones = zones;
                    for (var i=0; i<zones.length; i++) {
                        this._processNewZone(zones[i]);
                    }
                },
                /**
                 * Returns the zone at the specified index.
                 * @param index
                 */
                getZoneAt: function (index) {
                    return this.zones[index];
                },
                /**
                 * Returns the index of the passed zone.
                 * @param zone
                 */
                getZoneIndex: function (zone) {
                    return this.zones.indexOf(zone);
                },
                /**
                 * Returns the largest zone.
                 */
                getLargestZone: function() {
                    return this.getZoneAt(this.zones.length-1);
                },
                /**
                 * Deactivates all zones.
                 */
                deactivateZoneOverlays: function () {
                    for (var i = 0; i < this.zones.length; i++) {
                        this.zones[i].setActive(false);
                    }
                },
                /**
                 * Add the passed zone.
                 * @param zone
                 */
                addZone: function (zone) {
                    if (_outer._loadedAlertTemplate === this) {
                        _outer.push('_loadedAlertTemplate.zones',zone);
                    }
                    else {
                        this.zones.push(zone);
                    }
                    this.updateJSON();
                    this._punchOutShape(this.zones.length-1);
                    this._processNewZone(zone);
                },
                /**
                 * Remove the passed zone.
                 * @param zone
                 */
                removeZone: function (zone) {
                    zone.shapeOverlay.setMap(null);
                    zone.nameOverlay.setMap(null);
                    var zoneIndex = this.getZoneIndex(zone);
                    if (_outer._loadedAlertTemplate === this) {
                        _outer.splice('_loadedAlertTemplate.zones',zoneIndex,1);
                    }
                    else {
                        this.zones.splice(zoneIndex,1);
                    }
                    this.updateJSON();
                },
                /**
                 * Updates the JSON to reflect the current state of the template. Also updates
                 * the northernCoordinate which adjusts the position of the zone name overlays.
                 */
                updateJSON: function () {
                    var N = 50; //The number of coordinates circular polygons will have.
                    var degreeStep = 360 / N; //The number of degrees in which each coordinate will be spaced apart.
                    var zone, northernCoordinate, latLng, id, overlay, json = this.constructor.getJSONStructure();
                    json.name = this.name;
                    if (this.parentId) {
                        json.properties.parentAlertId = this.parentId;
                    }
                    for (var i=0; i<this.zones.length; i++) {
                        zone = this.zones[i];
                        northernCoordinate = [null, -100];
                        id = zone.id;
                        overlay = zone.shapeOverlay;
                        json.properties[id] = {
                            "name": zone.name,
                            "shape": zone.getShape(),
                            "editable": zone.editable,
                            "opacity": zone.opacity,
                            "colour": zone.colour
                        };
                        if (zone.messageTemplate) {
                            json.properties[id].messageTemplate = zone.messageTemplate;
                        }
                        json.geo.geometries.push({
                            "id": id,
                            "type": "Polygon",
                            "coordinates": [[]]
                        });
                        if (zone.getShape() === 'circle') {
                            json.properties[id].radius = zone.radius;
                            var center =  this.marker.getPosition();
                            for (var j=0; j<N; j++) {
                                //Calculate and save the next coordinate.
                                latLng = google.maps.geometry.spherical.computeOffset(
                                    center, json.properties[id].radius,  degreeStep * j
                                );
                                json.geo.geometries[i].coordinates[0].push([latLng.lng(), latLng.lat()]);
                                //Look for the northern most point of the circle so we know
                                //where to render the Proximity Zone overlay label.
                                if (latLng.lat() > northernCoordinate[1]) {
                                    northernCoordinate = [latLng.lng(), latLng.lat()];
                                }
                            }
                        }
                        else {
                            var paths = overlay.getPaths();
                            for (var k=0; k<paths.length; k++) {
                                for (var l=0; l<paths.getAt(k).length; l++) {
                                    //Retrieve each coordinate from the shape and save it.
                                    latLng = paths.getAt(k).getAt(l);
                                    json.geo.geometries[i].coordinates[0].push([
                                        latLng.lng(), latLng.lat()
                                    ]);
                                    //Look for the northern most point of the polygon so we know
                                    //where to render the Proximity Zone overlay label.
                                    if (latLng.lat() > northernCoordinate[1]) {
                                        northernCoordinate = [latLng.lng(), latLng.lat()];
                                    }
                                }
                            }
                        }
                        zone.setNorthernCoordinate(northernCoordinate);
                        //Copy the first coordinate to the last one to complete the shape.
                        json.geo.geometries[i].coordinates[0].push(json.geo.geometries[i].coordinates[0][0]);
                    }
                    this.json = json;
                },
                /**
                 * Loops the zone coordinates in the JSON and triggers punching out the smaller
                 * from the larger, starting from the largest and excluding the smallest.
                 */
                punchOutShapes: function() {
                    for (var i=this.json.geo.geometries.length-1; i>0; i--) {
                        this._punchOutShape(i);
                    }
                },
                /**
                 * Punches out the zone at the passed index with it's closest smallest zone.
                 * @param index - The index of the zone to be punched out.
                 * @private
                 */
                _punchOutShape: function(index) {
                    //Return if the index of the smallest zone (0) is passed then don't proceed.
                    if (!index) { return; }
                    //Turf accepts polygon feature objects so pass these in and then
                    //only pull out the coordinates from the new feature object.
                    var doughnut = turf.difference({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": this.json.geo.geometries[index].coordinates
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": this.json.geo.geometries[index-1].coordinates
                            }
                        }
                    );
                    var coordinates = doughnut.geometry.coordinates;
                    if (this.zones[index].getShape() === 'polygon') {
                        //Calculate and set the new punched out paths so the changes get reflected on the map immediately.
                        var punchedOutPaths = this.constructor.calculatePathsUsingCoordinates(coordinates);
                        this.zones[index].shapeOverlay.setPaths(punchedOutPaths);
                    }
                    //Replace the old json coordinates with our new punched out zone.
                    this.json.geo.geometries[index].coordinates = coordinates;
                },
                /**
                 * Updates the center of the zone to match the marker and sets up relevant listeners.
                 * @private
                 */
                _processNewZone: function(zone) {
                    if (zone.getShape() === 'circle') {
                        zone.shapeOverlay.setCenter(this.marker.getPosition());
                    }
                    this._setupZoneListeners(zone);
                },
                /**
                 * Calculates the zone positions in relation to the centroid.
                 * @private
                 */
                _calculateCoordinatePositions: function() {
                    var centroid = this.marker.getPosition(), positions;
                    for (var i=0; i<this.zones.length; i++) {
                        positions=[];
                        if (this.zones[i].getShape() === 'circle') {
                            //Calculate the distance and bearing from the centroid to the center of the zone.
                            var zoneCenter = this.zones[i].shapeOverlay.getCenter();
                            positions.push({
                                "distance":google.maps.geometry.spherical.computeDistanceBetween(centroid,zoneCenter),
                                "bearing":google.maps.geometry.spherical.computeHeading(centroid,zoneCenter)
                            });
                        }
                        else { //polygon
                            var paths = this.zones[i].shapeOverlay.getPaths(), innerPositions;
                            for (var j=0; j<paths.length; j++) {
                                innerPositions = [];
                                for (var k=0; k<paths.getAt(j).length; k++) {
                                    //Calculate the distance and bearing from the centroid to the each vertex.
                                    innerPositions.push({
                                        "distance":google.maps.geometry.spherical.computeDistanceBetween(centroid,paths.getAt(j).getAt(k)),
                                        "bearing":google.maps.geometry.spherical.computeHeading(centroid,paths.getAt(j).getAt(k))
                                    });
                                }
                                positions.push(innerPositions);
                            }
                        }
                        this.zones[i]._coordinatePositions = positions;
                    }
                },
                /**
                 * Syncs the zone positions with marker movements.
                 * @private
                 */
                _dragZonesWithMarker: function () {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions = this.zones[i]._coordinatePositions;
                        if (this.zones[i].getShape() === 'circle') {
                            var newCenter = google.maps.geometry.spherical.computeOffset(
                                this.marker.getPosition(),
                                positions[0].distance,
                                positions[0].bearing
                            );
                            this.zones[i].shapeOverlay.setCenter(newCenter);
                        }
                        else { //polygon
                            var paths = [], path;
                            for (var j=0; j<positions.length; j++) {
                                path = [];
                                for (var k=0; k<positions[j].length; k++) {
                                    path.push(google.maps.geometry.spherical.computeOffset(
                                        this.marker.getPosition(),
                                        positions[j][k].distance,
                                        positions[j][k].bearing)
                                    );
                                }
                                paths.push(path);
                            }
                            this.zones[i].setPaths(paths);
                        }
                    }
                },
                /**
                 * Initializes marker listeners.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the marker so we'll use these listeners to ignore those events.
                    var marker = this.marker;
                    google.maps.event.addListener(marker, 'dragstart', function () {
                        _outer._ignoreCenterChangedEvent = true;
                        _this._calculateCoordinatePositions();
                    });
                    google.maps.event.addListener(marker, 'dragend', function () {
                        _outer._ignoreCenterChangedEvent = false;
                        //Update the alert's location if the alert is activated.
                        if (_this.parentId && _outer._isActivated) {
                            _outer._updateAlertLocation();
                        }
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(marker, 'click', function () {
                        //Toggle all the accordions closed.
                        if (_outer._loadedAlertTemplate) {
                            _outer._toggleAccordion(-1);
                        }
                        //Load the clicked template data in case it's a different template.
                        _outer._loadedAlertTemplate = _this;
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(marker, 'drag', function () {
                        _this._dragZonesWithMarker();
                        _this.updateJSON();
                    });
                },
                /**
                 * Initializes zone listeners.
                 * @private
                 */
                _setupZoneListeners: function (zone) {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    var overlay = zone.shapeOverlay;
                    //Add click listener to shapes.
                    google.maps.event.addListener(overlay, 'click', function () {
                        var zoneIndex = _this.getZoneIndex(zone);
                        //If we have a currently loaded alert template or alert...
                        if (_outer._loadedAlertTemplate) {
                            //If they click a zone for the currently active
                            //alert template or alert then toggle the accordion.
                            if (_outer._loadedAlertTemplate === _this) {
                                _outer._toggleAccordion(zoneIndex);
                            }
                            else {
                                //Toggle the accordion for the previously selected alert template.
                                _outer._toggleAccordion(-1);
                                //Load the new one and toggle the selected zone.
                                _outer._loadedAlertTemplate = _this;
                                _outer._toggleAccordion(zoneIndex);
                            }
                        }
                        else { //If we have no loaded data then always load the template and toggle the selected zone.
                            _outer._loadedAlertTemplate = _this;
                            _outer._toggleAccordion(zoneIndex);
                        }
                    });

                    if (zone.getShape() === 'circle') {
                        /*This listener is used for the special case of dragging by the center editable point of circular
                        zones. When the user drags by this center point we need to be sure to move the zones and marker
                        to it's new position after dragging. However, this listener will fire after modifying the positions
                        of other zones so we will use a flag to ignore these events. Additionally, we use a flag to ignore
                        when dragging by the marker because the event fires continiously then as well.*/
                        google.maps.event.addListener(overlay, 'center_changed', function () {
                            if (_outer._ignoreCenterChangedEvent) {
                                return;
                            }
                            _outer._ignoreCenterChangedEvent = true;
                            _this.marker.setPosition(this.getCenter());
                            for (var i=0; i<_this.zones.length; i++) {
                                _this.zones[i].shapeOverlay.setCenter(this.getCenter());
                            }
                            _this.updateJSON();
                            _outer._ignoreCenterChangedEvent = false;
                            //Update the alert's location.
                            if (_this.parentId) {
                                _outer._updateAlertLocation();
                            }
                        });
                        //Add resize listener to circle.
                        google.maps.event.addListener(overlay, 'radius_changed', function () {
                            _this.updateJSON();
                            //Sort the zones list.
                            _outer._sortZonesBySize();
                        });
                    }
                    else { //Handle editing polygonal zones.
                        for (var i=0; i<overlay.getPaths().length; i++) {
                            google.maps.event.addListener(overlay.getPaths().getAt(i), "insert_at", function () {
                                _this._polyAtListeners();
                            });
                            google.maps.event.addListener(overlay.getPaths().getAt(i), "set_at", function () {
                                _this._polyAtListeners();
                            });
                            google.maps.event.addListener(overlay.getPaths().getAt(i), "remove_at", function () {
                                _this._polyAtListeners();
                            });
                        }
                    }
                },
                /**
                 * Handles polygon edits.
                 * @private
                 */
                _polyAtListeners: function () {
                    this.updateJSON();
                    //The area of the polygon may be smaller or
                    //larger than the other zones now so re-sort.
                    _outer._sortZonesBySize();
                }
            };
            Object.seal(this._AlertTemplate);

            /**
             * A class that represents an alert zone, both the drawn map entity and the json.
             * @param name - The user-defined name.
             * @param editable - Whether the zone is editable (resizable).
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @private
             */
            this._AlertZone = function (name,editable,opacity,colour,zIndex) {
                this.id = _outer._generateUid();
                this.setName(name || 'Zone_1');
                this.setEditable(typeof editable === 'boolean' ? editable : true);
                this.setOpacity(opacity || 0.30);
                this.setColour(colour || '000000');
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.setRenaming(false);
                this.messageTemplate = null;
            };
            /**
             * _AlertZone prototype (instance) functions.
             */
            this._AlertZone.prototype = {
                constructor: _outer._AlertZone,
                /**
                 * Sets the name and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.name',name);
                    }
                },
                /**
                 * Sets editable, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param editable
                 */
                setEditable: function(editable) {
                    this.editable = editable;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.editable',editable);
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setEditable(editable);
                    }
                },
                /**
                 * Sets the colour, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param colour
                 */
                setColour: function(colour) {
                    this.colour = colour;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.colour',colour);
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillColor':'#'+colour})
                    }
                },
                /**
                 * Sets the opacity, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.opacity',opacity);
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets active, updates the overlay and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.active',active);
                    }
                    active ? this.activateOverlay() : this.deactivateOverlay();
                },
                /**
                 * Sets the northern coordinate and draws the nameOverlay.
                 * @param northernCoordinate
                 */
                setNorthernCoordinate: function(northernCoordinate) {
                    this.northernCoordinate = northernCoordinate;
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        this.nameOverlay = new _outer._ProximityZoneOverlay(this);
                    }
                },
                /**
                 * Sets renaming and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param renaming
                 */
                setRenaming: function(renaming) {
                    this.renaming = renaming;
                    if (_outer._loadedAlertTemplate && _outer._loadedAlertTemplate.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlertTemplate.zones.'+_outer._loadedAlertTemplate.zones.indexOf(this)+'.renaming',renaming);
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({"strokeWeight":2});
                        this.shapeOverlay.setEditable(this.editable);
                    }
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({"strokeWeight":0});
                        this.shapeOverlay.setEditable(false);
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    this.shapeOverlay.setMap(null);
                    this.nameOverlay.setMap(null);
                }
            };
            Object.seal(this._AlertZone);

            /**
             * A class that represents a circular alert zone.
             * @param radius - The circle radius.
             * @param name - The user-defined name.
             * @param editable - Whether the zone is editable (resizable).
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @extends _AlertZone
             * @private
             */
            this._CircularAlertZone = function(radius,name,editable,opacity,colour,zIndex) {
                _outer._AlertZone.call(this,name,editable,opacity,colour,zIndex);
                this.radius = radius || 500;
                this.shapeOverlay = (new google.maps.Circle(this._getShapeOverlayOpts()));
            };
            //Inherit the prototype of _AlertZone.
            this._inheritPrototype(this._CircularAlertZone, this._AlertZone);
            /**
             * Returns the shape in string format.
             */
            this._CircularAlertZone.prototype.getShape = function() {
                return 'circle';
            };
            /**
             * Returns the options for building a google maps circle.
             * @returns {*}
             * @private
             */
            this._CircularAlertZone.prototype._getShapeOverlayOpts = function() {
                return {
                    draggable: false, editable: false,
                    fillColor: '#'+this.colour, fillOpacity: this.opacity,
                    map: _outer._map, radius: this.radius,
                    strokeWeight:0, zIndex: this.zIndex
                };
            };
            Object.seal(this._CircularAlertZone);

            /**
             * A class that represents a circular alert zone.
             * @param paths - The polygon paths, an array of arrays of LatLng objects.
             * @param name - The user-defined name.
             * @param editable - Whether the zone is editable (resizable).
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @extends _AlertZone
             * @private
             */
            this._PolygonalAlertZone = function(paths,name,editable,opacity,colour,zIndex) {
                zIndex = 100;
                _outer._AlertZone.call(this,name,editable,opacity,colour,zIndex);
                this.setPaths(paths);
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
            };
            //Inherit the prototype of _AlertZone.
            this._inheritPrototype(this._PolygonalAlertZone, this._AlertZone);
            /**
             * Returns the shape in string format.
             */
            this._PolygonalAlertZone.prototype.getShape = function() {
                return 'polygon';
            };
            /**
             * Sets the paths and updates the shape overlay.
             */
            this._PolygonalAlertZone.prototype.setPaths = function(paths) {
                this.paths = paths;
                if (this.shapeOverlay) {
                    this.shapeOverlay.setPaths(paths);
                }
            };
            /**
             * Returns the options for building a google maps polygon.
             * @returns {*}
             * @private
             */
            this._PolygonalAlertZone.prototype._getShapeOverlayOpts = function() {
                return {
                    clickable: _outer.nodeName !== 'VOYENT-ALERT-VIEW', draggable: false,
                    editable:false, fillColor: '#'+this.colour,
                    fillOpacity: this.opacity, map: _outer._map,
                    strokeWeight:0, zIndex:this.zIndex, paths:this.paths
                };
            };
            Object.seal(this._PolygonalAlertZone);

            /**
             * A class that represents a user's fixed location record, both the drawn map entity and the json.
             * @param id - The system-generated id.
             * @param name - The user-defined name.
             * @param type - The type of location, one of home, business, school or other.
             * @param marker - The associated map marker.
             * @private
             */
            this._MyLocation = function(id,name,type,marker) {
                this.id = id || _outer._generateUid();
                this.setName(name || '');
                this.type = type || '';
                this.setMarker(marker);
            };
            /**
             * Sets the name and draws the nameOverlay.
             * @param name
             */
            this._MyLocation.prototype.setName = function (name) {
                this.name = name;
                if (this.nameOverlay) {
                    this.nameOverlay.draw();
                }
                else {
                    this.nameOverlay = new _outer._LocationOverlay(this);
                }
            };
            /**
             * Sets the marker and sets up relevant listeners.
             * @param marker
             */
            this._MyLocation.prototype.setMarker = function(marker) {
                this.marker = marker;
                this._setupMarkerListeners();
            };
            /**
             * Removes the location from the map.
             */
            this._MyLocation.prototype.removeFromMap = function() {
                this.marker.setMap(null);
                this.nameOverlay.setMap(null);
            };
            /**
             * Updates the JSON to reflect the current state of the template.
             * @private
             */
            this._MyLocation.prototype.updateJSON = function() {
                var markerPosition = this.marker.getPosition();
                this.json = {
                    "location": {
                        "geometry": {
                            "type": "Point",
                            "coordinates": [markerPosition.lng(),markerPosition.lat()]
                        },
                        "properties": {
                            "vras": {
                                "id": this.id,
                                "name": this.name,
                                "type": this.type
                            }
                        }
                    }
                }
            };
            /**
             * Initializes marker listeners.
             * @private
             */
            this._MyLocation.prototype._setupMarkerListeners = function() {
                if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                var _this = this;
                //Continuously re-draw the overlay as the location is dragged.
                var marker = this.marker;
                google.maps.event.addListener(marker,'drag',function() {
                    _this.nameOverlay.draw();
                });
                //Update the coordinates on the location record and flag the location for updating after it's dragged.
                google.maps.event.addListener(marker,'dragend',function() {
                    if (_outer._locationsToUpdate.indexOf(_this) === -1) {
                        _outer._locationsToUpdate.push(_this);
                    }
                    _outer._buttonsEnabled = true;
                });
                //Display infoWindow on location marker click.
                google.maps.event.addListener(marker,'click',function() {
                    _outer._toggleInfoWindow(_this);
                });
            };
            Object.seal(this._MyLocation);

            /**
             * A class that represents a zone name overlay.
             * @param zone - The zone for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._ProximityZoneOverlay = function(zone) {
                this.zone = zone;
                this.setMap(_outer._map);
            };
            /**
             * A class that represents a location name overlay.
             * @param location - The location for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._LocationOverlay = function(location) {
                this.loc = location;
                this.setMap(_outer._map);
            };
            //Inherit the prototype of google.maps.OverlayView.
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();
            this._LocationOverlay.prototype = new google.maps.OverlayView();
            /**
             * Called automatically when the map is ready for the overlay to be attached.
             */
            this._ProximityZoneOverlay.prototype.onAdd =
            this._LocationOverlay.prototype.onAdd = function () {
                //Setup the div.
                this.div = document.createElement('div');
                this.div.style.borderStyle = 'none';
                this.div.style.borderWidth = '0px';
                this.div.style.position = 'absolute';
                this.div.style.padding = '5px';
                this.div.style.fontSize = '8px';
                this.div.style.zIndex = 10000;
                this.div.style.opacity = 1.0;
                this.div.style.borderRadius = '25px';
                this.div.style.letterSpacing = '1px';
                // Add the element to the "overlayLayer" pane.
                this.getPanes().overlayLayer.appendChild(this.div);
            };
            /**
             * Handles drawing and re-drawing of the proximity zone overlay on the map.
             */
            this._ProximityZoneOverlay.prototype.draw = function() {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var northernCoordinate = this.zone.northernCoordinate;
                var nc = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(northernCoordinate[1],northernCoordinate[0])
                );
                //Set the div content.
                this.div.innerHTML = this.zone.name;
                //Center the label above the zone.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-20 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#'+this.zone.colour;
                this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
            };
            /**
             * Handles drawing and re-drawing of the location overlay on the map.
             */
            this._LocationOverlay.prototype.draw = function () {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(this.loc.marker.getPosition());
                //Set the div content.
                this.div.innerHTML = this.loc.name;
                //Center the label above the location.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-60 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#F96757';
                this.div.style.color = '#F5F5F5';
            };
            /**
             * Cleans up the overlay whenever the overlays map property is set to null.
             */
            this._ProximityZoneOverlay.prototype.onRemove =
            this._LocationOverlay.prototype.onRemove = function () {
                    this.div.parentNode.removeChild(this.div);
                    this.div = null;
            };
            /**
             * Hide the overlay.
             */
            this._LocationOverlay.prototype.hide = function() {
                this.div.style.display = 'none';
            };
            /**
             * Re-display the overlay.
             */
            this._LocationOverlay.prototype.displayAndDraw = function() {
                this.div.style.display = 'block';
                this.draw();
            };
            /**
             * Returns a font colour of black or white based on the zone colour.
             */
            this._ProximityZoneOverlay.prototype.returnColourBasedOnBackground = function(hex) {
                //Convert 3 digits to 6.
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                //Just return black if we receive an invalid colour.
                if (hex.length !== 6) {
                    return '#000';
                }
                //Calculate
                var r = parseInt(hex.slice(0, 2), 16),
                    g = parseInt(hex.slice(2, 4), 16),
                    b = parseInt(hex.slice(4, 6), 16);
                return (r * 0.299 + g * 0.587 + b * 0.114) > 186
                    ? '#000'
                    : '#FFF';
            };
            Object.seal(this._ProximityZoneOverlay);
            Object.seal(this._LocationOverlay);
        }
    };
</script>