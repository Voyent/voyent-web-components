<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {
        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'},
            /**
             * The location host for convenience of linking.
             */
            locationHost: { type: String, value: window.location.host }
        },

        ready: function() {
            this._loadedAlert = null;
            //Define some constants.
            //The number of coordinates circular polygons will have.
            this._NUM_CIRCULAR_POLY_SIDES = 100;
            //The number of degrees in which each coordinate will be spaced apart.
            this._CIRCULAR_POLY_DEGREE_STEP = 360 / this._NUM_CIRCULAR_POLY_SIDES;
            //The id of the fallback zone under the properties section.
            this._FALLBACK_ZONE_ID = 'fallback_zone';
            //My Location icons.
            this._MY_LOCATION_ICON_INACTIVE = this.pathtoimages+'/img/green_marker_circle.png';
            this._MY_LOCATION_ICON_ACTIVE = this.pathtoimages+'/img/green_marker_star.png';
            //Messages.
            this._OVERLAP_WITHIN_STACK_MSG = 'The zone cannot overlap other zones in the stack';
        },

        getBadgeUrl: function(badgeName) {
            var url = window.location.protocol + '//' + this.locationHost + '/vras/images/badges/';
            if (badgeName && typeof badgeName === 'string') {
                url += badgeName;
            }
            else {
                url += 'info.png';
            }
            return url;
        },

        /**
         * Displays the zone properties for the zone matching the passed id.
         */
        selectZoneById: function(zoneId) {
            if (!this._loadedAlert || !this._loadedAlert.template.zoneStacks) { return; }
            for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                var zoneStack = this._loadedAlert.template.zoneStacks[i];
                var zone = zoneStack.getZoneById(zoneId);
                if (zone) {
                    if (!zone.active) {
                        if (zoneStack !== this._loadedAlert.selectedStack) {
                            this._toggleProperties(null);
                            this.set('_loadedAlert.selectedStack',zoneStack);
                        }
                        this._toggleProperties(zone);
                        return;
                    }
                }
                else {
                    if (this._fallbackZone && this._fallbackZone.id === zoneId && !this._fallbackZone.active) {
                        this._toggleFallbackZoneProperties();
                        return;
                    }
                }
            }
        },

        /**
         * Validates the currently loaded alert template and returns all errors and warnings in the response.
         * @returns {Object} - {"errors": [], "warnings": []}
         */
        validate: function() {
            var results = { errors: [], warnings: [] };
            if (!this._loadedAlert || !this._loadedAlert.template ||
                (!this._loadedAlert.template.zoneStacks.length && (!this._fallbackZone || !this._fallbackZone.enabled))) {
                results.errors.push('Must define at least one zone');
            }
            else {
                // Restrict JSON size to 250KB
                this._loadedAlert.template.updateJSON();
                if (JSON.stringify(this._loadedAlert.template.json).length > 250000) {
                    var templateTxt = this.nodeName === 'VOYENT-ALERT-EDITOR' ? '' : 'template';
                    results.errors.push('This alert ' + templateTxt + ' is too large, try reducing the size of the message contents or complexity of zones');
                }
            }
            if (this.nodeName === 'VOYENT-ALERT-EDITOR') {
                //Ensure we have both movement parameters or none at all.
                if (this._alertSpeed && (!this._alertDirection && this._alertDirection !== 0)) {
                    results.errors.push('Moving alerts must have both a speed and direction defined (direction is missing)');
                }
                if (!this._alertSpeed && (this._alertDirection || this._alertDirection === 0)) {
                    results.errors.push('Moving alerts must have both a speed and direction defined (speed is missing)');
                }
                //Restrict moving alerts to a maximum of two zones, excluding the fallback zone.
                if (this._alertSpeed && (this._alertDirection || this._alertDirection === 0)) {
                    var zoneCount = 0;
                    for (var i=0; i<this._loadedAlert.template.zoneStacks.length; i++) {
                        zoneCount += this._loadedAlert.template.zoneStacks[i].zones.length;
                    }
                    if (zoneCount > 2) {
                        results.errors.push('Moving alerts are restricted to a maximum of two zones');
                    }
                }
            }
            return results;
        },

        /**
         * Saves or updates the current alert template.
         */
        saveAlertTemplate: function() {
            this._saveAlertTemplate().catch(function(e){})
        },

        /**
         * Wrapped function for `saveAlertTemplate` that returns a Promise for internal component use.
         * @returns {Promise}
         * @private
         */
        _saveAlertTemplate: function () {
            var _this = this, msg;
            return new Promise(function (resolve, reject) {
                if (_this._savingAlertTemplate) { return reject('already saving template'); }
                //Prompt the user if no categories are defined for the template.
                if (!_this._skipCategoryValidation &&
                    (!_this._loadedAlert.template.categories || !_this._loadedAlert.template.categories.length)) {
                    _this._openUncategorizedTemplateDialog();
                    return reject('no categories provided');
                }
                _this._savingAlertTemplate = true;
                _this._loadedAlert.template.updateJSON();
                var requestOpts = {realm: _this.realm, account: _this.account, alertTemplate: _this._loadedAlert.template.json};
                var func = 'createAlertTemplate';
                if (_this._loadedAlert.template.id) {
                    func = 'updateAlertTemplate';
                    requestOpts.id = _this._loadedAlert.template.id
                }
                voyent.locate[func](requestOpts).then(function (uri) {
                    _this._savingAlertTemplate = false;
                    if (func === 'createAlertTemplate') {
                        _this._loadedAlert.template.setId(uri.split('/').pop());
                        _this.fire('message-info', 'Alert template successfully created');
                    }
                    else {
                        _this.fire('message-info', 'Alert template successfully updated');
                    }
                    _this.fire('voyent-alert-template-saved',{});
                    resolve();
                }).catch(function(e) {
                    _this._savingAlertTemplate = false;
                    _this.fire('message-error', 'Issue saving alert template: ' + (e.responseText || e.message || e));
                    reject(msg);
                });
            });
        },

        /**
         * Wrapper for `_saveAlertTemplate` that disables prompt for unspecified template categories.
         * @private
         */
        _saveAlertTemplateWithoutCategory: function() {
            var _this = this;
            this._skipCategoryValidation = true;
            this._closeUncategorizedTemplateDialog();
            this._saveAlertTemplate().then(function() {
                _this._skipCategoryValidation = false;
            });
        },

        /**
         * Builds the location JSON for the currently loaded alert.
         * @private
         */
        _buildAlertLocationJSON: function() {
            var pos;
            if (this._loadedAlert.template.zoneStacks.length > 0) {
                pos = this._AlertTemplate.calculateCentroidFromJSON(this._loadedAlert.template.json);
            }
            else {
                // No stacks means we have no centroid, fallback zone only
                pos = new google.maps.LatLng(0,0);
            }
            return {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : [pos.lng(),pos.lat()] },
                    "properties": {
                        "alertId": this._loadedAlert.template.id
                    },
                    "type": "Feature"
                }
            };
        },

        /**
         * Returns the rectangular path around the bounds of the polygon path.
         * @param path
         * @returns {google.maps.MVCArray}
         * @private
         */
        _getRectangularPathFromPolygonPath: function(path) {
            var bounds = new google.maps.LatLngBounds();
            path.forEach(function (element) {
                bounds.extend(element);
            });
            var ne = bounds.getNorthEast();
            var sw = bounds.getSouthWest();

            return new google.maps.MVCArray([new google.maps.MVCArray([ne,new google.maps.LatLng(sw.lat(),ne.lng()),sw,new google.maps.LatLng(ne.lat(),sw.lng())])]);
        },

        /**
         * Selects the passed zone.
         * @param zoneStack
         * @param zone
         */
        _selectZone: function(zoneStack, zone) {
            // If either the zoneStack or zone are not provided then deselect all stacks/zones
            if (!zoneStack || !zone) {
                this._toggleProperties(null);
                this.set('_loadedAlert.selectedStack',null);
            }
            //If they click a zone for the currently active stack then toggle the accordion.
            else if (this._loadedAlert.selectedStack && this._loadedAlert.selectedStack === zoneStack) {
                // Don't allow de-selecting the zone
                if (!zone.active) {
                    this._toggleProperties(zone);
                }
            }
            else {
                //Toggle the accordion for the previously selected stack.
                this._toggleProperties(null);
                //Load the selected stack and toggle the selected zone.
                this.set('_loadedAlert.selectedStack',zoneStack);
                this._toggleProperties(zone);
            }
        },

        /**
         * Toggles the zone properties section from the side panel.
         * @param e
         * @private
         */
        _togglePropertiesFromSidePanel: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            var zone = zoneStack.getZoneAt(e.model.get('zoneIndex'));
            this._selectZone(zoneStack, zone);
        },

        /**
         * Toggles the zone properties section. This is triggered directly when selecting a proximity
         * zone or from a wrapper function when clicking the accordion pane. In addition to toggling
         * the panes this will also trigger styling updates to zones overlays on the map.
         * @param zone - The zone to toggle properties for.
         * @private
         */
        _toggleProperties: function(zone) {
            if (!this._loadedAlert || !this._loadedAlert.template) { return; }

            // If they toggle the currently toggled accordion pane then we'll close it
            if (zone && zone.active) {
                zone = null;
            }
            // If the fallback zone is active then deactivate it
            if (this._fallbackZone && this._fallbackZone.active) {
                this._toggleFallbackZoneProperties(true);
            }
            else { // Otherwise deactivate all zone overlays
                this._loadedAlert.template.deactivateZoneStackOverlays();
            }
            // Fire the appropriate events
            if (zone) {
                zone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": zone.id,
                    "zone": zone,
                    "isFallbackZone": false
                });
                this._scrollToActivePane();
            }
            else {
                this.fire('voyent-alert-zone-selected',{
                    "id": null,
                    "zone": null,
                    "isFallbackZone": false
                });
            }
        },

        /**
         * Toggles the fallback zone properties section.
         * @param skipEvent
         * @private
         */
        _toggleFallbackZoneProperties: function(skipEvent) {
            if (this._fallbackZone.active) {
                this._fallbackZone.setActive(false);
                if (typeof skipEvent !== 'boolean' || !skipEvent) {
                    this.fire('voyent-alert-zone-selected',{
                        "id": null,
                        "zone": null,
                        "isFallbackZone": true
                    });
                }
            }
            else {
                if (this._loadedAlert && this._loadedAlert.selectedStack) {
                    this._loadedAlert.selectedStack.deactivateZoneOverlays();
                }
                this._fallbackZone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": this._fallbackZone.id,
                    "zone": this._fallbackZone,
                    "isFallbackZone": true
                });
                this._scrollToTop();
            }
        },

        /**
         * Toggles the movement properties section.
         * @private
         */
        _toggleMovement: function() {
            this._showMovement = !this._showMovement;
            this._scrollToBottom();
        },

        /**
         * Scrolls the properties panel to the currently active pane.
         * @private
         */
        _scrollToActivePane: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        var propertiesComp = propertiesPanel.querySelector('voyent-alert-properties');
                        if (propertiesComp) {
                            var activeZone = propertiesComp.querySelector('.header.active');
                            if (activeZone) {
                                propertiesPanel.scrollTop = activeZone.offsetTop;
                            }
                        }
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Scrolls the properties panel to the top.
         * @private
         */
        _scrollToTop: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        propertiesPanel.scrollTop = 0;
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Scrolls the properties panel to the bottom.
         * @private
         */
        _scrollToBottom: function() {
            var _this = this;
            setTimeout(function() {
                // This may be triggered from one of the alert editor component or from the properties
                // component so determine which one and find the component we need based on that
                var alertEditorComp = _this.nodeName === 'VOYENT-ALERT-PROPERTIES'
                    ? document.querySelector(_this.parentIsAlertEditor ? 'voyent-alert-editor' : 'voyent-alert-template-editor')
                    : _this;
                if (alertEditorComp) {
                    var propertiesPanel = alertEditorComp.querySelector('#propertiesPanel');
                    if (propertiesPanel) {
                        propertiesPanel.scrollTop = propertiesPanel.scrollHeight;
                    }
                }
            },300); // 300ms to match CSS height transition time
        },

        /**
         * Toggles the badge properties section.
         * @private
         */
        _toggleBadge: function() {
            this._showBadge = !this._showBadge;
        },

        /**
         * Add mouseover styling to zone when mousing over it in side panel.
         * @param e
         * @private
         */
        _mouseoverZoneProperties: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            this._mouseoverZone(zoneStack.getZoneAt(e.model.get('zoneIndex'), false));
        },

        /**
         * Adds mouseover styling for the passed zone.
         * @param zone
         * @param showMarker
         * @private
         */
        _mouseoverZone: function(zone, showMarker) {
            zone.highlightOverlay(!!showMarker);
        },

        /**
         * Removes mouseover styling from a zone when mousing over it in side panel.
         * @param e
         * @private
         */
        _mouseoutZoneProperties: function(e) {
            var zoneStack = this._loadedAlert.template.getZoneStackAt(e.model.get('zoneStackIndex'));
            this._mouseoutZone(zoneStack.getZoneAt(e.model.get('zoneIndex')));
        },

        /**
         * Removes mouseover styling from the passed zone.
         * @param zone
         * @private
         */
        _mouseoutZone: function(zone) {
            zone.unHighlightOverlay();
        },

        /**
         * Converts the passed mouse event to a latLng coordinate on the map.
         * @param e
         * @private
         */
        _fromMouseEventToLatLng: function(e) {
            if (e && typeof e.clientX === 'number' && typeof e.clientY === 'number' && this._map && this._map.getProjection) {
                var rect = this._map.getDiv().getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                return this._overlayView && this._overlayView.getProjection()
                    ? this._overlayView.getProjection().fromContainerPixelToLatLng(new google.maps.Point(x, y))
                    : null;
            }
        },

        /**
         * Creates and configures the styling for a generic overlay div, used for various labels.
         * @param extraRound
         * @param noFontStyling
         * @param translucent
         * @private
         */
        _buildOverlayDiv: function(extraRound, noFontStyling, translucent) {
            var div = document.createElement('div');
            if (!noFontStyling) {
                div.style.fontSize = '12px';
                div.style.fontWeight = 'bold';
            }
            div.style.position = 'absolute';
            div.style.padding = '5px';
            div.style.zIndex = '10000';
            div.style.borderRadius =  (extraRound ? '25' : '7') + 'px';
            div.style.letterSpacing = '1px';
            div.style.whiteSpace = 'nowrap';
            if (translucent) {
                div.style.opacity = '0.25';
            }
            return div;
        },

        /**
         * Creates and configures the styling and listeners for the distance between points overlay.
         * @param zone - The zone that the overlay is being created for.
         * @private
         */
        _buildDistanceBetweenPointsOverlayDiv: function(zone) {
            var _this = this;

            var mainDiv = this._buildOverlayDiv(false, true);
            var distanceInput = document.createElement('input');
            var metersSpan = document.createElement('span');

            mainDiv.style.textAlign = 'center';
            mainDiv.style.minWidth = '51px';
            mainDiv.style.border = '2px solid transparent';
            mainDiv.style.cursor = 'pointer';
            // Prevent the event form bubbling so the zone is not de-selected and the map zoomed
            mainDiv.onclick = mainDiv.ondblclick = function(e) {
                e.stopPropagation();
                distanceInput.focus();
            };
            // Add some highlight styling to the overlay on mouseover
            mainDiv.onmouseover = function() {
                zone.distanceBetweenPointsOverlay.highlight();
            };
            // Restore original overlay styling on mouseout
            mainDiv.onmouseout = function() {
                zone.distanceBetweenPointsOverlay.unHighlight();
            };
            // Set some styling on the input
            distanceInput.style.color = 'inherit';
            distanceInput.style.borderRadius = '7px';
            distanceInput.style.padding = '3px 6px 3px 0px';
            distanceInput.style.border = 'none';
            distanceInput.style.outline = 'none';
            distanceInput.style.backgroundColor = 'transparent';
            distanceInput.oninput = function() {
                this.style.width = this.value.length + 'ch';
            };
            // Prevent the user from entering non-numerical keys
            distanceInput.onkeypress = function(e) {
                if (['0','1','2','3','4','5','6','7','8','9'].indexOf(e.key) === -1) {
                    e.preventDefault();
                    return false;
                }
            };
            // Submit the new radius value on enter key presses
            distanceInput.onkeyup = function(e) {
                if (e.key === 'Enter') {
                    submitDistanceValue();
                }
                else if (e.key === 'Escape') {
                    revertDistanceValue();
                }
            };
            // Ensure the cancel / confirm buttons are displayed when the input is focused
            distanceInput.onfocus = function() {
                zone.distanceBetweenPointsOverlay.enableEditingMode();
            };
            mainDiv.appendChild(distanceInput);

            // Add the "meters" abbreviation after the input
            metersSpan.style.marginLeft = '-6px';
            metersSpan.innerText = 'm';
            mainDiv.appendChild(metersSpan);

            // Add the cancel / confirm buttons
            mainDiv.appendChild(this._buildButtonsDiv(submitDistanceValue, revertDistanceValue));

            // Submits the new distance value
            function submitDistanceValue() {
                var stack = _this._loadedAlert.selectedStack;
                var zoneIndex = stack.getZoneIndex(zone);
                var smallerZone = stack.getZoneAt(zoneIndex - 1);
                var largerZone = stack.getZoneAt(zoneIndex + 1);
                var newDistance = parseInt(distanceInput.value);
                if (newDistance < 5) {
                    newDistance = 5;
                }
                var paths = zone.shapeOverlay.getPaths();
                if (zone.isCircle) {
                    if (smallerZone) {
                        var smallerZoneRadius = smallerZone.getPolylineLengthInMeters();
                        if (newDistance <= smallerZoneRadius) {
                            _this.fire('message-error', 'Zone radius cannot be smaller than ' + parseInt((smallerZoneRadius+1)) + 'm');
                            zone.distanceBetweenPointsOverlay.draw();
                            return;
                        }
                    }
                    if (largerZone) {
                        var largerZoneRadius = largerZone.getPolylineLengthInMeters();
                        if (newDistance >= largerZoneRadius) {
                            _this.fire('message-error', 'Zone radius cannot be larger than ' + parseInt((largerZoneRadius-1)) + 'm');
                            zone.distanceBetweenPointsOverlay.draw();
                            return;
                        }
                    }

                    // Set the new paths and adjust the position of the overlay
                    zone.setPaths(_this._adjustDistanceFromCentroid(paths, newDistance));
                    zone.manageCircleDistanceBetweenPointsOverlay();
                    // Since we set the paths of the zone to a non-punched out shape we must punch out the zones again
                    stack.updateJSONAndCentroid();
                    stack.punchOutShapes();
                    // Since we adjusted the size of the larger zone we'll update
                    // the template JSON and punch out the fallback zone
                    if (!largerZone) {
                        _this._loadedAlert.template.updateJSONAndCentroid();
                        if (_this._fallbackZone) {
                            _this._fallbackZone.punchOutOverlay();
                        }
                    }
                }
                else {
                    _this._expandDistanceFromCenter(
                        stack, zone, stack.marker.getPosition(), null, null, newDistance, !smallerZone
                    );
                }
                // Keep the zoom level appropriate for the size of the zone
                _this._panToZone(zone);
                // Disable editing mode
                disableEditing();
            }

            // Reverts the distance value to the current one
            function revertDistanceValue() {
                // Revert the value
                zone.distanceBetweenPointsOverlay.draw();
                // Disable editing mode
                disableEditing();
            }

            // Disables editing mode styling
            function disableEditing() {
                // setTimeout so the overlay redraws first after value change
                setTimeout(function() {
                    zone.distanceBetweenPointsOverlay.disableEditingMode();
                },0);
            }

            return mainDiv;
        },

        /**
         * Expands the distance between the vertex and the centroid to be the specified distance apart. This function may
         * be called recursively for the innermost zone because after adjusting the distance between the vertex and the
         * centroid the shape of the polygon may change in such a way that the centroid position changes, so the new
         * point will be x meters away from the old centroid not the new one.
         * @param stack - The stack being operated on.
         * @param zone - The zone being operated on.
         * @param centroid - The center point of the stack.
         * @param vertexPosition - The current position of the vertex.
         * @param opType - The vertex operation type (insertAt or setAt).
         * @param distance - The distance, in meters, that we want the vertex to be from the center point.
         * @param isInnerMostZone
         */
        _expandDistanceFromCenter: function(stack, zone, centroid, vertexPosition, opType, distance, isInnerMostZone) {
            var vertexIndex = this._activeVertexDetails.index;
            vertexPosition = vertexPosition || this._activeVertexDetails.latLng;
            opType = opType || this._activeVertexDetails.type;
            var paths = zone.shapeOverlay.getPaths();
            // Calculate the bearing from the passed coordinate to the vertex being modified
            var bearing = google.maps.geometry.spherical.computeHeading(centroid, vertexPosition);
            // Calculate the new coordinate that is x meters from the centroid
            var newLatLng = google.maps.geometry.spherical.computeOffset(centroid, distance, bearing);
            // Update an existing vertex or insert a new one as required
            try {
                paths.getAt(0)[opType](vertexIndex, newLatLng);
            }
            catch (e) {
                // If a setAt operation fails and the vertex is removed because the original opType was insertAt,
                // then the vertex will be removed and the setAt operation will throw an error so we will catch it
                // and ignore it
            }

            // The setAt and insertAt calls above will trigger the polyAtListener which will
            // validate whether the vertex move operation was valid and revert if necessary.
            // If this occurs we will stop processing and revert the template state
            if (this._haveVertexError) {
                this.set('_haveVertexError', false);
                stack.updateTemplateAfterVertexModification(zone, this._activeVertexDetails.latLng);
                return;
            }

            // Recursively recalculate the distance between the new center and the vertex until
            // it is x meters away from the center. This only applies to the innermost zone since
            // modifying the shape of it may cause the center point of the stack to change
            if (isInnerMostZone) {
                centroid = this._AlertTemplate.calculateCentroidFromPaths(paths);
                var newDistance = Math.round(google.maps.geometry.spherical.computeDistanceBetween(centroid, newLatLng));
                if (distance !== newDistance) {
                    // Even if a new index was inserted above (opType=insertAt) we always want subsequent
                    // operations to be setAt since the new vertex will now exist on the polygon paths and
                    // using insertAt again would continuously create a new vertex
                    this._expandDistanceFromCenter(stack, zone, centroid, newLatLng, 'setAt', distance, isInnerMostZone);
                    return;
                }
            }

            // Store the previous vertex position in case we need to revert
            this.set('_activeVertexDetails', {
                zone: zone,
                latLng: newLatLng,
                index: vertexIndex,
                type: 'setAt'
            });
        },

        /**
         * Creates and configures the styling and listeners for the coordinate overlay.
         * @param stack - The stack that the overlay is for.
         * @private
         */
        _buildCoordinateOverlayDiv: function(stack) {
            var _this = this;

            var mainDiv = this._buildOverlayDiv(false, true);
            var latDivWrapper = document.createElement('div');
            var latSpan = document.createElement('span');
            var latInput = document.createElement('input');
            var lngDivWrapper = document.createElement('div');
            var lngSpan = document.createElement('span');
            var lngInput = document.createElement('input');

            // Set some styling
            mainDiv.style.border = '2px solid transparent';
            mainDiv.style.cursor = 'pointer';
            latDivWrapper.style.cursor = lngDivWrapper.style.cursor = 'text';
            latInput.className = 'lat';
            lngInput.className = 'lng';
            latInput.style.border = lngInput.style.border = 'none';
            latInput.style.outline = lngInput.style.outline = 'none';
            latInput.style.backgroundColor = lngInput.style.backgroundColor = 'transparent';
            latInput.style.color = lngInput.style.color = 'inherit';

            // Add some highlight styling to the overlay on mouseover
            mainDiv.onmouseover  = function() {
                stack.coordinateOverlay.highlight();
            };
            // Restore original overlay styling on mouseout
            mainDiv.onmouseout = function() {
                stack.coordinateOverlay.unHighlight();
            };

            // Prevent the event form bubbling so the map doesn't zoom, focus the
            // input, and ensure the cancel / confirm buttons are displayed
            latDivWrapper.onclick = latDivWrapper.ondblclick = latSpan.onclick =
            latSpan.ondblclick = latInput.onclick = latInput.ondblclick = function(e) {
                e.stopPropagation();
                latInput.focus();
                stack.coordinateOverlay.enableEditingMode();
            };
            lngDivWrapper.onclick = lngDivWrapper.ondblclick = lngSpan.onclick =
            lngSpan.ondblclick = lngInput.onclick = lngInput.ondblclick = function(e) {
                e.stopPropagation();
                lngInput.focus();
                stack.coordinateOverlay.enableEditingMode();
            };

            // Prevent the user from entering unsupported keys
            latInput.onkeypress = lngInput.onkeypress = function(e) {
                if (['0','1','2','3','4','5','6','7','8','9','.','-'].indexOf(e.key) === -1) {
                    e.preventDefault();
                    return false;
                }
            };

            // Submit the new lat/lng value on enter key presses
            latInput.onkeyup = lngInput.onkeyup = function(e) {
                if (e.key === 'Enter') {
                    submitCoordinateValues();
                }
                else if (e.key === 'Escape') {
                    revertCoordinateValues();
                }
            };

            // Add the "Lat" label before the input
            latSpan.innerText = 'Lat: ';
            latDivWrapper.appendChild(latSpan);
            latDivWrapper.appendChild(latInput);
            mainDiv.appendChild(latDivWrapper);

            // Add the "Lng" label before the input
            lngSpan.innerText = 'Lng: ';
            lngDivWrapper.appendChild(lngSpan);
            lngDivWrapper.appendChild(lngInput);
            mainDiv.appendChild(lngDivWrapper);

            // Add the cancel / confirm buttons
            mainDiv.appendChild(this._buildButtonsDiv(submitCoordinateValues, revertCoordinateValues));

            // Submits the new coordinate values
            function submitCoordinateValues() {
                var latVal = parseFloat(latInput.value);
                if (latVal > 90 || latVal < -90) {
                    _this.fire('message-error', 'Latitude cannot be less than or greater than 90');
                    latInput.value = stack.lat;
                    return;
                }
                var lngVal = parseFloat(lngInput.value);
                if (lngVal > 180 || lngVal < -180) {
                    _this.fire('message-error', 'Longitude cannot be less than or greater than 180');
                    lngInput.value = stack.lng;
                    return;
                }
                stack.updateMarkerPosition(latVal, lngVal);

                // Keep the stack in view
                _this._panToZone(stack.getOutermostZone());
                // Disable editing mode
                disableEditing();
            }

            // Reverts the coordinate values to the the current ones
            function revertCoordinateValues() {
                // Revert the value
                stack.coordinateOverlay.draw();
                // Disable editing mode
                disableEditing();
            }

            // Disables editing mode styling
            function disableEditing() {
                // setTimeout so the overlay redraws first after value change
                setTimeout(function() {
                    stack.coordinateOverlay.disableEditingMode();
                },0);
            }
            return mainDiv;
        },

        /**
         * Creates and configures the styling and listeners for the image overlay.
         * @param imgUrl
         * @param imgDimensions
         * @param onclickListener
         * @private
         */
        _buildImageOverlayDiv: function(imgUrl, imgDimensions, onclickListener) {
            var mainDiv = document.createElement('div');
            mainDiv.style.position = 'absolute';
            mainDiv.style.cursor = 'pointer';
            mainDiv.onclick = function(e) {
                // Prevent the event form bubbling so the map doesn't zoom
                e.stopPropagation();
                if (typeof onclickListener === 'function') {
                    onclickListener(e);
                }
            };

            var img = document.createElement('img');
            img.src = imgUrl;
            img.style.width = imgDimensions.width || '100%';
            img.style.height = imgDimensions.height || '100%';

            mainDiv.appendChild(img);
            return { div: mainDiv, img: img }
        },

        /**
         * Adjusts the distance from the centroid for every coordinate to be the passed distance. This must only be used
         * for circles since all of the coordinates will be the same distance from the centroid. Only does the outer path,
         * the shape must be punched out again after.
         * @param paths
         * @param distance
         * @returns {google.maps.MVCArray}
         * @private
         */
        _adjustDistanceFromCentroid: function(paths,distance) {
            var centroid = this._AlertTemplate.calculateCentroidFromPaths(paths);
            var bearing, newPath = [];
            for (var j=0; j<paths.getAt(0).length; j++) {
                // Calculate the bearing from the center to each point
                bearing = google.maps.geometry.spherical.computeHeading(centroid,paths.getAt(0).getAt(j));
                // Calculate the new coordinate
                newPath.push(google.maps.geometry.spherical.computeOffset(centroid,distance,bearing));
            }
            return new google.maps.MVCArray([new google.maps.MVCArray(newPath)])
        },

        /**
         * Builds and returns a div containing ✔ and ✖ buttons.
         * @param confirmListener
         * @param cancelListener
         */
        _buildButtonsDiv: function(confirmListener, cancelListener) {
            var buttonsDiv = document.createElement('div');
            var cancelButton = document.createElement('button');
            var confirmButton = document.createElement('button');

            buttonsDiv.className = 'buttons';
            buttonsDiv.style.marginTop = '5px';
            buttonsDiv.style.display = 'none';
            buttonsDiv.style.textAlign = 'center';
            confirmButton.innerHTML = '✔';
            cancelButton.innerHTML = '✖';
            cancelButton.style.backgroundColor = confirmButton.style.backgroundColor = 'transparent';
            cancelButton.style.border = confirmButton.style.border = 'none';
            cancelButton.style.color = confirmButton.style.color = 'inherit';
            cancelButton.style.cursor = confirmButton.style.cursor = 'pointer';
            confirmButton.style.marginLeft = '5px';
            confirmButton.onclick = function(e) {
                e.stopPropagation();
                if (typeof confirmListener === 'function') {
                    confirmListener(e);
                }
            };
            cancelButton.onclick = function(e) {
                e.stopPropagation();
                if (typeof cancelListener === 'function') {
                    cancelListener(e);
                }
            };
            buttonsDiv.appendChild(cancelButton);
            buttonsDiv.appendChild(confirmButton);

            return buttonsDiv;
        },

        /**
         * Opens the dialog and sets various properties to be used later.
         * @param title
         * @param message
         * @param inputVal
         * @param inputMsg
         * @param toggleLabel
         * @param showBadge
         * @param showCategoryPicker
         * @param confirmFunc
         * @param cancelFunc
         * @private
         */
        _openDialog: function(title,message,inputVal,inputMsg,toggleLabel,showBadge,showCategoryPicker,confirmFunc,cancelFunc) {
            var dialog = this.querySelector('#modalDialog');
            if (!dialog) { return; }
            // Store all dialog properties so the dialog renders properly
            this._dialogTitle = title;
            this._dialogMessage = message;
            this._dialogInput = inputVal;
            this._showDialogInput = (typeof inputVal !== 'undefined' && inputVal !== null);
            this._dialogInputMsg = inputMsg || 'Enter a value';
            this._dialogToggleLabel = toggleLabel;
            this._showDialogToggle = !!toggleLabel;
            this._dialogToggle = false;
            this._showDialogBadge = !!showBadge;
            if (this._showDialogBadge) {
                this._dialogBadge = "info.png";
                if (this._loadedAlert && this._loadedAlert.template && this._loadedAlert.template.badge) {
                    this._dialogBadge = this._loadedAlert.template.badge;
                }
                // When using the badge chooser we need to be sure to resize and center the dialog
                // after the badges have loaded so the dialog renders in the correct position
                if (!this._dialogBadgeListener) {
                    this._dialogBadgeListener = document.addEventListener('voyent-alert-badge-chooser-ready',function() {
                        dialog.notifyResize();
                        dialog.center();
                    });
                }
            }
            this._dialogConfirmFunc = confirmFunc;
            this._dialogCancelFunc = cancelFunc;
            // Open the dialog
            dialog.open();
            // Ensure that our dialog is sized and positioned correctly
            if (!this._showDialogBadge) {
                setTimeout(function() {
                    dialog.notifyResize();
                    dialog.center();
                },0);
            }
            // If there's no input rendered in the dialog then focus on the dialog so we
            // can capture the user's key presses. The input will focus automatically
            if (!this._showDialogInput) {
                setTimeout(function() {
                    dialog.focus();
                },200);
            }
        },

        /**
         * Handles dialog input validation and calling the confirmation function if available.
         * @private
         */
        _confirmDialog: function() {
            //Validate the input.
            if (this._showDialogInput && (!this._dialogInput ||
                    !this._dialogInput.trim())) {
                this.fire('message-error', this._dialogInputMsg);
                return;
            }
            //We allow for passing the confirm function directly or as a string.
            if (this._dialogConfirmFunc) {
                if (typeof this._dialogConfirmFunc === 'string') { this[this._dialogConfirmFunc](); }
                else { this._dialogConfirmFunc(); }
            }
            //Close the dialog after.
            this.closeDialog(true);
        },

        /**
         * Handles closing the dialog and calling the cancel function if available.
         * @param confirmed
         * @private
         */
        closeDialog: function(confirmed) {
            confirmed = typeof confirmed === 'boolean' ? confirmed : false;

            //Only call the cancel function if this is triggered by a cancel.
            //We allow passing the confirm function directly or as a string.
            if (!confirmed && this._dialogCancelFunc) {
                if (typeof this._dialogCancelFunc === 'string') { this[this._dialogCancelFunc](); }
                else { this._dialogCancelFunc(); }
            }

            if (this.querySelector('#modalDialog')) {
                this.querySelector('#modalDialog').close();
            }
        },

        /**
         * Handles enter key presses when the dialog is focused.
         * @param e
         * @private
         */
        _dialogKeyUp: function(e) {
            //Prevent the event from bubbling.
            e.stopPropagation();
            if (e.key === 'Enter') { //Enter
                this._confirmDialog();
            }
        },

        /**
         * Opens the category picker dialog.
         * @private
         */
        _openCategorySelector: function() {
            var _this = this;
            var dialog = this.querySelector('#categoryManager');
            if (dialog) {
                dialog.open();
                this.set('_categorySearchQuery','');
                this.set('_filteredTemplateCategories',_this._templateCategories.slice(0));
                this.set('_selectedCategories',this._loadedAlert ?
                    function(categories) {
                        var selectedCategories = [];
                        for (var i=0; i<_this._templateCategories.length; i++) {
                            if (categories.indexOf(_this._templateCategories[i].name) > -1) {
                                selectedCategories.push(_this._templateCategories[i]);
                            }
                        }
                        return selectedCategories;
                    }(this._loadedAlert.template.categories) :
                    []
                );
                setTimeout(function() {
                    var categoryWrapper = document.querySelector('.category-wrapper');
                    if (categoryWrapper) {
                        categoryWrapper.scrollTop = 0;
                    }
                },0);
            }
        },

        /**
         * Closes the category picker dialog.
         */
        closeCategorySelector: function() {
            this.set('_showCategoryManager',false);
            var dialog = this.querySelector('#categoryManager');
            if (dialog) {
                dialog.close();
            }
        },

        /**
         * Confirms category selection changes made in the category picker dialog.
         * @private
         */
        _confirmCategorySelector: function() {
            this._loadedAlert.template.setCategories(this._selectedCategories.map(function(categoryObj) {
                return categoryObj.name;
            }));
            if (this._templateSavePending) {
                this.saveAlertTemplate();
                this._templateSavePending = false;
            }
            this.closeCategorySelector();
        },

        /**
         * Opens a prompt message during a save when no categories are specified for a template.
         * @private
         */
        _openUncategorizedTemplateDialog: function() {
            var dialog = this.querySelector('#uncategorizedTemplate');
            if (dialog) {
                dialog.open();
            }
        },

        /**
         * Closes the prompt message displayed during a save when no categories are specified for a template.
         * @private
         */
        _closeUncategorizedTemplateDialog: function() {
            var dialog = this.querySelector('#uncategorizedTemplate');
            if (dialog) {
                dialog.close();
            }
        },

        /**
         * Opens the category picker dialog so the user can define template categories before saving.
         * @private
         */
        _openCategorySelectorBeforeSave: function() {
            this._templateSavePending = true;
            this._closeUncategorizedTemplateDialog();
            this._openCategorySelector();
        },

        /**
         * Force the paper-dialog to modal the entire page properly regardless of stacking context
         * See https://github.com/PolymerElements/paper-dialog/issues/7
         */
        _patchOverlay: function (e) {
            // To match our custom overlays below we drop the transition from the central overlay
            if (e.target.backdropElement) {
                e.target.backdropElement.style.transitionProperty = 'none';
                e.target.backdropElement.style.transition = 'all 0s ease 0s';
            }

            // So some real complexity here for paper-dialog because of stacking context:
            // Dialogs defined at the top level (like in app-view itself) will work as desired
            // But if we use a dialog without any changes that is defined in a subview (so out of context from the main <body>)
            //  then the modal will overlay the entire page, BUT the dialog will be underneath it
            // So then below we do "insertBefore" to move the overlay to directly before the dialog that it belongs to
            // This introduces another problem because the overlay is now on a subpage, so it doesn't block the menu navigation that is at a higher stacking context
            // So to work around this we create a similar looking overlay if the appDrawer and app-header are present, and then remove these when closing the dialog

            // This is the part where we make an overlay for the non-subview
            // parts of the app, which in the case of web components is always
            this._overlayOnComp(document.getElementById('appHeader'));

            // Finally we move the backdrop directly before the dialog
            // If we don't do this the backdrop can't layer properly and doesn't show up at all
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },

        /**
         * Fired when a dialog is closed
         * The intent here is if we created a separate overlay for a higher stacking context in "_patchOverlay" we want to remove that custom overlay
         */
        _patchOverlayClosed: function(e) {
            if (e.target.tagName === 'PAPER-DIALOG') {
                this._overlayOnComp(document.getElementById('appHeader'), true);
            }
        },

        /**
         * Create a modal style overlay on the passed component
         * Alternatively you can pass true for "remove" to remove an existing overlay
         * No matter what this should only ever create a single overlay on a component, so it can safely be used multiple times in a row
         */
        _overlayOnComp: function(component, remove) {
            if (component) {
                var overlayId = component.id + '_overlay';

                // If we're removing just try to find an existing overlay and kill it
                if (remove) {
                    if (component.querySelector('#' + overlayId)) {
                        component.removeChild(component.querySelector('#' + overlayId));
                    }
                    return;
                }

                // Create and style the overlay to match the existing iron-overlay style, but with the same size as our target component
                var overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.cssText = "position: absolute; top: 0; background-color: black; opacity: 0.6; z-index: 102; pointer-events: auto; width: 100%; height: 100%;";

                // Only add if we don't already have an overlay
                if (!component.querySelector('#' + overlay.id)) {
                    component.appendChild(overlay);
                }
            }
        },

        /**
         * Handles displaying the zone overlap message and ensuring we don't display it too frequently.
         * @private
         */
        _displayOverlapMsg: function() {
            var currentTime = new Date().getTime();
            //Only allow displaying this message once every 5 seconds.
            if (this._displayedZoneOverlapMsgAt &&
                currentTime - this._displayedZoneOverlapMsgAt <= 5000) {
                return;
            }
            this.fire('message-error',this._OVERLAP_WITHIN_STACK_MSG);
            this._displayedZoneOverlapMsgAt = new Date().getTime();
        },

        /**
         * All components need a reference to the classes so once the map is set we'll initialize them.
         */
        _mapChanged: function(map) {
            if (map) {
                this._initializeClasses();
            }
        },

        /**
         * Generates a uid using the current time in ms and a random number
         * in the trillions (each are 13 characters separated by a dash).
         * @returns {string}
         * @private
         */
        _generateUid: function() {
            return new Date().getTime()+'-'+Math.floor(Math.random()*(9000000000000)+1000000000000);
        },

        /**
         * Prefixes a missing # character to the passed param if it is a valid string.
         * @param colour
         * @private
         */
        _formatColour: function(colour) {
            if (colour && typeof colour === 'string' && colour.charAt(0) !== '#') {
                return '#' + colour;
            }
            return colour;
        },

        /**
         * Updates the map bounds so that only the passed zone is in view and then pans the map.
         * Restricts the panning to every 500ms to avoid excessive map panning while resizing zones.
         * @param zone
         * @param forcePan
         * @private
         */
        _panToZone: function(zone, forcePan) {
            var currentTime = new Date().getTime();
            if (forcePan || !this._lastPanZoneTime || currentTime - this._lastPanZoneTime > 500) {
                var bounds = this._AlertZone.getBoundingBox(zone);
                this._map.fitBounds(bounds);
                this._map.panToBounds(bounds);
                this._lastPanZoneTime = new Date().getTime();
            }
        },

        /**
         * Enables zone reshaping for the currently active zone.
         * @param e
         * @private
         */
        _enableZoneReshaping: function(e) {
            this._zoneToReshape = this._loadedAlert.selectedStack.getZoneAt(e.model.get('zoneIndex'));
            if (this._zoneToReshape) {
                // We only want to allow editing the outer boundary of a zone so we can control whether
                // the inner zone is editable. So set the shape to the outer path only and when they
                // are done editing we will punch out the shape again to recreate the inner path.
                var stack = this._zoneToReshape.getParentStack();
                if (stack.zones.indexOf(this._zoneToReshape) > 0) {
                    this._zoneToReshape.setPaths([this._zoneToReshape.shapeOverlay.getPaths().getAt(0)]);
                }
                // Enable editing
                this._zoneToReshape.setEditable(true);
                this._zoneReshapeEscapeListener = function (e) {
                    if (e.key === 'Escape') {
                        this._disableZoneReshaping();
                    }
                }.bind(this);
                window.addEventListener('keydown', this._zoneReshapeEscapeListener);
            }
        },

        /**
         * Disables zone reshaping for the currently active zone.
         * @private
         */
        _disableZoneReshaping: function() {
            var _this = this;
            if (this._zoneToReshape) {
                // Due to the "asynchronous" nature of this function we will immediately reset the
                // zoneToReshape property to prevent this function from executing more than once. This
                // becomes an issue when completing editing by selecting another zone stack or fallback
                // zone since the each of selection events will try to disable zone reshaping
                var zoneToReshape = this._zoneToReshape;
                this._zoneToReshape = null;
                // Enable the wait cursor since the setPaths operation (in punchOutShapes) may take a long time
                this._enableGlobalWaitCursor();
                // Proceed after a small delay so the wait cursor is displayed
                setTimeout(function() {
                    // If we were editing a stacked zone then we punch out the shape when they are
                    // done editing. This is because we only allow them to edit the outer path of
                    // the zone so we can control whether the inner zone is editable or not.
                    var stack = zoneToReshape.getParentStack();
                    if (stack.zones.indexOf(zoneToReshape) > 0) {
                        // Now that editing is done we must punch the shape out again
                        //Update the stack JSON and adjust the centroid position.
                        stack.updateJSONAndCentroid();
                        //Always re-punch out the shapes. This will handle cases like filling
                        //in gaps when the outer boundary of an inner zone is pulled inwards.
                        stack.punchOutShapes();
                        //Update the centroid for the template.
                        _this._loadedAlert.template.updateJSONAndCentroid();
                        if (_this._fallbackZone && zoneToReshape === stack.getOutermostZone()) {
                            _this._fallbackZone.punchOutOverlay();
                        }
                    }
                    // Hide the distance overlay
                    zoneToReshape.managePolygonDistanceBetweenPointsOverlay(false, null);
                    // Disable editing
                    zoneToReshape.setEditable(false);
                    window.removeEventListener('keydown', _this._zoneReshapeEscapeListener);
                    // Disable the wait cursor, again after a delay to ensure it persists for the entire reshape operation
                    setTimeout(function() {
                        _this._disableGlobalWaitCursor();
                    },0);
                },50);
            }
        },

        /**
         * Enables a wait cursor for all elements on the page.
         * @private
         */
        _enableGlobalWaitCursor: function() {
            document.querySelector('html').style.cursor = 'wait !important';
            this._cursorStylingRule = document.createElement('div');
            this._cursorStylingRule.innerHTML = '<style>html * { cursor: wait !important; }</style>'
            document.querySelector('body').appendChild(this._cursorStylingRule);
        },

        /**
         * Disables the wait cursor for all elements on the page (restores default cursors).
         * @private
         */
        _disableGlobalWaitCursor: function() {
            document.querySelector('html').style.cursor = null;
            document.querySelector('body').removeChild(this._cursorStylingRule);
            this._cursorStylingRule = null;
        },

        /**
         * Returns whether tos how the reshapable button.
         * @param isCircle
         * @param fromFile
         * @param isPointerLocked
         * @returns {boolean}
         * @private
         */
        _showReshapableButton: function(isCircle,fromFile,isPointerLocked) {
            return !isCircle && !fromFile && !isPointerLocked;
        },

        /**
         * Notifies the polymer path for AlertTemplate properties.
         * @param propName
         * @private
         */
        _notifyPropertyPathForAlert: function(propName) {
            if (this._loadedAlert && this._loadedAlert.template) {
                this.notifyPath('_loadedAlert.template.'+propName);
            }
        },

        /**
         * Notifies the polymer path for AlertZone properties.
         * @param zone
         * @param propName
         * @private
         */
        _notifyPropertyPathForZone: function(zone,propName) {
            if (!zone || !propName) { return; }
            if (this._loadedAlert && this._loadedAlert.template && this._loadedAlert.selectedStack) {
                var stackIndex = this._loadedAlert.template.getZoneStackIndex(this._loadedAlert.selectedStack);
                var zoneIndex = this._loadedAlert.selectedStack.zones.indexOf(zone);
                if (stackIndex > -1 && zoneIndex > -1) {
                    this.notifyPath('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones.'+zoneIndex+'.'+propName);
                }
            }
        },

        /**
         * Notifies the polymer path for AlertZoneStack properties.
         * @param stack
         * @param propName
         * @private
         */
        _notifyPropertyPathForStack: function(stack,propName) {
            if (!stack || !propName) { return; }
            if (this._loadedAlert && this._loadedAlert.template) {
                var stackIndex = this._loadedAlert.template.getZoneStackIndex(stack);
                if (stackIndex > -1) {
                    this.notifyPath('_loadedAlert.template.zoneStacks.'+stackIndex+'.'+propName);
                }
            }
        },

        /**
         * Notifies the polymer path for FallbackAlertZone properties.
         * @param propName
         * @private
         */
        _notifyPropertyPathForFallbackZone: function(propName) {
            if (this._fallbackZone) {
                this.notifyPath('_fallbackZone.'+propName);
            }
        },

        /**
         * Returns whether the current component is one of the alert editors.
         * @private
         */
        _isAnAlertEditor: function() {
            return this.nodeName === 'VOYENT-ALERT-TEMPLATE-EDITOR' || this.nodeName === 'VOYENT-ALERT-EDITOR';
        },

        /**
         * Waits for the condition function to return true. Optionally pass a
         * waitTimeout in ms to stop waiting once the timeout is reached.
         * @param conditionFunc - The function that will be executed to determine whether the condition has passed.
         * @param waitTimeout - The number of ms to wait until ceasing the search, defaults to indefinitely, can also pass 0 for indefinitely.
         * @param retryTimeout - The retry frequency, defaults to 100ms.
         * @returns {Promise<any>}
         * @private
         */
        _waitForCondition: function(conditionFunc, waitTimeout, retryTimeout) {
            retryTimeout = typeof retryTimeout === 'number' ? retryTimeout : 100;
            let waitedForMs = 0;
            return new Promise(function (resolve, reject) {
                if (conditionFunc()) {
                    resolve();
                }
                else {
                    waitForCondition();
                }
                function waitForCondition() {
                    if (!conditionFunc()) {
                        if (typeof waitTimeout === 'number' && waitTimeout !== 0 && waitedForMs >= waitTimeout) {
                            return reject('condition failed after ' + waitTimeout + 'ms');
                        }
                        waitedForMs += retryTimeout;
                        setTimeout(function(){
                            waitForCondition();
                        },retryTimeout);
                        return;
                    }
                    resolve();
                }
            });
        },

        /**
         * Initialize all our custom "classes" that are required for the various components.
         * @private
         */
        _initializeClasses: function() {
            var _outer = this;
            /**
             * Common code for inheriting a parent's prototype on the child's.
             * @param child
             * @param parent
             * @private
             */
            this._inheritPrototype = function(child,parent) {
                var parentPrototypeClone = Object.create(parent.prototype);
                parentPrototypeClone.constructor = child;
                child.prototype = parentPrototypeClone;
            };
            /**
             * A class that represents an alert template, both the drawn map entity and the json.
             * @param id - The unique identifier.
             * @param parentId - The parent template id, only relevant for child templates.
             * @param alertFamilyId - The alert family id, only relevant for child templates.
             * @param name - The user-defined name.
             * @param badge - The user chosen alert badge icon.
             * @param marker - The associated map marker for the entire template, centered between the various stacks.
             * @param zoneStacks - A list of _AlertZoneStack objects, the list of zone stacks belonging with the template.
             * @param state - The current state of the alert, only relevant for child templates.
             * @param savePosition - Whether the position of the template should be stored in the json.
             * @param schedule - The schedule details, only relevant for child templates.
             * @param categories - Zero or more categories that this template belongs to.
             * @private
             */
            this._AlertTemplate = function(id,parentId,alertFamilyId,name,badge,marker,zoneStacks,state,savePosition,schedule,categories) {
                this.setId(id || null);
                this.setParentId(parentId || null);
                this.setAlertFamilyId(alertFamilyId || null);
                this.setName(name || 'Unnamed');
                this.setBadge(badge || 'info.png');
                this.setMarker(marker || null);
                this.setZoneStacks(zoneStacks && zoneStacks.length ? zoneStacks : []);
                this.setState(state || null);
                this.setSavePosition(!!savePosition);
                this.setIsSampleTemplate(categories && categories.indexOf('Sample') > -1);
                this.setSchedule(schedule);
                this.setCategories(categories || []);
                this.forceSavePosition = false;
            };
            /**
             * Used to calculate the bounds of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateBoundsFromJSON = function(json) {
                var geometries = json.geo.geometries;
                var coordinates, bounds = new google.maps.LatLngBounds();
                for (var i=0; i<geometries.length; i++) {
                    coordinates = geometries[i].coordinates[0];
                    for (var j=0; j<coordinates.length; j++) {
                        bounds.extend(new google.maps.LatLng(coordinates[j][1],coordinates[j][0]));
                    }
                }
                return bounds;
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromJSON = function(json) {
                return this.calculateBoundsFromJSON(json).getCenter();
            };
            /**
             * Used to calculate the rectangular paths around the provided json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateBoundingPathsFromJSON = function(json) {
                var bounds = this.calculateBoundsFromJSON(json);
                var ne = bounds.getNorthEast();
                var sw = bounds.getSouthWest();
                return [ne,new google.maps.LatLng(sw.lat(),ne.lng()),sw,new google.maps.LatLng(ne.lat(),sw.lng()),ne];
            };
            /**
             * Used to calculate the bounds of the passed zone paths.
             * @param paths - An array of LatLng object arrays that define the zone.
             * @static
             */
            this._AlertTemplate.calculateBoundsFromPaths = function(paths) {
                var bounds = new google.maps.LatLngBounds();
                for (var i=0; i<paths.length; i++) {
                    var innerPath = paths.getAt ? paths.getAt(i) : paths[i]; // MVCArray or []
                    for (var j=0; j<innerPath.length; j++) {
                        bounds.extend(paths.getAt ? paths.getAt(i).getAt(j) : paths[i][j]); // MVCArray or []
                    }
                }
                return bounds;
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed paths array.
             * @param paths - An array of arrays of LatLng objects that define the zone.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromPaths = function(paths) {
                var bounds = new google.maps.LatLngBounds();
                for (var i=0; i<paths.length; i++) {
                    var innerPath = paths.getAt ? paths.getAt(i) : paths[i]; // MVCArray or []
                    for (var j=0; j<innerPath.length; j++) {
                        bounds.extend(paths.getAt ? paths.getAt(i).getAt(j) : paths[i][j]); // MVCArray or []
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Calculate the shape overlay paths using the passed coordinates arrays.
             * @param coordinates
             * @static
             */
            this._AlertTemplate.calculatePathsFromCoordinates = function(coordinates) {
                var latLng, paths = [], path;
                for (var i=0; i<coordinates.length; i++) {
                    path = [];
                    //In GeoJSON we must complete the shape by duplicating the coordinate at index 0 at the last index
                    //but Google Maps API states: "Paths are closed automatically; do not repeat the first vertex of
                    //the path as the last vertex.". So we'll exclude the last coordinate when converting to paths.
                    for (var j=0; j<coordinates[i].length-1; j++) {
                        latLng = new google.maps.LatLng(coordinates[i][j][1],coordinates[i][j][0]);
                        path.push(latLng);
                    }
                    paths.push(path);
                }
                return paths;
            };
            /**
             * Calculate the GeoJSON coordinates using the passed shape overlay paths.
             * @param paths
             * @param func - The function to be executed after the inner path has being modified.
             * @static
             */
            this._AlertTemplate.calculateCoordinatesFromPaths = function(paths,func) {
                var latLng, outer = [], inner;
                for (var i=0; i<paths.length; i++) {
                    inner = [];
                    var innerPath = paths.getAt ? paths.getAt(i) : paths[i]; // MVCArray or []
                    for (var j=0; j<innerPath.length; j++) {
                        //Retrieve each coordinate from the shape and save it.
                        latLng = innerPath.getAt ? innerPath.getAt(j) : innerPath[j]; // MVCArray or []
                        inner.push(latLng.lng ? [latLng.lng(), latLng.lat()] : latLng); // LatLng or [lng,lat]
                        if (func) {
                            func(latLng)
                        }
                    }
                    //In GeoJSON we must copy the first coordinate to the last one
                    //to complete the shape. Do this for each coordinate array.
                    inner.push(inner[0]);
                    outer.push(inner);
                }
                return outer;
            };
            /**
             * Calculates the circular shape overlay paths using the passed center coordinate and radius.
             * @param center
             * @param radius
             * @static
             */
            this._AlertTemplate.calculatePathsFromCircleProperties = function(center, radius) {
                var latLng, coordinates=[];
                for (var k=0; k<_outer._NUM_CIRCULAR_POLY_SIDES; k++) {
                    //Calculate and save the next coordinate.
                    latLng = google.maps.geometry.spherical.computeOffset(
                        center, radius, _outer._CIRCULAR_POLY_DEGREE_STEP * k
                    );
                    coordinates.push(latLng);
                }
                return [coordinates];
            };
            /**
             * A static function that returns the default JSON structure.
             * @static
             */
            this._AlertTemplate.getJSONStructure = function () {
                return {
                    "name": "Unnamed",
                    "badge": "info.png",
                    "geo": {
                        "type": "GeometryCollection",
                        "geometries": []
                    },
                    "properties": {}
                };
            };
            /**
             * _AlertTemplate prototype (instance) functions.
             */
            this._AlertTemplate.prototype = {
                constructor: _outer._AlertTemplate,
                /**
                 * Sets the id and notifies the polymer path.
                 * @param id
                 */
                setId: function (id) {
                    this.id = id;
                    _outer._notifyPropertyPathForAlert('id');
                },
                /**
                 * Sets the parentId and notifies the polymer path.
                 * @param parentId
                 */
                setParentId: function(parentId) {
                    this.parentId = parentId;
                    _outer._notifyPropertyPathForAlert('parentId');
                },
                /**
                 * Sets the alertFamilyId and notifies the polymer path.
                 * @param alertFamilyId
                 */
                setAlertFamilyId: function(alertFamilyId) {
                    this.alertFamilyId = alertFamilyId;
                    _outer._notifyPropertyPathForAlert('alertFamilyId');
                },
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    _outer._notifyPropertyPathForAlert('name');
                },
                /**
                 * Sets the alert badge icon and notifies the polymer path.
                 * @param badge
                 */
                setBadge: function(badge) {
                    this.badge = badge;
                    _outer._notifyPropertyPathForAlert('badge');
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    //When we create a new AlertTemplate with only one stack we don't need a marker for
                    //the template since the stack has it's own so always check if we were passed one.
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Sets the zone stacks and triggers required processing.
                 * @param zoneStacks
                 */
                setZoneStacks: function (zoneStacks) {
                    this.zoneStacks = [];
                    for (var i=0; i<zoneStacks.length; i++) {
                        this.addZoneStack(zoneStacks[i]);
                    }
                },
                /**
                 * Sets the alert state.
                 * @param state
                 */
                setState: function(state) {
                    this.state = state;
                },
                /**
                 * Sets whether we should save the template position.
                 * @param savePosition
                 */
                setSavePosition: function(savePosition) {
                    this.savePosition = savePosition;
                    _outer._notifyPropertyPathForAlert('savePosition');
                },
                /**
                 * Sets whether this is a sample template.
                 * @param isSampleTemplate
                 */
                setIsSampleTemplate: function(isSampleTemplate) {
                    this.isSampleTemplate = isSampleTemplate;
                },
                /**
                 * Sets the schedule for the alert.
                 * @param schedule
                 */
                setSchedule: function(schedule) {
                    this.schedule = schedule;
                },
               /**
                * Returns a boolean indicating whether the alert has a schedule.
                */
                hasSchedule: function() {
                    return this.schedule;
                },
                /**
                 * Sets the categories that this alert belongs to.
                 * @param categories
                 */
                setCategories: function(categories) {
                    this.categories = categories;
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.fire('voyent-alert-categories-changed', {"categories":this.categories});
                    }
                },
                /**
                 * Add the passed zone stack.
                 * @param zoneStack
                 */
                addZoneStack: function (zoneStack) {
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.push('_loadedAlert.template.zoneStacks',zoneStack);
                    }
                    else {
                        this.zoneStacks.push(zoneStack);
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Remove the passed zone stack.
                 * @param zoneStack
                 */
                removeZoneStack: function (zoneStack) {
                    zoneStack.removeFromMap();
                    var zoneStackIndex = this.getZoneStackIndex(zoneStack);
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.splice('_loadedAlert.template.zoneStacks',zoneStackIndex,1);
                        if (_outer._loadedAlert.selectedStack === zoneStack) {
                            _outer.set('_loadedAlert.selectedStack',null);
                        }
                    }
                    else {
                        this.zoneStacks.splice(zoneStackIndex,1);
                    }
                    this.updateJSONAndCentroid();
                    if (this.zoneStacks.length === 1) {
                        this.marker.setMap(null);
                        this.setMarker(null);
                    }
                },
                /**
                 * Returns the zone stack at the specified index.
                 * @param index
                 */
                getZoneStackAt: function (index) {
                    return this.zoneStacks[index];
                },
                /**
                 * Returns the index of the passed zone stack.
                 * @param zoneStack
                 */
                getZoneStackIndex: function (zoneStack) {
                    return this.zoneStacks.indexOf(zoneStack);
                },
                /**
                 * Returns the zone stack that the specified zone belongs to.
                 * @param zone
                 */
                getStackForZone: function(zone) {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        var stack = this.zoneStacks[i];
                        if (stack.getZoneIndex(zone) > -1) {
                            return stack;
                        }
                    }
                    return null;
                },
                /**
                 * Deactivates all zone overlays for this stack.
                 */
                deactivateZoneStackOverlays: function() {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].deactivateZoneOverlays();
                    }
                },
                /**
                 * Triggers reinitialization of edit listeners for each polygonal zone stack.
                 */
                initializePolygonStackPathListeners: function() {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        if (!this.zoneStacks[i].zones[0].isCircle) {
                            this.zoneStacks[i].initializePolygonPathListeners();
                        }
                    }
                },
                /**
                 * Accepts a parameter that toggles whether we should force the position to be saved
                 * with the template. This is generally used for imported zones so the user cannot
                 * later create an alert from the template and reposition the imported zone.
                 * @param force
                 */
                forceSavePositionWithTemplate: function(force) {
                    if (force) {
                        this.setSavePosition(true);
                        this.forceSavePosition = true;
                    }
                    else {
                        this.forceSavePosition = false;
                    }
                    _outer._notifyPropertyPathForAlert('forceSavePosition');
                },
                /**
                 * Updates the json to reflect the current state of the template. Since each stack of zones maintains
                 * their own json we update their json and then simply merge the geometries and properties section from
                 * each stack into one.
                 */
                updateJSON: function () {
                    var json = this.constructor.getJSONStructure();
                    //Add template-level properties.
                    json.name = this.name;
                    json.badge = 'info.png';
                    if (this.badge) {
                        json.badge = this.badge;
                    }
                    if (this.parentId) {
                        json.properties.parentAlertId = this.parentId;
                        if (this.alertFamilyId) {
                            json.properties.alertFamilyId = this.alertFamilyId;
                        }
                        if (this.state) {
                            json.state = this.state;
                        }
                        if (this.schedule) {
                            json.schedule = this.schedule;
                        }
                        if (_outer._alertDirection || _outer._alertDirection === 0) {
                            json.properties.direction = Number(_outer._alertDirection);
                        }
                        if (_outer._alertSpeed) {
                            json.properties.speed = Number(_outer._alertSpeed);
                            json.properties.speedUnit = _outer._alertSpeedUnit || 'kph';
                        }
                    }
                    else {
                        json.categories = this.categories;
                    }
                    //Add fallback zone, we'll always add it the properties.
                    json.properties[_outer._FALLBACK_ZONE_ID] = {
                        "enabled": false
                    };
                    if (_outer._fallbackZone) {
                        json.properties[_outer._FALLBACK_ZONE_ID] = {
                            "enabled":_outer._fallbackZone.enabled,
                            "name": _outer._fallbackZone.name
                            /*"opacity": _outer._fallbackZone.opacity,*/ // Fixed opacity
                            /*"colour": _outer._fallbackZone.colour*/ // Fixed colour
                        };
                        if (_outer._fallbackZone.messageTemplate) {
                            json.properties[_outer._FALLBACK_ZONE_ID].messageTemplate = _outer._fallbackZone.messageTemplate;
                        }
                        if (_outer._fallbackZone.notificationFilter) {
                            json.properties[_outer._FALLBACK_ZONE_ID].notificationFilter = _outer._fallbackZone.notificationFilter;
                        }
                        if (_outer._fallbackZone.acknowledgement) {
                            json.properties[_outer._FALLBACK_ZONE_ID].acknowledgement = _outer._fallbackZone.acknowledgement;
                        }
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        //First update the json for the stack.
                        this.zoneStacks[i].updateJSON();
                        //Merge the geometries arrays.
                        json.geo.geometries = json.geo.geometries.concat(this.zoneStacks[i].json.geo.geometries);
                        //Merge the properties objects.
                        for (var zoneId in this.zoneStacks[i].json.properties) {
                            if (this.zoneStacks[i].json.properties.hasOwnProperty(zoneId)) {
                                json.properties[zoneId] = this.zoneStacks[i].json.properties[zoneId];
                            }
                        }
                    }
                    //Check if this is a "fixed location" template and store it.
                    delete json.properties.center;
                    if (!this.parentId && this.savePosition) {
                        json.properties.center = _outer._AlertTemplate.calculateCentroidFromJSON(json).toJSON();
                    }
                    //If we have no geometries defined then delete the geo property entirely.
                    if (!json.geo.geometries.length) { delete json.geo; }

                    this.json = json;
                },
                /**
                 * Updates the position of the template marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    if (this.marker) {
                        this.marker.setPosition(
                            this.constructor.calculateCentroidFromJSON(this.json)
                        );
                    }
                },
                /**
                 * Removes the template from the map.
                 */
                removeFromMap: function() {
                    if (this.marker) {
                        this.marker.setMap(null);
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].removeFromMap();
                    }
                },
                /**
                 * Initializes marker listeners for the alert.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    // As of Feb 6, 2019 the marker is invisible so we won't setup these listeners
                    /*if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the template marker so we'll add a flag to ignore those events.
                    google.maps.event.addListener(this.marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeStackPositions();
                    });
                    google.maps.event.addListener(this.marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                        _this.initializePolygonStackPathListeners();
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(this.marker, 'drag', function () {
                        _this.moveStacksRelativeToPosition();
                        _this.updateJSON();
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                        _this.manageAlertBoundary(true);
                    });
                    google.maps.event.addListener(this.marker, 'dragend', function () {
                        _this.manageAlertBoundary(false);
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(this.marker, 'click', function () {
                        //Toggle all the accordion panes closed and de-select all stacks.
                        _outer._selectZone(null, null);
                    });
                    //Add mouseover and mouseout listeners to highlight the alert boundary for multi-stack alerts.
                    google.maps.event.addListener(this.marker, 'mouseover', function () {
                        _this.manageAlertBoundary(true);
                    });
                    google.maps.event.addListener(this.marker, 'mouseout', function () {
                        _this.manageAlertBoundary(false);
                    });*/
                },
                /**
                 * Calculates the current zone positions (distance and bearing)
                 * in each stack relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeStackPositions: function(latLng) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].calculateRelativeZonePositions(position);
                    }
                },
                /**
                 * Moves zone stacks from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 * @param updateStackMarker - Whether the stack marker position should also be updated.
                 */
                moveStacksRelativeToPosition: function (latLng, updateStackMarker) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].moveZonesRelativeToPosition(position);
                        if (updateStackMarker) {
                            this.zoneStacks[i].updateMarker();
                        }
                    }
                },
                /**
                 * Handles creating, positioning and toggling the visibility of the alert boundary
                 * which is displayed on alert marker mouseover for multi-stack alerts.
                 * @param visible
                 */
                manageAlertBoundary: function(visible) {
                    if (visible) {
                        this.updateJSON();
                        if (!this._alertBoundary) {
                            this._alertBoundary = new google.maps.Polyline({
                                path: _outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json),
                                map: _outer._map,
                                strokeWeight: 1
                            });
                        }
                        else {
                            this._alertBoundary.setMap(_outer._map);
                            this._alertBoundary.setPath(_outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json));
                        }
                    }
                    else if (this._alertBoundary) {
                        this._alertBoundary.setMap(null);
                    }
                }
            };
            Object.seal(this._AlertTemplate);

            /**
             * A class that represents an alert template proximity zone stack.
             * @param id - The unique id that identifies the zone stack, if one is not provided it will be generated.
             * @param zones - A list of _AlertZone objects, the list of zones belonging with the stack.
             * @param fromFile - Whether this stack was derived from an imported file.
             * @private
             */
            this._AlertZoneStack = function (id,zones,fromFile) {
                this.id = id && typeof id === 'string' ? id : _outer._generateUid();
                this.setZones(zones && zones.length ? zones : []);
                this.updateMarker();
                this.setFromFile(fromFile);
                this.updateJSON();
                this.forceDisplayMarker = false;
            };
            /**
             * Returns the colour of the zone at the passed index, assuming
             * a default order of `red`, `yellow`, `blue`, `green`.
             * @param index
             * @static
             */
            this._AlertZoneStack.getZoneColourAtIndex = function(index) {
                if (this._isZoneAtIndexColour(index,'red')) {
                    return '#FF0000'
                }
                else if (this._isZoneAtIndexColour(index,'orange')) {
                    return '#FFB000';
                }
                else if (this._isZoneAtIndexColour(index,'yellow')) {
                    return '#FFFF00';
                }
                else if (this._isZoneAtIndexColour(index,'green')) {
                    return '#00FF00';
                }
                else if (this._isZoneAtIndexColour(index,'blue')) {
                    return '#0000FF';
                }
                else if (this._isZoneAtIndexColour(index,'cyan')) {
                    return '#00EEFF';
                }
                else if (this._isZoneAtIndexColour(index,'pink')) {
                    return '#FF00DD';
                }
            };
            /**
             * Determines if the zone at the index is the colour.
             * @param index - The index of the zone.
             * @param colour - The colour to check.
             * @static
             * @private
             */
            this._AlertZoneStack._isZoneAtIndexColour = function(index,colour) {
                var zoneNumber = index+1;
                //Only generate the minimum amount of numbers in the sequence that we need to determine a match.
                var count = Math.ceil((zoneNumber)/7);
                //Determine the starting point for our sequence.
                var sequence = [];
                if (colour === 'red') { sequence.push(1); }
                else if (colour === 'orange') { sequence.push(2); }
                else if (colour === 'yellow') { sequence.push(3); }
                else if (colour === 'green') { sequence.push(4); }
                else if (colour === 'blue') { sequence.push(5); }
                else if (colour === 'cyan') { sequence.push(6); }
                else { sequence.push(7); }
                //Generate the sequence and return whether we have a match.
                for (var i=1; i<=count; i++) {
                    sequence.push(sequence[sequence.length-1]+7);
                }
                return sequence.indexOf(zoneNumber) > -1;
            };
            /**
             * _AlertZoneStack prototype (instance) functions.
             */
            this._AlertZoneStack.prototype = {
                constructor: _outer._AlertZoneStack,
                /**
                 * Sets the marker and sets up relevant listeners.
                 */
                updateMarker: function () {
                    var paths = this.zones[0] && this.zones[0].shapeOverlay && this.zones[0].shapeOverlay.getPaths();
                    if (paths) {
                        var position = _outer._AlertTemplate.calculateCentroidFromPaths(paths);
                        if (!this.marker) {
                            this.marker = new google.maps.Marker({
                                map: _outer._map, draggable: true, zIndex: 50, cursor: 'move', visible: _outer.nodeName === 'VOYENT-MOBILE-ALERT-EDITOR'
                            });
                            this._setupMarkerListeners();
                        }
                        this.marker.setPosition(position);
                        this.updateLatLngFromMarker();
                    }
                },
                /**
                 * Updates the lat/lng properties using the current position of
                 * the marker and creates or updates the coordinate overlay.
                 */
                updateLatLngFromMarker: function() {
                    var markerPos = this.marker && this.marker.getPosition();
                    if (markerPos) {
                        this.setLat(markerPos.lat());
                        this.setLng(markerPos.lng());
                    }
                },
                /**
                 * Updates the marker position using the passed lat/lng, and updates
                 * the position of the stack and related overlays to match.
                 * @param lat
                 * @param lng
                 */
                updateMarkerPosition: function(lat, lng) {
                    if (this.marker) {
                        this.calculateRelativeZonePositions(this.marker.getPosition());
                        lat = lat || this.marker.getPosition().lat();
                        lng = lng || this.marker.getPosition().lng();
                        this.marker.setPosition({lat: lat, lng: lng});
                        this._moveStackToMarkerPosition();
                    }
                },
                /**
                 * Set the latitude coordinate of the stack.
                 * @param lat
                 */
                setLat: function(lat) {
                    if (lat && typeof lat === 'number') {
                        this.lat = lat.toFixed(5);
                        _outer._notifyPropertyPathForStack(this, 'lat');
                    }
                },
                /**
                 * Set the longitude coordinate of the stack.
                 */
                setLng: function(lng) {
                    if (lng && typeof lng === 'number') {
                        this.lng = lng.toFixed(5);
                        _outer._notifyPropertyPathForStack(this, 'lng');
                    }
                },
                /**
                 * Adds the passed zones to the stack.
                 * @param zones
                 */
                setZones: function (zones) {
                    this.zones = [];
                    for (var i=0; i<zones.length; i++) {
                        this.addZone(zones[i]);
                    }
                },
                /**
                 * Sets whether this stack was derived from a file.
                 */
                setFromFile: function(fromFile) {
                    this.fromFile = !!fromFile;
                },
                /**
                 * Returns the zone at the specified index.
                 * @param index
                 */
                getZoneAt: function (index) {
                    return this.zones[index];
                },
                /**
                 * Returns the index of the passed zone.
                 * @param zone
                 */
                getZoneIndex: function (zone) {
                    return this.zones.indexOf(zone);
                },
                /**
                 * Returns the zone with the specified zoneId.
                 * @param zoneId
                 */
                getZoneById: function (zoneId) {
                    for (var i=0; i<this.zones.length; i++) {
                        if (this.zones[i].id === zoneId) {
                            return this.zones[i];
                        }
                    }
                    return null;
                },
                /**
                 * Returns the outermost zone.
                 */
                getOutermostZone: function() {
                    return this.getZoneAt(this.zones.length-1);
                },
                /**
                 * Returns the innermost zone.
                 */
                getInnermostZone: function() {
                    return this.getZoneAt(0);
                },
                /**
                 * Deactivates all zones.
                 */
                deactivateZoneOverlays: function () {
                    for (var i = 0; i < this.zones.length; i++) {
                        this.zones[i].setActive(false);
                    }
                },
                /**
                 * Add the passed zone and notifies the polymer path.
                 * @param zone
                 */
                addZone: function (zone) {
                    var pushed = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.push('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',zone);
                            pushed = true;
                        }
                    }
                    if (!pushed) {
                        this.zones.push(zone);
                    }
                    // Set the zone colour based on the zone position
                    if (!zone.colour) {
                        zone.setColour(this.constructor.getZoneColourAtIndex(this.zones.length-1));
                    }
                    this.updateJSONAndCentroid();
                    this._punchOutShape(this.zones.length-1);
                    this._setupZoneListeners(zone);
                },
                /**
                 * Inserts the passed zone at the passed index and notifies the polymer path.
                 * @param zone
                 * @param index
                 */
                insertZone: function (zone, index) {
                    var spliced = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.splice('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',index,0,zone);
                            spliced = true;
                        }
                    }
                    if (!spliced) {
                        this.zones.splice(index,0,zone);
                    }
                    // Set the zone colour based on the number of zones
                    if (!zone.colour) {
                        zone.setColour(this.constructor.getZoneColourAtIndex(this.zones.length-1));
                    }
                    this.updateJSONAndCentroid();
                    // Punch out our new shape with the next closest inner shape
                    this._punchOutShape(index);
                    // Punch out the next closest outer shape
                    this._punchOutShape(index+1);
                    this._setupZoneListeners(zone);
                },
                /**
                 * Remove the passed zone and notifies the polymer path.
                 * @param zone
                 */
                removeZone: function (zone) {
                    zone.removeFromMap();
                    var zoneIndex = this.getZoneIndex(zone);
                    var spliced = false;
                    if (_outer._loadedAlert && _outer._loadedAlert.template) {
                        var stackIndex = _outer._loadedAlert.template.getZoneStackIndex(this);
                        if (stackIndex > -1) {
                            _outer.splice('_loadedAlert.template.zoneStacks.'+stackIndex+'.zones',zoneIndex,1);
                            spliced = true;
                        }
                    }
                    if (!spliced) {
                        this.zones.splice(zoneIndex,1);
                    }
                    //Update the JSON so we have a fresh set of coordinates for the punch out logic.
                    this.updateJSON();
                    //The zoneIndex actually points to the closest outer zone now since the array was just spliced.
                    var closestOuterZone = this.zones[zoneIndex];
                    if (zoneIndex === 0) {
                        if (closestOuterZone) {
                            //The inner-most zone was removed so we must fill in the hole with the
                            //closest outer zone. To do this we will take the outer boundary of the
                            //zone and set it as the only path, producing a geometry with no holes.
                            closestOuterZone.setPaths(closestOuterZone.shapeOverlay.getPaths().getAt(0));
                        }
                    }
                    else {
                        //A middle or outer zone was removed so just re-punch out the closest outer zone if there is one.
                        if (closestOuterZone) {
                            this._punchOutShape(zoneIndex);
                        }
                    }
                    //Refresh the JSON again and update the centroid position in case the outer zone was removed.
                    this.updateJSONAndCentroid();
                },
                /**
                 * Updates the json to reflect the current state of the stack. Also updates
                 * the northernCoordinate which adjusts the position of the zone name overlays.
                 */
                updateJSON: function () {
                    var zone, northernCoordinate, overlay,
                        json = _outer._AlertTemplate.getJSONStructure();

                    for (var i=0; i<this.zones.length; i++) {
                        zone = this.zones[i];
                        northernCoordinate = [null, -100];
                        overlay = zone.shapeOverlay;
                        json.properties[zone.id] = {
                            "name": zone.name,
                            "stackId": this.id,
                            "shape": zone.isCircle ? 'circle' : 'polygon',
                            /*"opacity": zone.opacity,*/ // Fixed opacity
                            "colour": zone.colour,
                            "innermost": i===0,
                            "positionInStack": i+1,
                            "fromFile": !!zone.fromFile
                        };
                        if (zone.messageTemplate) {
                            json.properties[zone.id].messageTemplate = zone.messageTemplate;
                        }
                        if (zone.notificationFilter) {
                            json.properties[zone.id].notificationFilter = zone.notificationFilter;
                        }
                        if (zone.acknowledgement) {
                            json.properties[zone.id].acknowledgement = zone.acknowledgement;
                        }
                        json.geo.geometries.push({
                            "id": zone.id,
                            "stackId": this.id,
                            "fromFile": !!this.fromFile,
                            "type": "Polygon",
                            "coordinates": [[]]
                        });
                        json.geo.geometries[i].coordinates =
                            _outer._AlertTemplate.calculateCoordinatesFromPaths(overlay.getPaths(),function(latLng) {
                                //Look for the northern most point of the polygon so we know
                                //where to render the Proximity Zone overlay label.
                                if (latLng.lat() > northernCoordinate[1]) {
                                    northernCoordinate = [latLng.lng(), latLng.lat()];
                                }
                            });
                        zone.setNorthernCoordinate(northernCoordinate);
                    }
                    this.json = json;
                },
                /**
                 * Updates the position of the stack marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    // Position the stack marker in the center of the inner-most zone
                    if (this.marker) {
                        this.marker.setPosition(
                            _outer._AlertTemplate.calculateCentroidFromPaths(this.zones[0].shapeOverlay.getPaths())
                        );
                    }
                },
                /**
                 * Loops the zone coordinates in the JSON and triggers punching out the smaller
                 * from the larger, starting from the largest and excluding the smallest.
                 */
                punchOutShapes: function() {
                    for (var i=this.json.geo.geometries.length-1; i>0; i--) {
                        this._punchOutShape(i);
                    }
                },
                /**
                 * Punches out the zone at the passed index with it's closest smallest zone.
                 * @param index - The index of the zone to be punched out.
                 * @private
                 */
                _punchOutShape: function(index) {
                    //Don't proceed if the index of the smallest zone (0) is passed.
                    if (!index) { return; }
                    var doughnut = turf.difference({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index].coordinates[0]]
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index-1].coordinates[0]]
                            }
                        }
                    );
                    var coordinates = doughnut.geometry.coordinates;
                    //Calculate and set the new punched out paths so the changes get reflected on the map immediately.
                    var punchedOutPaths = _outer._AlertTemplate.calculatePathsFromCoordinates(coordinates);
                    this.zones[index].setPaths(punchedOutPaths);
                    //Re-initialize the polygon path listeners for the edited zone.
                    this.initializePolygonPathListeners(this.zones[index]);
                    //Replace the old json coordinates with our new punched out zone.
                    this.json.geo.geometries[index].coordinates = coordinates;
                },
                /**
                 * Calculates the current zone positions (distance and bearing) relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeZonePositions: function(latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions=[];
                        var paths = this.zones[i].shapeOverlay.getPaths(), innerPositions;
                        for (var j=0; j<paths.length; j++) {
                            innerPositions = [];
                            for (var k=0; k<paths.getAt(j).length; k++) {
                                //Calculate the distance and bearing from the position to the each vertex.
                                innerPositions.push({
                                    "distance":google.maps.geometry.spherical.computeDistanceBetween(latLng,paths.getAt(j).getAt(k)),
                                    "bearing":google.maps.geometry.spherical.computeHeading(latLng,paths.getAt(j).getAt(k))
                                });
                            }
                            positions.push(innerPositions);
                        }
                        this.zones[i]._relativePositions = positions;
                    }
                },
                /**
                 * Moves zones from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 */
                moveZonesRelativeToPosition: function (latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions = this.zones[i]._relativePositions, paths = [], path;
                        for (var j=0; j<positions.length; j++) {
                            path = [];
                            for (var k=0; k<positions[j].length; k++) {
                                path.push(google.maps.geometry.spherical.computeOffset(
                                    latLng,
                                    positions[j][k].distance,
                                    positions[j][k].bearing)
                                );
                            }
                            paths.push(path);
                        }
                        this.zones[i].setPaths(paths);
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Hides this stack and all of its associated zones and overlays.
                 */
                hide: function() {
                    this.marker.setVisible(false);
                    if (this.coordinateOverlay && this.coordinateOverlay.visible) {
                        this.coordinateOverlay.div.style.display = 'none';
                    }
                    for (var i=0; i<this.zones.length; i++) {
                        this.zones[i].hide();
                    }
                },
                /**
                 * Shows this stack and all of its associated zones and overlays.
                 */
                show: function() {
                    if (this.forceDisplayMarker) {
                        this.marker.setVisible(true);
                    }
                    if (this.coordinateOverlay && this.coordinateOverlay.visible) {
                        this.coordinateOverlay.displayAndDraw();
                    }
                    for (var i=0; i<this.zones.length; i++) {
                        this.zones[i].show();
                    }
                },
                /**
                 * Removes the stack of zones from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    for (var i=0; i<this.zones.length; i++) {
                        this.zones[i].removeFromMap();
                    }
                    if (this.coordinateOverlay) {
                        this.coordinateOverlay.setMap(null);
                    }
                    if (this.badgeOverlay) {
                        this.badgeOverlay.setMap(null);
                    }
                },
                /**
                 * Manages the visibility of the stack marker on zone selection for the rare case where
                 * the marker does not live within the boundary of the innermost zone (VRAS-774).
                 * @param visible
                 * @private
                 */
                _forceToggleStackMarkerOnZoneActivation: function(visible) {
                    if (_outer.nodeName !== 'VOYENT-MOBILE-ALERT-EDITOR' && this && !this.fromFile) {
                        var markerWithinStack = google.maps.geometry.poly.containsLocation(
                            this.marker.getPosition(), this.getInnermostZone().shapeOverlay
                        );
                        if (!visible || (visible && !markerWithinStack)) {
                            this._forceToggleStackMarker(visible);
                        }
                    }
                },
                /**
                 * Manages the visibility of the stack marker after polygon edits for the rare case where
                 * the marker does not live within the boundary of the innermost zone (VRAS-774).
                 */
                _forceToggleStackMarkerAfterPolygonEdit: function() {
                    if (this && !this.fromFile) {
                        var markerWithinStack = google.maps.geometry.poly.containsLocation(
                            this.marker.getPosition(), this.getInnermostZone().shapeOverlay
                        );
                        var visible;
                        if (markerWithinStack && this.forceDisplayMarker) {
                            visible = false;
                        }
                        else if (!markerWithinStack && !this.forceDisplayMarker) {
                            visible = true;
                        }
                        if (typeof visible === 'boolean') {
                            this._forceToggleStackMarker(visible);
                        }
                    }
                },
                /**
                 * Manages force toggling the stack marker and associated coordinate overlay.
                 * @param visible
                 * @private
                 */
                _forceToggleStackMarker: function(visible) {
                    this.forceDisplayMarker = visible;
                    this.marker.setOptions( { visible: visible } );
                    if (!visible && this.coordinateOverlay) {
                        this.coordinateOverlay.hide();
                    }
                },
                /**
                 * Initializes marker listeners for the zone stack.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    // The proximity zone center_changed listener will fire continuously when
                    // dragging the stack marker so we'll add a flag to ignore those events
                    var marker = this.marker;
                    google.maps.event.addListener(marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeZonePositions(_this.marker.getPosition());
                        _outer._dragStartPosition = _this.marker.getPosition();
                    });
                    google.maps.event.addListener(marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        // Re-initialize the polygon path listeners for all zones
                        _this.initializePolygonPathListeners();
                    });
                    // Continuously re-draw the overlay as the template is dragged
                    google.maps.event.addListener(marker, 'drag', function () {
                        // Update the position of the stack
                        _this._moveStackToMarkerPosition();
                        //_this.manageStackBoundary(true);
                    });
                    // Display the coordinate overlay on marker mouseover
                    google.maps.event.addListener(marker, 'mouseover', function () {
                        if (!_this.coordinateOverlay) {
                            _this.coordinateOverlay = new _outer._CoordinateOverlay(_this);
                        }
                        else if (!_this.coordinateOverlay.visible) {
                            _this.coordinateOverlay.displayAndDraw();
                        }
                    });
                    /*google.maps.event.addListener(marker, 'dragend', function () {
                        _this.manageStackBoundary(false);
                    });*/
                    /*// Add mouseover and mouseout listeners to highlight the stack boundary.
                    google.maps.event.addListener(marker, 'mouseover', function () {
                        _this.manageStackBoundary(true);
                    });
                    google.maps.event.addListener(marker, 'mouseout', function () {
                        _this.manageStackBoundary(false);
                    });*/
                },
                /**
                 * Moves the stack to the current position of the marker.
                 * @private
                 */
                _moveStackToMarkerPosition: function() {
                    // Move the stack
                    this.moveZonesRelativeToPosition(this.marker.getPosition());
                    // Update the JSON and punch out the fallback zone
                    _outer._loadedAlert.template.updateJSONAndCentroid();
                    if (_outer._fallbackZone) {
                        _outer._fallbackZone.punchOutOverlay();
                    }
                    // Update the position of the radius polyline
                    this.manageZoneRadiusOverlays();
                    // Update the stored lat/lng coordinates
                    this.updateLatLngFromMarker();
                },
                /**
                 * Initializes zone listeners.
                 * @param zone
                 * @private
                 */
                _setupZoneListeners: function (zone) {
                    var _this = this;
                    if (_outer.nodeName !== 'VOYENT-ALERT-VIEW' && _outer.nodeName !== 'VOYENT-MOBILE-ALERT-EDITOR') {
                        var overlay = zone.shapeOverlay;
                        //Add click listener to shapes.
                        google.maps.event.addListener(overlay, 'click', function () {
                            _outer._selectZone(_this, zone);
                        });
                        // Adjust zone styling on zone hover and toggle the polygon distance overlay on vertex hover
                        google.maps.event.addListener(overlay, 'mouseover', function(e) {
                            _outer._mouseoverZone(zone, true);
                            // Store which zone the mouse is over so we can use it to determine whether the mouse
                            // is still over a zone within the stack or if it has moved outside of the stack
                            _this.activeZoneOnMouseover = zone;
                            // Process mouseover on the vertices
                            if (!zone.isCircle && typeof e.path !== 'undefined') {
                                // Store the previous vertex position when hovering
                                // an existing vertex in case we need to revert
                                var activeVertexDetails = {
                                    zone: zone,
                                    latLng: e.latLng,
                                    index: typeof e.edge === 'number' ? (e.edge+1) : e.vertex,
                                    type: typeof e.edge === 'number' ? 'insertAt' : 'setAt'
                                };
                                // Disable editing mode when switching the active vertex
                                if (zone.distanceBetweenPointsOverlay && _outer._activeVertexDetails &&
                                    (_outer._activeVertexDetails.index !== activeVertexDetails.index ||
                                    _outer._activeVertexDetails.type !== activeVertexDetails.type)) {
                                    zone.distanceBetweenPointsOverlay.disableEditingMode();
                                }
                                _outer.set('_activeVertexDetails', activeVertexDetails);
                                zone.managePolygonDistanceBetweenPointsOverlay(true, e.latLng);
                            }
                        });
                        google.maps.event.addListener(overlay, 'mouseout', function(e) {
                            if (typeof e.path === 'undefined') {
                                _outer._mouseoutZone(zone);
                                _this.activeZoneOnMouseout = _this.activeZoneOnMouseover;
                                setTimeout(function() {
                                    // If the `activeZoneOnMouseover` property has not changed then it means a mouseover
                                    // event was not fired after this mouseout event was received. This indicates
                                    // that the mouse was moved outside of the stack rather than just to another
                                    // zone within the stack, so we will hide the coordinate overlay
                                    if (_this.activeZoneOnMouseout === _this.activeZoneOnMouseover &&
                                        _this.coordinateOverlay && !_this.forceDisplayMarker &&
                                        !_this.coordinateOverlay.editing) {
                                        _this.coordinateOverlay.hide();
                                    }
                                });
                            }
                        });
                        if (!zone.isCircle) {
                            // Handle polygon edits
                            _this.initializePolygonPathListeners(zone);
                            // Stores whether a vertex is actively being dragged
                            google.maps.event.addListener(overlay, 'mousedown', function(e) {
                                if (typeof e.path !== 'undefined') {
                                    _outer._activelyMovingVertex = true;
                                }
                            });
                        }
                    }
                },
                /**
                 * Initializes polygon edit listeners. When that paths of the overlay change significantly, such as when
                 * punching the shapes out, we need to call this function again to re-initialize the listeners.
                 * @param zone - The optional zone for which listeners will be initialized. If this is not provided then
                 *               all zones for the stack will be processed.
                 */
                initializePolygonPathListeners: function(zone) {
                    if (zone) {
                        if (!zone.isCircle) {
                            this._setupPolygonPathListeners(zone);
                        }
                    }
                    else {
                        for (var i=0; i<this.zones.length; i++) {
                            if (!this.zones[i].isCircle) {
                                this._setupPolygonPathListeners(this.zones[i]);
                            }
                        }
                    }
                },
                /**
                 * Processes individual zones sent from `initializePolygonPathListeners`.
                 * @param zone
                 * @private
                 */
                _setupPolygonPathListeners: function(zone) {
                    var _this = this;
                    // To ensure we don't duplicate listeners we will always clear existing ones first
                    for (var i=0; i<zone.shapeOverlay.getPaths().length; i++) {
                        (function(pathIndex) {
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'insert_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'insert_at', function (vertexIndex) {
                                // setTimeout so the vertex gets inserted before we operate on it
                                setTimeout(function() {
                                    _this._polyAtListener('insert_at',zone,pathIndex,vertexIndex);
                                },0);
                            });
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'set_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'set_at', function (vertexIndex) {
                                // The setAt operation will be triggered when we are
                                // reverting a vertex so don't process these events
                                if (_outer._revertedVertex) {
                                    _outer._revertedVertex = false;
                                    return;
                                }
                                _this._polyAtListener('set_at',zone,pathIndex,vertexIndex);
                            });
                        })(i);
                    }
                },
                /**
                 * Checks if the vertex change is valid when a polygonal zone is edited.
                 * @param eventName - The name of the event that is calling this function. One of `insert_at` or `set_at`.
                 * @param zone - The zone that the event fired on.
                 * @param pathIndex - The path that the event fired on.
                 * @param vertexIndex - The vertex that the event fired on.
                 * @private
                 */
                _polyAtListener: function (eventName, zone, pathIndex, vertexIndex) {
                    var errorMsg = null;
                    var zoneIndex = this.getZoneIndex(zone);
                    var outerZone = this.getOutermostZone();
                    var newVertexPosition = zone.shapeOverlay.getPaths().getAt(pathIndex).getAt(vertexIndex);
                    // Check if the vertex exists because in the recursive expandDistanceFromCenter processing a
                    // vertex may be inserted (insertAt), updated (setAt), and then removed (removeAt) by this
                    // listener because validation fails. When this happens the vertex can no longer be found
                    // because the insertAt event triggers after the setAt and removeAt operations.
                    if (!newVertexPosition) {
                        return;
                    }
                    //Check if the polygon intersects itself. To do this we will use the turf library but we
                    //must first extract the new zone coordinates so they can be interpreted by turf as GeoJSON.
                    var newZoneCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(zone.shapeOverlay.getPaths());
                    var closestInnerZoneCoordinates;
                    if (this.getZoneAt(zoneIndex-1)) {
                        closestInnerZoneCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(
                            this.getZoneAt(zoneIndex-1).shapeOverlay.getPaths()
                        );
                    }
                    var kinks = turf.kinks({
                        "type": "Feature",
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": newZoneCoordinates
                        }
                    });
                    if (kinks.features.length) {
                        errorMsg = 'The zone cannot self-intersect';
                    }
                    if (!errorMsg && this.zones.length > 1) {
                        //Check that the vertex is within our zone boundary. This handles the case
                        //where they drag an inner zone vertex past the boundaries of the stack.
                        if (zoneIndex !== this.getZoneIndex(outerZone)) {
                            if (!google.maps.geometry.poly.containsLocation(newVertexPosition,new google.maps.Polygon({
                                paths: [outerZone.shapeOverlay.getPaths().getAt(pathIndex)]}))) {
                                errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                            }
                        }
                        else {
                            //Check that the outer-most zone is touching it's closest inner zone. This
                            //handles the case where they drag a vertex on the outer-most zone to the
                            //opposite side of the shape, detaching it from the stack.
                            var intersects = turf.intersect({
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    //The zone isn't punched out yet which means the previous inner zone boundary
                                    //will exist as a filled polygon so make sure we only select the edited zone.
                                    "coordinates": [newZoneCoordinates[0]]
                                }
                            },
                            {
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    "coordinates": closestInnerZoneCoordinates
                                }
                            });
                            if (!intersects.geometry) {
                                errorMsg = 'The zone cannot be detached from the stack';
                            }
                        }
                        //Check if the vertex overlaps zones beyond the adjacent zone on either side. Overlapping the
                        //adjacent zone is OK because we will just adjust the shape of that zone to accommodate.
                        if (!errorMsg && this.zones.length > 2) {
                            //Test zones on the outer side of the edited zone, starting with two zones away.
                            for (var i=zoneIndex+2; i<this.zones.length; i++) {
                                if (google.maps.geometry.poly.containsLocation(
                                    newVertexPosition, this.getZoneAt(i).shapeOverlay)) {
                                    errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                                    break;
                                }
                            }
                            if (!errorMsg) {
                                //Test zones on the inner side of the edited zone, starting with two zones away.
                                for (i=zoneIndex-2; i>=0; i--) {
                                    if (google.maps.geometry.poly.containsLocation(
                                        newVertexPosition, this.getZoneAt(i).shapeOverlay)) {
                                        errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                                        break;
                                    }
                                }
                            }
                        }
                        // If we are editing an outer zone (a zone which has an inner zone) then we will not punch out
                        // the shape until the user completes the editing operation so we must check if the outer zone
                        // completely contains the inner zone to prevent the user from intersecting with it.
                        if (!errorMsg && zoneIndex > 0) {
                            var zoneContainsClosestInnerZone = turf.lineIntersect({
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [newZoneCoordinates[0]] // Select the outer path of the zone we're editing
                                    }
                                },
                                {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": closestInnerZoneCoordinates
                                    }
                                }
                            );
                            if (zoneContainsClosestInnerZone.features.length) {
                                errorMsg = _outer._OVERLAP_WITHIN_STACK_MSG;
                            }
                        }

                    }
                    // Revert the position if there was a problem and display a message to the user
                    if (errorMsg) {
                        _outer.set('_haveVertexError', true);
                        // If we set an existing vertex and that vertex was not inserted as part of recursion
                        // in `expandDistanceFromCenter` then we will reset it to the original value
                        if (eventName === 'set_at' && _outer._activeVertexDetails.type !== 'insertAt') {
                            _outer._revertedVertex = true;
                            zone.shapeOverlay.getPaths().getAt(pathIndex).setAt(vertexIndex, _outer._activeVertexDetails.latLng);
                            _outer._revertedVertex = false;
                        }
                        else { // Otherwise completely remove the vertex
                            zone.shapeOverlay.getPaths().getAt(pathIndex).removeAt(vertexIndex);
                        }

                        // If we reverted the vertex operation of the innermost zone then the marker and coordinate
                        // overlay position may have changed while we were dragging so we must reset them
                        if (zone === this.getInnermostZone()) {
                            this.marker.setPosition(_outer._AlertTemplate.calculateCentroidFromPaths(zone.shapeOverlay.getPaths()));
                            this.updateLatLngFromMarker();
                        }
                        // Redraw the distance overlay since it moves with the vertex as we drag it
                        zone.managePolygonDistanceBetweenPointsOverlay(true, _outer._activeVertexDetails.latLng);

                        _outer.fire('message-error',errorMsg);
                        return;
                    }
                    _outer.set('_haveVertexError', false);

                    this.updateTemplateAfterVertexModification(zone, newVertexPosition);
                },
                /**
                 * Updates template state after a vertex modification (insertAt,
                 * setAt, removeAt) has been made to the polygon paths of a zone.
                 */
                updateTemplateAfterVertexModification: function(zone, newVertexPosition) {
                    var zoneIndex = this.getZoneIndex(zone);
                    var isOuterMostZone = this.getOutermostZone() === zone;

                    //Update the stack JSON and adjust the centroid position.
                    this.updateJSONAndCentroid();

                    // If we are editing an inner zone (a zone which has an outer zone) then punch out the outer zone
                    // immediately since if the inner zone is editable then so is the outer one. If the zone is
                    // the outer zone then it will be punched out when the user completes the editing operation.
                    if (this.getZoneAt(zoneIndex+1)) {
                        //Punch out the outer zone
                        this._punchOutShape(zoneIndex+1);
                    }

                    // Update the centroid for the template
                    _outer._loadedAlert.template.updateJSONAndCentroid();
                    // Update the position of the coordinate overlay
                    this.updateLatLngFromMarker();

                    // If we are editing the outer zone then punch out the fallback zone immediately
                    if (isOuterMostZone) {
                        //Punch out the fallback zone
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                    }

                    // Update the position of the distance overlay
                    zone.managePolygonDistanceBetweenPointsOverlay(true, newVertexPosition);

                    // Manage the visibility of the stack marker to ensure it can always be accessed
                    this._forceToggleStackMarkerAfterPolygonEdit();

                    // Quickly toggle the overlay to fix a couple bugs with correctly displaying the polygons:
                    // 1) Dragging a multi-zone polygon stack after editing will leave a line
                    //    where the edited vertex connects to its neighbouring vertices.
                    // 2) Editing a polygon after resizing will leave some vertices behind.
                    zone.shapeOverlay.setMap(null);
                    setTimeout(function() {
                        zone.shapeOverlay.setMap(_outer._map);
                    },0);
                },
                /**
                 * Manages the position of the radius overlays for all zones associated with this stack.
                 */
                manageZoneRadiusOverlays: function() {
                    for (var i=0; i<this.zones.length; i++) {
                        if (this.zones[i].active) {
                            this.zones[i].manageCircleDistanceBetweenPointsOverlay();
                        }
                    }
                },
                /**
                 * Handles creating, positioning and toggling the visibility of the
                 * zone stack boundary which is displayed on stack marker mouseover.
                 * @param visible
                 */
                manageStackBoundary: function(visible) {
                    if (visible) {
                        this.updateJSON();
                        if (!this._stackBoundary) {
                            this._stackBoundary = new google.maps.Polyline({
                                path: _outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json),
                                map: _outer._map,
                                strokeWeight: 1
                            });
                        }
                        else {
                            this._stackBoundary.setMap(_outer._map);
                            this._stackBoundary.setPath(_outer._AlertTemplate.calculateBoundingPathsFromJSON(this.json));
                        }
                    }
                    else if (this._stackBoundary) {
                        this._stackBoundary.setMap(null);
                    }
                }
            };
            Object.seal(this._AlertZoneStack);

            /**
             * A class that represents an alert zone, both the drawn map entity and the json.
             * @param id - The unique id that identifies the zone, if one is not provided it will be generated.
             * @param name - The user-defined name.
             * @param paths - The polygon paths, an array of arrays of LatLng objects.
             * @param isCircle - The shape of
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param notificationFilter - The notification data associated with this zone.
             * @param acknowledgement - The acknowledgement property associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @param fromFile - Whether this zone was derived from an imported file.
             * @private
             */
            this._AlertZone = function (id,name,paths,isCircle,opacity,colour,messageTemplate,notificationFilter,acknowledgement,zIndex,fromFile) {
                this.id = id && typeof id === 'string' ? id : _outer._generateUid();
                this.setName(name || 'Zone 1');
                this.setPaths(paths);
                this.isCircle = !!isCircle;
                this.setEditable(false); // Editing must be toggled by the user
                this.setOpacity(/*opacity || */0.25); // Fixed opacity
                this.setColour(colour || null); //Default to null so the stack can manage the colours based on the number of zones.
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.messageTemplate = messageTemplate || null;
                this.notificationFilter = notificationFilter || null;
                this.acknowledgement = acknowledgement || null;
                this.setFromFile(fromFile);
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
                this.overlayHighlighted = false;
            };
            /**
             * Returns the LatLngBounds for the passed zone.
             * @param zone
             * @static
             */
            this._AlertZone.getBoundingBox = function(zone) {
                if (zone && zone.shapeOverlay) {
                    var bounds = new google.maps.LatLngBounds();
                    var outerPath = zone.shapeOverlay.getPaths().getAt(0);
                    outerPath.forEach(function (latLng) {
                        bounds.extend(latLng);
                    });
                    return bounds;
                }
                return null;
            };
            /**
             * _AlertZone prototype (instance) functions.
             */
            this._AlertZone.prototype = {
                constructor: _outer._AlertZone,
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    _outer._notifyPropertyPathForZone(this,'name');
                },
                /**
                 * Sets the editable property and notifies the polymer path.
                 * @param editable
                 */
                setEditable: function(editable) {
                    this.editable = editable;
                    _outer._notifyPropertyPathForZone(this,'editable');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ editable: !!editable });
                    }
                },
                /**
                 * Sets the colour and notifies the polymer path.
                 * @param colour
                 */
                setColour: function(colour) {
                    colour = _outer._formatColour(colour);
                    this.colour = colour;
                    _outer._notifyPropertyPathForZone(this,'colour');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ 'fillColor': colour });
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    if (this.distanceBetweenPointsOverlay) {
                        this.distanceBetweenPointsOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity and notifies the polymer path.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    _outer._notifyPropertyPathForZone(this,'opacity');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets the paths and updates the shape overlay.
                 * @param paths
                 */
                setPaths: function(paths) {
                    this.paths = paths;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setPaths(paths);
                    }
                },
                /**
                 * Sets active, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    _outer._notifyPropertyPathForZone(this,'active');
                    active ? this.activateOverlay() : this.deactivateOverlay();
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    // Update the visibility of the radius overlay
                    this.manageCircleDistanceBetweenPointsOverlay();
                    // Handle the special case where we want to force display the stack marker on zone selection
                    if (!this.isCircle && this.getParentStack()) {
                        this.getParentStack()._forceToggleStackMarkerOnZoneActivation(active);
                    }
                },
                /**
                 * Sets whether this zone was derived from a file.
                 */
                setFromFile: function(fromFile) {
                    this.fromFile = !!fromFile;
                    _outer._notifyPropertyPathForZone(this,'fromFile');
                },
                /**
                 * Sets the northern coordinate and draws the nameOverlay.
                 * @param northernCoordinate
                 */
                setNorthernCoordinate: function(northernCoordinate) {
                    this.northernCoordinate = northernCoordinate;
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        this.nameOverlay = new _outer._ProximityZoneOverlay(this);
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ strokeWeight:3.0, fillOpacity: 0.30 });
                    }
                    // Notify the polymer path for editable so the properties sheet properly toggles off
                    // the zone reshaping message if the zone was deselected while reshaping was enabled
                    _outer._notifyPropertyPathForZone(this,'editable');
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ strokeWeight:0.50, fillOpacity: 0.25 });
                    }
                    // If reshaping is enabled then disable it since the zone was deselected
                    if (_outer._zoneToReshape === this) {
                        _outer._disableZoneReshaping();
                    }
                },
                /**
                 * Highlights the shape overlay by adding a border.
                 * @param showMarker - Whether to show the marker for moving the stack.
                 */
                highlightOverlay: function(showMarker) {
                    this.overlayHighlighted = true;
                    if (this.shapeOverlay && !this.active) {
                        this.shapeOverlay.setOptions({ strokeWeight: 2.0, fillOpacity: 0.30 });
                    }
                    // Redraw the overlay so the highlight styling updates
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    // Show the stack marker, if requested
                    if (showMarker) {
                        this.toggleStackMarker(true);
                    }
                },
                /**
                 * Restores the original shape overlay border.
                 */
                unHighlightOverlay: function() {
                    this.overlayHighlighted = false;
                    if (this.shapeOverlay && !this.active) {
                        this.shapeOverlay.setOptions({ strokeWeight:0.50, fillOpacity: 0.25 });
                    }
                    // Redraw the overlay so the highlight styling updates
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    // Hide the stack marker
                    this.toggleStackMarker(false);
                },
                /**
                 * Toggles the visibility of the stack marker.
                 */
                toggleStackMarker: function(visible) {
                    if (_outer.nodeName !== 'VOYENT-MOBILE-ALERT-EDITOR' &&
                        _outer._loadedAlert && _outer._loadedAlert.template && !this.fromFile) {
                        var stack = this.getParentStack();
                        // Toggle the stack marker if the zone and stack were not derived from a file import
                        if (stack && stack.marker && !stack.fromFile) {
                            if (visible) {
                                stack.marker.setOptions( { visible: true } );
                            }
                            else if (!stack.forceDisplayMarker && (!stack.coordinateOverlay || !stack.coordinateOverlay.editing)) {
                                stack.marker.setOptions( { visible: false } );
                            }
                        }
                    }
                },
                /**
                 * Returns the zone stack that this zone belongs to.
                 */
                getParentStack: function() {
                    if (!this.parentStack) {
                        this.parentStack = _outer._loadedAlert && _outer._loadedAlert.template && _outer._loadedAlert.template.getStackForZone(this);
                    }
                    return this.parentStack;
                },
                /**
                 * Hides this zone and all of its associated overlays.
                 */
                hide: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setVisible(false);
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.hide();
                    }
                    if (this.distanceBetweenPointsOverlay && this.distanceBetweenPointsOverlay.visible) {
                        this.distanceBetweenPointsOverlay.div.style.display = 'none';
                        if (this.polyline) {
                            this.polyline.setVisible(false);
                        }
                    }
                },
                /**
                 * Shows this zone and all of its associated overlays.
                 */
                show: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setVisible(true);
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.displayAndDraw();
                    }
                    if (this.distanceBetweenPointsOverlay && this.distanceBetweenPointsOverlay.visible) {
                        this.distanceBetweenPointsOverlay.displayAndDraw();
                        if (this.polyline) {
                            this.polyline.setVisible(true);
                        }
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setMap(null);
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.setMap(null);
                    }
                    if (this.distanceBetweenPointsOverlay) {
                        this.distanceBetweenPointsOverlay.setMap(null);
                    }
                    if (this.polyline) {
                        this.polyline.setMap(null);
                    }
                    this.polylineOuterCoordinate = null;
                },
                /**
                 * Manages the state and position of the distance between
                 * points (radius) polyline and associated overlay for circles.
                 */
                manageCircleDistanceBetweenPointsOverlay: function() {
                    if (this.isCircle) {
                        var path;
                        if (this.active) {
                            var bounds = _outer._AlertTemplate.calculateBoundsFromPaths(this.shapeOverlay.getPaths());
                            var center = bounds.getCenter();
                            this.polylineOuterCoordinate = { lat: center.lat(), lng: bounds.getNorthEast().lng() };
                            path = [
                                { lat: center.lat(), lng: center.lng() },
                                this.polylineOuterCoordinate
                            ];
                        }
                        this._manageDistanceBetweenPointsOverlay(this.active, path);
                    }
                },
                /**
                 * Manages the state and position of the distance between
                 * points polyline and associated overlay for polygons.
                 * @param enabled
                 * @param vertex
                 */
                managePolygonDistanceBetweenPointsOverlay: function(enabled, vertex) {
                    if (!this.isCircle) {
                        var path;
                        if (enabled) {
                            this.polylineOuterCoordinate = { lat: vertex.lat(), lng: vertex.lng() };
                            path = [this.getParentStack().marker.getPosition(), vertex];
                        }
                        this._manageDistanceBetweenPointsOverlay(enabled, path);
                    }
                },
                /**
                 * General function for managing the distance between points overlay for all shapes.
                 * @param enabled
                 * @param path
                 */
                _manageDistanceBetweenPointsOverlay: function(enabled, path) {
                    if (_outer.nodeName !== 'VOYENT-MOBILE-ALERT-EDITOR') {
                        if (enabled) {
                            if (!this.polyline) {
                                this.polyline = new google.maps.Polyline({
                                    path: path, map: _outer._map, strokeOpacity: 0.65, strokeWeight: 1.5
                                });
                                this.distanceBetweenPointsOverlay = new _outer._DistanceBetweenPointsOverlay(this);
                            }
                            else {
                                this.polyline.setMap(_outer._map);
                                this.polyline.setPath(path);
                                this.distanceBetweenPointsOverlay.displayAndDraw();
                            }
                        }
                        else {
                            if (this.polyline) {
                                this.polyline.setMap(null);
                            }
                            if (this.distanceBetweenPointsOverlay) {
                                this.distanceBetweenPointsOverlay.hide();
                            }
                        }
                    }
                },
                /**
                 * Returns the length, in meters, of this zone's polyline (radius
                 * for circles, distance between center and vertex for polygons).
                 */
                getPolylineLengthInMeters: function() {
                    var distance = 0;
                    if (this.polyline) {
                        var path = this.polyline.getPath();
                        for (var i = 0; i < path.getLength() - 1; i++) {
                            distance += google.maps.geometry.spherical.computeDistanceBetween(path.getAt(i), path.getAt(i + 1));
                        }
                    }
                    else {
                        // Since the polyline for circles is drawn lazily and we need to know the length of it for
                        // validating the radius input then we need to provide a fallback which calculates it manually
                        if (this.isCircle) {
                            var bounds = _outer._AlertTemplate.calculateBoundsFromPaths(this.shapeOverlay.getPaths());
                            var center = bounds.getCenter();
                            distance = google.maps.geometry.spherical.computeDistanceBetween(
                                center,
                                new google.maps.LatLng(center.lat(), bounds.getNorthEast().lng())
                            );
                        }
                    }
                    return Math.round(distance);
                },
                /**
                 * Returns the options for building a google maps polygon.
                 * @returns {*}
                 * @private
                 */
                _getShapeOverlayOpts: function() {
                    return {
                        clickable: _outer.nodeName !== 'VOYENT-ALERT-VIEW', draggable: false,
                        editable: false, fillColor: this.colour,
                        fillOpacity: this.opacity, map: _outer._map,
                        strokeWeight:0.50, zIndex:this.zIndex, paths:this.paths,
                        suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                    };
                }
            };
            Object.seal(this._AlertZone);

            /**
             * A class that represents the polygonal fallback alert zone.
             * @param enabled - Indicates whether the zone should be displayed immediately after initializing.
             * @param name - The user defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param notificationFilter - The notification filter associated with this zone.
             * @param acknowledgement - The acknowledgement data associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @private
             */
            this._FallbackAlertZone = function(enabled,name,opacity,colour,messageTemplate,notificationFilter,acknowledgement,zIndex) {
                this.id = _outer._FALLBACK_ZONE_ID;
                this.setPaths(this._buildWorldPolygon());
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
                this._setupOverlayClickListener();
                this.setName(name || 'Entire Region');
                this.setOpacity(/*opacity || */0.25); // Fixed opacity
                this.setColour(/*colour || */'9EAD9E'); // Fixed colour
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.messageTemplate = messageTemplate || null;
                this.notificationFilter = notificationFilter || null;
                this.acknowledgement = acknowledgement || null;
                this.nameOverlay = new _outer._FallbackZoneOverlay(this);
                this.setEnabled(enabled);
            };

            this._FallbackAlertZone.prototype = {
                /**
                 * Sets the paths and updates the shape overlay.
                 */
                setPaths: function(paths) {
                    this.paths = paths;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setPaths(paths);
                    }
                },
                /**
                 * Sets the name and notifies the polymer path.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    _outer._notifyPropertyPathForFallbackZone('name');
                },
                /**
                 * Sets the colour and notifies the polymer path.
                 * @param colour
                 */
                setColour: function(colour) {
                    colour = _outer._formatColour(colour);
                    this.colour = colour;
                    _outer._notifyPropertyPathForFallbackZone('colour');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ 'fillColor': colour });
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity and notifies the polymer path.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    _outer._notifyPropertyPathForFallbackZone('opacity');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets active, updates the overlay and notifies the polymer path.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    _outer._notifyPropertyPathForFallbackZone('active');
                    active ? this.activateOverlay() : this.deactivateOverlay();
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets enabled, updates the overlays and notifies the polymer path.
                 * @param enabled
                 */
                setEnabled: function(enabled) {
                    this.enabled = enabled;
                    _outer._notifyPropertyPathForFallbackZone('enabled');
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'visible':enabled});
                    }
                    if (enabled) {
                        _outer.fire('voyent-alert-zone-added',{"id":this.id,"zone":this,"isFallbackZone":true});
                        this.punchOutOverlay();
                        if (this.nameOverlay) {
                            this.nameOverlay.draw();
                        }
                    }
                    else {
                        _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                        if (this.nameOverlay) {
                            this.nameOverlay.hide();
                        }
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ fillOpacity: 0.40 });
                    }
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({ fillOpacity: 0.25 });
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    this.shapeOverlay.setMap(null);
                    if (this.nameOverlay) {
                        this.nameOverlay.hide();
                    }
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer._fallbackZone = null;
                    }
                    _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                },
                /**
                 * Punches out all of the stacks currently drawn on the map.
                 */
                punchOutOverlay: function() {
                    if (!this.enabled) { return; }
                    var paths = this._buildWorldPolygon();
                    if (_outer._loadedAlert) {
                        for (var i=0; i<_outer._loadedAlert.template.zoneStacks.length; i++) {
                            var outerZone = _outer._loadedAlert.template.zoneStacks[i].getOutermostZone();
                            //Ideally we would just push the paths directly from the drawn polygon but Google expects
                            //a specific "winding order" of the coordinates. Whichever direction the coordinates
                            //are in for the outer zone, the coordinates for the inner "punched out" zones
                            //must be in the opposite direction. Google handles this ordering when using the Data Layer
                            //API, however, this is overly complex for our purposes. Instead we'll use turf to
                            //reorder the zones by punching them out and returning the newly sorted coordinates.

                            //Convert the array of fallback zone coordinates to a proper MVC paths array.
                            var fallbackPaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                new google.maps.MVCArray([new google.maps.MVCArray(paths[0])])
                            )[0]];
                            //Select only the outer ring of the outermost zone in the stack.
                            var largestZonePaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                outerZone.shapeOverlay.getPaths()
                            )[0]];
                            //Do the punch out.
                            var doughnut = turf.difference({
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": fallbackPaths
                                    }
                                }, {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": largestZonePaths
                                    }
                                }
                            );
                            //The coordinates will now be in the correct order so we want to convert them back to paths
                            //and then use this to draw the Polygon. In this case, we don't use the punched out
                            //zone at all. This was only for the purposes of correctly ordering the coordinates list.
                            var orderedLargestZonePaths = _outer._AlertTemplate.calculatePathsFromCoordinates(
                                doughnut.geometry.coordinates
                            )[1];
                            paths.push(orderedLargestZonePaths);
                        }
                    }
                    //The path at index 0 will be the entire fallback zone and
                    //all of the other paths will be punched out stacks.
                    this.setPaths(paths);
                },
                /**
                 * Returns a rectangular polygon representing the entire world.
                 */
                _buildWorldPolygon: function() {
                    //Since Google Maps uses a special web version of the Mercator projection and it
                    //excludes the polar regions the maximum latitude is closer to 85° instead of 90°.
                    var worldCoords = [
                        new google.maps.LatLng(85.05113, 180), new google.maps.LatLng(0, 180),
                        new google.maps.LatLng(-85.05113, 180), new google.maps.LatLng(-85.05113, 90),
                        new google.maps.LatLng(-85.05113, 0), new google.maps.LatLng(-85.05113, -90),
                        new google.maps.LatLng(-85.05113, -180), new google.maps.LatLng(0, -180),
                        new google.maps.LatLng(85.05113, -180), new google.maps.LatLng(85.05113, -90),
                        new google.maps.LatLng(85.05113, 0),new google.maps.LatLng(85.05113, 90),
                        new google.maps.LatLng(85.05113, 180)
                    ];
                    return [new google.maps.MVCArray(worldCoords).getArray()];
                },
                /**
                 * Initializes click listener for activating the overlay.
                 * @private
                 */
                _setupOverlayClickListener: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    google.maps.event.addListener(this.shapeOverlay, 'click', function () {
                        // Don't allow de-selecting the zone
                        if (!_outer._fallbackZone.active) {
                            _outer._toggleFallbackZoneProperties();
                        }
                    });
                },
                /**
                 * Returns the options for building a google maps polygon.
                 * @returns {*}
                 * @private
                 */
                _getShapeOverlayOpts: function() {
                    return {
                        clickable: true, draggable: false,
                        editable: false, fillColor: this.colour,
                        fillOpacity: this.opacity, map: _outer._map,
                        strokeWeight:0, zIndex:this.zIndex, paths:this.paths,
                        suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                    };
                }
            };
            Object.seal(this._FallbackAlertZone);

            /**
             * A class that represents a user's fixed location record, both the drawn map entity and the json.
             * @param id - The system-generated id.
             * @param name - The user-defined name.
             * @param type - The type of location (`mobile`, `residential`, `other`).
             * @param marker - The associated map marker.
             * @param endpointType - The endpoint type (`apns`, `fcm`, `mailto`, `sms`, `voice`) that this location is associated with, if applicable.
             * @private
             */
            this._MyLocation = function(id,name,type,marker,endpointType) {
                this.isPersisted = !!id;
                this.id = id || _outer._generateUid();
                this.setName(name || '');
                this.setType(type || 'other');
                this.setMarker(marker);
                this.endpointType = endpointType;
            };
            this._MyLocation.prototype = {
                constructor: _outer._MyLocation,
                /**
                 * Sets the name, draws the nameOverlay and notifies the polymer path.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    _outer.notifyPath('_loadedLocation.name');
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        // Don't show the floating name overlay label when Viewing an Alert in certain modes
                        if (name && (_outer.nodeName !== 'VOYENT-ALERT-VIEW' || _outer.mode === 'notification')) {
                            this.nameOverlay = new _outer._LocationOverlay(this);
                        }
                    }
                },
                /**
                 * Sets the type and notifies the polymer path.
                 * @param type
                 */
                setType: function(type) {
                    this.type = type;
                    _outer.notifyPath('_loadedLocation.type');
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function(marker) {
                    this.marker = marker;
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Adds the location to the map. Used to reverse `removeFromMap`.
                 */
                addToMap: function() {
                    this.marker.setMap(_outer._map);
                    if (this.nameOverlay) {
                        this.nameOverlay.displayAndDraw();
                    }
                },
                /**
                 * Removes the location from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    if (this.nameOverlay) {
                        this.nameOverlay.hide();
                    }
                },
                /**
                 * Updates the JSON to reflect the current state of the template.
                 */
                updateJSON: function() {
                    var markerPosition = this.marker.getPosition();
                    this.json = {
                        "location": {
                            "geometry": {
                                "type": "Point",
                                "coordinates": [markerPosition.lng(),markerPosition.lat()]
                            },
                            "properties": {
                                "vras": {
                                    "id": this.id,
                                    "name": this.name,
                                    "type": this.type
                                }
                            }
                        }
                    }
                },
                /**
                 * Initializes marker listeners for the location.
                 * @private
                 */
                _setupMarkerListeners: function() {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //Continuously re-draw the overlay as the location is dragged.
                    var marker = this.marker;
                    google.maps.event.addListener(marker,'drag',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.draw();
                        }
                    });
                    //Update the coordinates on the location record and flag the location for updating after it's dragged.
                    google.maps.event.addListener(marker,'dragend',function() {
                        _outer._saveLocation(_this,'moved');
                    });
                    //Display infoWindow on location marker click.
                    google.maps.event.addListener(marker,'click',function() {
                        _outer._toggleInfoWindow(_this);
                    });
                    //Adjust the stacking order of the name on mouseover and mouseout.
                    google.maps.event.addListener(marker,'mouseover',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.moveToTopPane();
                        }
                    });
                    google.maps.event.addListener(marker,'mouseout',function() {
                        if (_this.nameOverlay) {
                            _this.nameOverlay.moveToDefaultPane();
                        }
                    });
                }
            };
            Object.seal(this._MyLocation);

            /**
             * A class that represents the fallback zone control overlay.
             * @private
             */
            this._FallbackZoneOverlay = function(zone) {
                this.zone = zone;
                this.div = _outer._buildOverlayDiv(false, false, _outer._isAnAlertEditor());
                if (zone.enabled) {
                    this.draw();
                }
            };
            this._FallbackZoneOverlay.prototype = {
                /**
                 * Handles drawing and re-drawing of the fallback zone control overlay on the map.
                 */
                draw: function() {
                    //Set the div content, replacing spaces with non-breaking ones.
                    this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                    //Configure additional styling.
                    if (this.zone.active) {
                        this.div.style.fontSize = '14px';
                    }
                    else {
                        this.div.style.fontSize = '12px';
                    }
                    this.div.style.backgroundColor = this.zone.colour;
                    this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
                    this.div.style.opacity = !_outer._isAnAlertEditor() || this.zone.active
                        ? '1'
                        : '0.25';
                    if (!_outer._map.controls[google.maps.ControlPosition.TOP_CENTER].length) {
                        _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].push(this.div);
                    }
                },
                /**
                 * Hide the control overlay.
                 */
                hide: function() {
                    _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].clear();
                }
            };
            /**
             * A class that represents a zone name overlay.
             * @param zone - The zone for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._ProximityZoneOverlay = function(zone) {
                var _this = this;
                this.zone = zone;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv(false, false, _outer._isAnAlertEditor());
                if (!_outer._isAnAlertEditor()) {
                    // Bring the label to top on mouseover
                    this.div.onmouseover = function () {
                        _this.moveToTopPane();
                    };
                    this.div.onmouseout = function () {
                        _this.moveToDefaultPane();
                    };
                }
            };
            /**
             * A class that represents a location name overlay.
             * @param location - The location for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._LocationOverlay = function(location) {
                var _this = this;
                this.loc = location;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv(true);
                this.div.style.cursor = 'pointer';
                if (_outer.nodeName === 'VOYENT-MY-LOCATIONS') {
                    // Add some listeners to support info window toggling via label selection
                    this.div.onmouseover = function () {
                        _this.moveToTopPane();
                    };
                    this.div.onmouseout = function () {
                        _this.moveToDefaultPane();
                    };
                    this.div.onclick = function() {
                        _outer._toggleInfoWindow(_this.loc);
                    };
                }
            };
            /**
             * A class representing the overlay displayed when holding the mouse down on the my locations map.
             * @param latLng - A google.maps.LatLng object indicating the position of the overlay.
             * @param pixelCoordinates - An object containing x and y coordinates of the mouse position relative to the map.
             * @extends google.maps.OverlayView
             * @private
             */
            this._MouseHoldOverlay = function(latLng,pixelCoordinates) {
                this.latLng = latLng;
                this.pixelCoordinates = pixelCoordinates;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv(true);
                //Setup our transition and opacity so we can fade this overlay in.
                this.div.style.opacity = '0';
                this.div.style.webkitTransition = 'opacity 0.5s';
                this.div.style.transition = 'opacity 0.5s';
            };
            /**
             * A class that represents the current mobile location icon overlay.
             * @param latLng - A google.maps.LatLng object indicating the position of the overlay.
             * @extends google.maps.OverlayView
             * @private
             */
            this._MobileLocationOverlay = function(latLng) {
                this.latLng = latLng;
                this.div = _outer._buildOverlayDiv(true);
                this.visible = true;
                this.setMap(_outer._map);
            };
            /**
             * A class representing the overlay displayed for showing the distance between two points.
             * @extends google.maps.OverlayView
             * @private
             */
            this._DistanceBetweenPointsOverlay = function(zone) {
                this.zone = zone;
                this.setMap(_outer._map);
                this.div = _outer._buildDistanceBetweenPointsOverlayDiv(zone);
                this.visible = true;
                this.editing = false;
                this.active = false;
            };
            /**
             * A class representing the stack coordinate overlay.
             */
            this._CoordinateOverlay = function(stack) {
                this.stack = stack;
                this.setMap(_outer._map);
                this.div = _outer._buildCoordinateOverlayDiv(stack);
                this.editing = false;
                this.active = false;
                this.visible = true;
            };
            /**
             * A class representing the stack coordinate overlay.
             */
            this._ImageOverlay = function(stack, imgUrl, imgDimensions, onclickListener) {
                this.stack = stack;
                var elements = _outer._buildImageOverlayDiv(imgUrl, imgDimensions, onclickListener);
                this.div = elements.div;
                this.img = elements.img;
                this.setMap(_outer._map);
                this.visible = true;
            };
            // Inherit the prototype of google.maps.OverlayView
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();
            this._LocationOverlay.prototype = new google.maps.OverlayView();
            this._MouseHoldOverlay.prototype = new google.maps.OverlayView();
            this._MobileLocationOverlay.prototype = new google.maps.OverlayView();
            this._DistanceBetweenPointsOverlay.prototype = new google.maps.OverlayView();
            this._CoordinateOverlay.prototype = new google.maps.OverlayView();
            this._ImageOverlay.prototype = new google.maps.OverlayView();
            /**
             * Called automatically when the map is ready for the overlay to be attached.
             */
            this._LocationOverlay.prototype.onAdd =
            this._MouseHoldOverlay.prototype.onAdd =
            this._DistanceBetweenPointsOverlay.prototype.onAdd =
            this._CoordinateOverlay.prototype.onAdd = function() {
                // Add the div to the overlayMouseTarget pane so it renders above the markers
                this.getPanes().overlayMouseTarget.appendChild(this.div);
            };
            this._MobileLocationOverlay.prototype.onAdd =
            this._ImageOverlay.prototype.onAdd = function() {
                // Add the div to the floatPane pane so it renders above everything
                this.getPanes().floatPane.appendChild(this.div);
            };
            this._ProximityZoneOverlay.prototype.onAdd = function() {
                // If this is an alert editor then add the div to the overlayLayer pane so it renders below the markers
                if (_outer._isAnAlertEditor()) {
                    this.getPanes().overlayLayer.appendChild(this.div);
                }
                else { // Otherwise add the div to the overlayMouseTarget pane so it renders above the markers
                    this.getPanes().overlayMouseTarget.appendChild(this.div);
                }
            };
            /**
             * Handles drawing and re-drawing of the proximity zone overlay on the map.
             */
            this._ProximityZoneOverlay.prototype.draw = function() {
                //This will be called before it's ready when loading Alerts so we'll return if the prototype isn't initialized.
                if (!this.getProjection()) { return; }
                // Convert the lat/lng coordinates to pixel coordinates
                var northernCoordinate = this.zone.northernCoordinate;
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(northernCoordinate[1],northernCoordinate[0])
                );
                //Set the div content, replacing spaces with non-breaking ones.
                this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                //Configure additional styling.
                if (this.zone.active) {
                    this.div.style.fontSize = '14px';
                    this.div.style.top = northWestPixelPosition.y-28 + 'px';
                }
                else {
                    this.div.style.fontSize = '12px';
                    this.div.style.top = northWestPixelPosition.y-26 + 'px';
                }
                this.div.style.left = (northWestPixelPosition.x - this.div.offsetWidth/2) + 'px';
                this.div.style.backgroundColor = this.zone.colour;
                this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
                this.div.style.opacity = !_outer._isAnAlertEditor() || this.zone.active
                    ? '1'
                    : this.zone.overlayHighlighted ? '0.30' : '0.25';
            };
            /**
             * Handles drawing and re-drawing of the location overlay on the map.
             */
            this._LocationOverlay.prototype.draw = function () {
                // Convert the lat/lng coordinates to pixel coordinates
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(this.loc.marker.getPosition());
                //Set the div content.
                this.div.innerHTML = this.loc.name;
                //Center the label above the location.
                this.div.style.left = (northWestPixelPosition.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = northWestPixelPosition.y-64 + 'px';
                //Configure additional styling.
                this.div.style.backgroundColor = '#64FE86';
                this.div.style.color = '#000000';
            };
            /**
             * Handles drawing the mouse hold overlay on the my locations map.
             */
            this._MouseHoldOverlay.prototype.draw = function () {
                // Convert the lat/lng coordinates to pixel coordinates
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(this.latLng);
                //Set the div content.
                this.div.innerHTML = 'Release ' + (_outer.isMobile ? 'Finger' : 'Mouse') +' to Create Location';
                //Generally we will render the overlay x pixels above where the user selects. If this position will be hidden
                //because they selected near the top of the map then we will render 10 pixels below instead. If they select on
                //the left or right edge then we will adjust the position to the side to ensure the entire overlay is within view.
                var halfWidth = this.div.offsetWidth/2;
                if (this.pixelCoordinates.x > halfWidth) {
                    //If the overlay is being rendered near the right edge of the map
                    //then we will have a renderRightOffset otherwise just use 0.
                    var renderRightOffset = (this.pixelCoordinates.x + halfWidth) - _outer._map.getDiv().clientWidth;
                    renderRightOffset = renderRightOffset > 0 ? renderRightOffset : 0;
                    this.div.style.left = (northWestPixelPosition.x - halfWidth) - renderRightOffset + 'px';
                }
                else {
                    //If we fall into here it means we are drawing this overlay close to the left edge of
                    //the map. In this case we want to ensure that we render the overlay entirely in view.
                    var renderLeftOffset = halfWidth - this.pixelCoordinates.x;
                    this.div.style.left = (northWestPixelPosition.x - halfWidth) + renderLeftOffset + 'px';
                }
                //Render further from coordinate on mobile since the user's finger is in the way.
                var generalPixelOffset = _outer.isMobile ? 45 : 10;
                var renderAboveOffset = this.div.offsetHeight+generalPixelOffset;
                this.div.style.top = (this.pixelCoordinates.y > renderAboveOffset
                    ? northWestPixelPosition.y-this.div.offsetHeight-generalPixelOffset
                    : northWestPixelPosition.y+generalPixelOffset) + 'px';
                //Configure additional styling.
                this.div.style.backgroundColor = '#88b7d5';
                this.div.style.border = '2px solid #c2e1f5';
                this.div.style.borderRadius = '20px';
                this.div.style.opacity = '0.9';
                this.div.style.padding = '5px';
            };
            /**
             * Handles drawing the mobile location icon overlay.
             */
            this._MobileLocationOverlay.prototype.draw = function () {
                // Convert the lat/lng coordinates to pixel coordinates
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(this.latLng);
                // Set the div content
                this.div.innerHTML = '<img src="'+_outer.pathtoimages+'/img/gps.png'+'">';
                // Center the content at the exact coordinate
                this.div.style.left = (northWestPixelPosition.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = (northWestPixelPosition.y - this.div.offsetHeight/2) + 'px';
            };
            /**
             * Handles drawing the distance between points overlay.
             */
            this._DistanceBetweenPointsOverlay.prototype.draw = function() {
                // Convert the lat/lng coordinates to pixel coordinates
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(
                        this.zone.polylineOuterCoordinate.lat,
                        this.zone.polylineOuterCoordinate.lng
                    )
                );
                // Update the distance value
                var input = this.div.querySelector('input');
                input.value = this.zone.getPolylineLengthInMeters();
                input.style.width = input.value.length + 'ch';
                // Position the input to the right for circles and centered below for polygons
                if (this.zone.isCircle) {
                    this.div.style.left = (northWestPixelPosition.x + 7) + 'px';
                    this.div.style.top = (northWestPixelPosition.y - 17) + 'px';
                }
                else {
                    this.div.style.left = (northWestPixelPosition.x - this.div.offsetWidth/2) + 'px';
                    this.div.style.top = (northWestPixelPosition.y + 15) + 'px';
                }
                // Additional zone-specific styling
                this.div.style.backgroundColor = 'grey';
                this.div.style.color = 'white';
                this.div.style.borderColor = this.editing || this.active ? this.div.style.color : 'transparent';
            };
            /**
             * Handles drawing the stack coordinate overlay.
             */
            this._CoordinateOverlay.prototype.draw = function() {
                // Convert the lat/lng coordinates to pixel coordinates
                var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(
                        this.stack.lat,
                        this.stack.lng
                    )
                );
                // Update the coordinate inputs
                var latInput = this.div.querySelector('input.lat');
                latInput.value = this.stack.lat;
                latInput.style.width = latInput.value.length - 1 + 'ch';

                var lngInput = this.div.querySelector('input.lng');
                lngInput.value = this.stack.lng;
                lngInput.style.width = lngInput.value.length - 1 + 'ch';

                // Position the coordinate overlay 3px below the stack marker and horizontally centered
                this.div.style.left = (northWestPixelPosition.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = (northWestPixelPosition.y + 8) + 'px';

                // Styling the overlay based on the innermost zone
                this.div.style.backgroundColor = 'grey';
                this.div.style.color = 'white';
                this.div.style.borderColor = this.editing  || this.active ? this.div.style.color : 'transparent';
            };
            /**
             * Handles drawing the image overlay.
             */
            this._ImageOverlay.prototype.draw = function() {
                // This may be called before it's ready so return if the prototype isn't initialized
                if (!this.getProjection()) {
                    return;
                }
                if (this.visible) {
                    // Convert the lat/lng coordinates to pixel coordinates
                    var northWestPixelPosition = this.getProjection().fromLatLngToDivPixel(
                        _outer._AlertTemplate.calculateCentroidFromPaths(
                            this.stack.getOutermostZone().shapeOverlay.getPaths()
                        )
                    );
                    // Adjust the image position so the center of it located at the center of the outermost zone
                    this.div.style.left = (northWestPixelPosition.x - (this.img.clientWidth/2)) + 'px';
                    this.div.style.top = (northWestPixelPosition.y - (this.img.clientHeight/2)) + 'px';
                    // Hide the stack
                    this.stack.hide();
                }
            };
            /**
             * Cleans up the overlay whenever the overlays map property is set to null.
             */
            this._ProximityZoneOverlay.prototype.onRemove =
            this._LocationOverlay.prototype.onRemove =
            this._MouseHoldOverlay.prototype.onRemove =
            this._MobileLocationOverlay.prototype.onRemove =
            this._DistanceBetweenPointsOverlay.prototype.onRemove =
            this._CoordinateOverlay.prototype.onRemove =
            this._ImageOverlay.prototype.onRemove = function () {
                if (this.div && this.div.parentNode) {
                    this.div.parentNode.removeChild(this.div);
                    this.div = null;
                }
            };
            /**
             * Hide the overlay.
             */
            this._ProximityZoneOverlay.prototype.hide =
            this._LocationOverlay.prototype.hide =
            this._MobileLocationOverlay.prototype.hide =
            this._DistanceBetweenPointsOverlay.prototype.hide =
            this._CoordinateOverlay.prototype.hide = function() {
                this.div.style.display = 'none';
                if (this.disableEditingMode) {
                    this.disableEditingMode();
                }
                this.visible = false;
            };
            /**
             * Hide the overlay and show the associated stack.
             */
            this._ImageOverlay.prototype.hide = function() {
                this.div.style.display = 'none';
                this.visible = false;
                this.stack.show();
            };
            /**
             * Re-display the overlay.
             */
            this._ProximityZoneOverlay.prototype.displayAndDraw =
            this._LocationOverlay.prototype.displayAndDraw =
            this._MobileLocationOverlay.prototype.displayAndDraw =
            this._DistanceBetweenPointsOverlay.prototype.displayAndDraw =
            this._CoordinateOverlay.prototype.displayAndDraw =
            this._ImageOverlay.prototype.displayAndDraw = function() {
                this.div.style.display = 'block';
                this.visible = true;
                this.draw();
            };
            /**
             * Enables editing mode styling for the distance and coordinate overlays.
             */
            this._DistanceBetweenPointsOverlay.prototype.enableEditingMode =
            this._CoordinateOverlay.prototype.enableEditingMode = function() {
                var buttons = this.div.querySelector('.buttons');
                if (buttons) {
                    this.div.style.borderColor = this.div.style.color;
                    buttons.style.display = 'block';
                }
                this.editing = true;
            };
            /**
             * Disables editing styling for the distance and coordinate overlays.
             */
            this._DistanceBetweenPointsOverlay.prototype.disableEditingMode =
            this._CoordinateOverlay.prototype.disableEditingMode = function() {
                var buttons = this.div.querySelector('.buttons');
                if (buttons) {
                    this.div.style.borderColor = 'transparent';
                    buttons.style.display = 'none'
                }
                var inputs = this.div.querySelectorAll('input');
                if (inputs && inputs.length) {
                    for (var i=0; i<inputs.length; i++) {
                        inputs[i].blur();
                    }
                }
                this.editing = false;
            };
            /**
             * Highlights the distance and coordinate overlays by adding a border.
             */
            this._DistanceBetweenPointsOverlay.prototype.highlight =
            this._CoordinateOverlay.prototype.highlight = function() {
                if (!this.editing) {
                    this.div.style.borderColor = this.div.style.color;
                    this.active = true;
                }
            };
            /**
             * Restores the original border styling for the distance and coordinate overlays.
             */
            this._DistanceBetweenPointsOverlay.prototype.unHighlight =
            this._CoordinateOverlay.prototype.unHighlight = function() {
                if (!this.editing) {
                    this.div.style.borderColor = 'transparent';
                    this.active = false;
                }
            };
            this._ImageOverlay.prototype.updateImgUrl = function(imageUrl) {
                this.img.src = imageUrl;
            };
            /**
             * Moves the zone overlay to a map pane with a higher stacking priority.
             */
            this._ProximityZoneOverlay.prototype.moveToTopPane = function() {
                if (!_outer._isAnAlertEditor()) {
                    // Move the overlay to a pane with a higher stacking priority
                    this.getPanes().overlayMouseTarget.appendChild(this.div);
                }
            };
            /**
             * Moves the zone overlay to the default map pane.
             */
            this._ProximityZoneOverlay.prototype.moveToDefaultPane = function() {
                if (!_outer._isAnAlertEditor()) {
                    // Move the overlay to the default pane
                    this.getPanes().floatShadow.appendChild(this.div);
                }
            };
            /**
             * Update the latLng object associated with the mobile location overlay instance and draws the overlay.
             */
            this._MobileLocationOverlay.prototype.setLatLng = function (latLng) {
                this.latLng = latLng;
                this.displayAndDraw();
            };
            /**
             * Moves the location overlay to a map pane with a higher stacking priority.
             */
            this._LocationOverlay.prototype.moveToTopPane = function() {
                // Add a border and slightly adjust the position of the overlay
                // so it doesn't appear to shift due to the new border
                this.div.style.borderStyle = 'solid';
                this.div.style.borderWidth = '1px';
                var newTop = parseFloat(this.div.style.top.substr(0,this.div.style.top.indexOf('px'))) - 1;
                this.div.style.top = newTop + 'px';
                var newLeft = parseFloat(this.div.style.left.substr(0,this.div.style.left.indexOf('px'))) - 1;
                this.div.style.left = newLeft + 'px';
                // Move the overlay to a pane with a higher stacking priority + adjust marker z-index
                this.getPanes().overlayMouseTarget.appendChild(this.div);
                this.loc.marker.setZIndex(100);
                // Move the other overlays to a pane with a lower stacking priority so they will hide behind this overlay's marker
                for (var i=0; i<_outer._myLocations.length; i++) {
                    if (this !== _outer._myLocations[i].nameOverlay) {
                        this.getPanes().overlayLayer.appendChild(_outer._myLocations[i].nameOverlay.div);
                    }
                }
            };
            /**
             * Moves the location overlay to the default map pane.
             */
            this._LocationOverlay.prototype.moveToDefaultPane = function() {
                // Remove the border and positioning
                this.div.style.borderStyle = 'none';
                this.div.style.borderWidth = '0px';
                var newTop = parseFloat(this.div.style.top.substr(0,this.div.style.top.indexOf('px'))) + 1;
                this.div.style.top = newTop + 'px';
                var newLeft = parseFloat(this.div.style.left.substr(0,this.div.style.left.indexOf('px'))) + 1;
                this.div.style.left = newLeft + 'px';
                // Move the overlay to the default pane + adjust marker z-index
                this.getPanes().floatShadow.appendChild(this.div);
                this.loc.marker.setZIndex(50);
                // Move the other overlays to the default pane
                for (var i=0; i<_outer._myLocations.length; i++) {
                    if (this !== _outer._myLocations[i].nameOverlay) {
                        this.getPanes().floatShadow.appendChild(_outer._myLocations[i].nameOverlay.div);
                    }
                }
            };
            /**
             * Returns a font colour of black or white based on the zone colour.
             */
            this._FallbackZoneOverlay.prototype.returnColourBasedOnBackground =
            this._ProximityZoneOverlay.prototype.returnColourBasedOnBackground = function(hex) {
                // Chop any leading # character
                if (hex.charAt(0) === '#') {
                    hex = hex.substr(1);
                }
                return (
                    0.213 * parseInt(hex.slice(0, 2), 16) +
                    0.715 * parseInt(hex.slice(2, 4), 16) +
                    0.072 * parseInt(hex.slice(4, 6), 16) >
                    255 / 2
                ) ? '#000' : '#FFF';
            };
            Object.seal(this._FallbackZoneOverlay);
            Object.seal(this._ProximityZoneOverlay);
            Object.seal(this._LocationOverlay);
            Object.seal(this._MouseHoldOverlay);
            Object.seal(this._MobileLocationOverlay);
        }
    };
</script>