<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {

        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'}
        },

        ready: function() {
            this._loadedAlertTemplateData = null;
        },

        /**
         * Initialize google map listeners for moving, resizing and clicking of Alert Templates.
         * @param alertIndex - Optional.
         * @private
         */
        _setupChangeListeners: function(alertIndex) {
            var _this = this;
            (function(alertIndex) {
                var alertTemplateData = typeof alertIndex !== 'undefined' && alertIndex !== -1 ?
                    _this._alerts[alertIndex] : _this._loadedAlertTemplateData;

                if (alertTemplateData.marker) {
                    //Clear any previously added listeners (since we call this function again for newly added zones).
                    google.maps.event.clearInstanceListeners(alertTemplateData.marker);
                    //Add drag listener to marker.
                    google.maps.event.addListener(alertTemplateData.marker, 'dragend', function (me) {
                        //Update the template coordinates (always required to maintain label positions).
                        _this._updateAlertTemplateJSON(alertTemplateData);
                        if (alertTemplateData.alertInstance) {
                            //Update the Alert's location.
                            _this._updateAlertLocation(alertTemplateData);
                        }
                        //Adjust the position of the Proximity Zone labels since all of
                        //their positions changed. We pass in the necessary alertTemplateData
                        //since it's possible they dragged an Alert without it being active.
                        _this._redrawZoneOverlay(alertTemplateData);
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(alertTemplateData.marker, 'click', function () {
                        //If we have a currently loaded Alert Template or Alert...
                        if (_this._loadedAlertTemplateData) {
                            //If they click the marker for the currently active Alert Template or Alert
                            //marker then toggle then de-select the zones and close the accordion.
                            if (_this._loadedAlertTemplateData === alertTemplateData) {
                                _this._toggleAccordion(-1);
                            }
                            //If they clicked on an Alert that is not currently active then disable
                            //edits and toggle the accordion for the previously selected Alert zones.
                            if (_this._loadedAlertTemplateData !== alertTemplateData) {
                                _this._toggleAccordion(-1);
                                _this._toggleEditableZones(false);
                            }
                        }
                        //Regardless of if an Alert was previously loaded, if a new Alert
                        //was clicked load it and set the editable state of the zones.
                        if (_this._loadedAlertTemplateData !== alertTemplateData) {
                            _this._loadedAlertTemplateData = alertTemplateData;
                            _this._toggleEditableZones(true);
                        }
                    });
                }
                if (alertTemplateData.circles) {
                    for (var i=0; i<alertTemplateData.circles.length; i++) {
                        var circle = alertTemplateData.circles[i];
                        (function(circle){
                            //Clear any previously added listeners (since we call this function again for newly added zones).
                            google.maps.event.clearInstanceListeners(circle);
                            //Add resize listener to circles.
                            google.maps.event.addListener(circle, 'radius_changed', function () {
                                //Update the JSON since the size of a zone changed.
                                _this._updateAlertTemplateJSON(alertTemplateData);
                                //Adjust the position of the Proximity Zone label since the radius changed.
                                _this._redrawZoneOverlay(alertTemplateData,alertTemplateData.circles.indexOf(circle));
                            });
                            //Add click listener to circles.
                            google.maps.event.addListener(circle, 'click', function () {
                                var circleIndex = alertTemplateData.circles.indexOf(circle);
                                //If we have a currently loaded Alert Template or Alert...
                                if (_this._loadedAlertTemplateData) {
                                    //If they click a zone for the currently active
                                    //Alert Template or Alert then toggle the accordion.
                                    if (_this._loadedAlertTemplateData === alertTemplateData) {
                                        _this._toggleAccordion(circleIndex);
                                    }
                                    //If they clicked on an Alert that is not currently active then disable
                                    //edits to the previously selected Alert zones and toggle the accordion.
                                    if (_this._loadedAlertTemplateData !== alertTemplateData) {
                                        _this._toggleAccordion(-1);
                                        _this._toggleEditableZones(false);
                                    }
                                }
                                //Regardless of if an Alert was previously loaded, if a new Alert was clicked
                                //load it, toggle the accordion amd set the editable state of the zones.
                                if (_this._loadedAlertTemplateData !== alertTemplateData) {
                                    _this._loadedAlertTemplateData = alertTemplateData;
                                    _this._toggleAccordion(circleIndex);
                                    _this._toggleEditableZones(true);
                                }
                                // Fire an event for anyone interested
                                _this.fire('voyent-alert-template-click', {
                                    'alertTemplate': alertTemplateData.alertTemplate,
                                    'selectedZone': circleIndex
                                });
                            });
                        })(circle);
                    }
                }
            })(alertIndex);
        },
        /**
         * Updates the current Alert Location using the passed data or the current Alert Template data.
         * @param alertTemplateData
         * @private
         */
        _updateAlertLocation: function(alertTemplateData) {
            var _this = this, coordinates, zoneNamespace;
            var activatingAlert = this._activatingAlert;
            if (activatingAlert) {
                //We don't have existing Alert data yet so base the location
                //off the template position an set a new zoneNamespace.
                alertTemplateData = this._loadedAlertTemplateData;
                coordinates = alertTemplateData.alertTemplate.anchor.geometry.coordinates;
                zoneNamespace = new Date().getTime().toString();
                //Disable activation mode and show the existing Alerts again (do this immediately for a responsive UI).
                _this._toggleActivatingAlert();
                this._toggleActiveAlerts(true);
            }
            else {
                //We have a existing Alert data so base the location off
                //the marker position an use the existing zoneNamespace.
                var pos = alertTemplateData.marker.getPosition();
                coordinates = [pos.lng(),pos.lat()];
                zoneNamespace = alertTemplateData.alertInstance.location.properties.zoneNamespace;
            }
            //Create the new Alert location.
            var location = {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : coordinates },
                    "properties": {
                        "trackerId": alertTemplateData.alertTemplate._id,
                        "zoneNamespace": zoneNamespace
                    }
                }
            };
            voyent.locate.updateTrackerLocation({location: location}).then(function(data) {
                //Always update our stored instance location.
                _this.set('_loadedAlertTemplateData.alertInstance',location);
                if (activatingAlert) {
                    //Update our list of Alerts and o.
                    _this._alerts.push(alertTemplateData);
                    //Keep the overlay alert index in sync.
                    for (var i = 0; i < alertTemplateData.zoneOverlays.length; i++) {
                        alertTemplateData.zoneOverlays[i].setAlertIndex(_this._alerts.length - 1);
                    }
                    //Restore the create button.
                    _this._addAlertButton();
                    _this.fire('message-info', 'New Alert Activated!');
                }
            }).catch(function (error) {
                _this.fire('message-error', 'Issue creating new Alert: ' + location.location.properties.zoneNamespace);
                console.error('Issue creating new Alert: ' + location.location.properties.zoneNamespace, error);
            });
        },

        /**
         * Toggles the editable state of the currently active Alert Template or Alert zones.
         * If true we will set the Editable value to what is saved in the Alert Template.
         * @param editable
         * @private
         */
        _toggleEditableZones: function(editable) {
            for (var i=0; i<this._loadedAlertTemplateData.circles.length; i++) {
                this._loadedAlertTemplateData.circles[i].setEditable(editable ? this._loadedAlertTemplateData.alertTemplate.zones.features[i].properties.Editable : false);
            }
        },

        /**
         * Syncs the alertTemplate JSON with the current state of the map entities.
         * @param alertTemplateData
         * @private
         */
        _updateAlertTemplateJSON: function (alertTemplateData) {
            if (!alertTemplateData) {
                alertTemplateData = this._loadedAlertTemplateData;
            }
            if (!alertTemplateData) { return; }
            //Sync the marker coordinates (if available) with the alertTemplate
            //anchor in case the alertTemplate position has moved.
            if (alertTemplateData.marker) {
                alertTemplateData.alertTemplate.anchor.geometry.coordinates = [alertTemplateData.marker.getPosition().lng(),alertTemplateData.marker.getPosition().lat()];
            }
            var features = alertTemplateData.alertTemplate.zones.features;
            var N = 50; //The number of coordinates the circle approximation will have.
            var degreeStep = 360 / N; //The number of degrees in which each coordinate will be spaced apart.
            //Use the following two vars to calculate and store the northern most point of a Proximity
            //Zone circle. This is used to calculate where to render the Proximity Zone overlay label.
            var highestLat;
            alertTemplateData.highestLats = [];
            for (var i=0; i<features.length; i++) {
                highestLat = -100;
                //Sync the alertTemplate zone properties with the zones drawn on the map (if available).
                if (alertTemplateData.circles.length) {
                    features[i].properties.Editable = alertTemplateData.circles[i].getEditable();
                    features[i].properties.googleMaps.radius = alertTemplateData.circles[i].getRadius();
                    features[i].properties.googleMaps.center = [alertTemplateData.circles[i].getCenter().lat(),alertTemplateData.circles[i].getCenter().lng()];
                    features[i].properties.Color = alertTemplateData.circles[i].get('fillColor').substring(1); //Remove the '#'.
                    features[i].properties.googleMaps.zIndex = alertTemplateData.circles[i].get('zIndex');
                }
                //Reset the coordinates array since we'll recalculate them below.
                features[i].geometry.coordinates = [[]];
                for (var j=0; j<N; j++) {
                    //Calculate and save the next coordinate.'
                    var latLng = google.maps.geometry.spherical.computeOffset(
                        new google.maps.LatLng(features[i].properties.googleMaps.center[0],features[i].properties.googleMaps.center[1]),
                        features[i].properties.googleMaps.radius,
                        degreeStep * j);
                    features[i].geometry.coordinates[0].push([latLng.lng(), latLng.lat()]);
                    //Look for the northern most point of the circle.
                    if (latLng.lat() > highestLat) {
                        highestLat = latLng.lat();
                    }
                }
                //In addition to N coordinates we also need to copy the
                //first one to the last one to complete the circle.
                features[i].geometry.coordinates[0].push(features[i].geometry.coordinates[0][0]);
                //Save the highest known latitude.
                alertTemplateData.highestLats.push(highestLat);
            }
        },

        /**
         * Toggles the accordion panels. This is used to toggle the accordion
         * for both accordion pane and proximity zone clicks.
         * @param eOrI
         * @private
         */
        _toggleAccordion: function(eOrI) {
            //This function will either be passed an event (from the ui) or a direct index (from the JS).
            var index = eOrI.model ? eOrI.model.get('index') : eOrI;
            //If they toggle the currently toggled accordion pane then we'll close it.
            if (index !== -1 && this._loadedAlertTemplateData.alertTemplate.zones.features[index].tmpProperties.visible) {
                index = -1;
            }
            //Hide the accordions and remove the selected styling.
            for (var i=0; i<this._loadedAlertTemplateData.alertTemplate.zones.features.length; i++) {
                this.set('_loadedAlertTemplateData.alertTemplate.zones.features.'+i+'.tmpProperties.visible',false);
                this._loadedAlertTemplateData.circles[i].setOptions({"strokeWeight":0});
            }
            //Show the accordion contents for the selected zone and add the selected
            //styling. If the index is -1 then we'll de-toggle all Accordion panes.
            if (index !== -1) {
                this.set('_loadedAlertTemplateData.alertTemplate.zones.features.'+index+'.tmpProperties.visible',true);
                this._loadedAlertTemplateData.circles[index].setOptions({"strokeWeight":3});
            }
        },

        /**
         * Redraws a specific Proximity Zone overlay based on the passed index or redraws them all if no index is available.
         * @param alertTemplateData
         * @param i
         * @private
         */
        _redrawZoneOverlay: function(alertTemplateData,i) {
            if (typeof i !== 'undefined') {
                alertTemplateData.zoneOverlays[i].draw();
            }
            else {
                for (i=0; i<alertTemplateData.zoneOverlays.length; i++) {
                    alertTemplateData.zoneOverlays[i].draw();
                }
            }
        },

        /**
         * Our simple implementation of Google's OverlayView Class. Used to display Proximity Zone labels on the map.
         * @private
         */
        _initializeProximityZoneOverlayView: function() {
            var _outer = this;

            //Constructor
            this._ProximityZoneOverlay = function(zoneIndex,alertIndex) {
                //Set the index of this Proximity Zone which we'll use later.
                this.zoneIndex = zoneIndex;
                //Set the index of the Alerts array (only applicable to alert-editor).
                this.alertIndex = alertIndex;
                //Set the map for this overlay.
                this.setMap(_outer._map);
            };

            //Set the custom overlay object's prototype to a new instance of OverlayView.
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();

            //Called automatically when the map is ready for the overlay to be attached.
            this._ProximityZoneOverlay.prototype.onAdd = function () {
                //Begin to setup the div.
                this.div = document.createElement('div');
                this.div.style.borderStyle = 'none';
                this.div.style.borderWidth = '0px';
                this.div.style.position = 'absolute';
                // Add the element to the "overlayLayer" pane.
                this.getPanes().overlayLayer.appendChild(this.div);
            };

            //Handles visually displaying the overlay on the map. Called when the object is first displayed
            //and again whenever we want to redraw the overlay, like when the positon changes.
            this._ProximityZoneOverlay.prototype.draw = function () {
                var alertTemplateData = typeof this.alertIndex !== 'undefined' && this.alertIndex !== null ?
                    _outer._alerts[this.alertIndex] : _outer._loadedAlertTemplateData;
                var properties = alertTemplateData.alertTemplate.zones.features[this.zoneIndex].properties;

                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(alertTemplateData.highestLats[this.zoneIndex],
                        alertTemplateData.circles[this.zoneIndex].getCenter().lng())
                );
                //Set the div content.
                this.div.innerHTML = properties.zoneId;
                //Center the label above the zone.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-20 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#'+properties.Color;
                this.div.style.color = this.returnColorBasedOnBackground(properties.Color);
                this.div.style.padding = '5px';
                this.div.style.fontSize = '8px';
                this.div.style.zIndex = 10000;
                this.div.style.opacity = 0.8;
                this.div.style.borderRadius = '25px';
            };

            //Cleans up the overlay whenever the overlays map property is set to null.
            this._ProximityZoneOverlay.prototype.onRemove = function () {
                this.div.parentNode.removeChild(this.div);
                this.div = null;
            };

            //Returns #000 or #FFF depending on the passed HEX value.
            this._ProximityZoneOverlay.prototype.returnColorBasedOnBackground = function(hex) {
                //Convert 3 digits to 6.
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                //Just return black if we receive an invalid colour.
                if (hex.length !== 6) {
                    return '#000';
                }
                //Calculate
                var r = parseInt(hex.slice(0, 2), 16),
                    g = parseInt(hex.slice(2, 4), 16),
                    b = parseInt(hex.slice(4, 6), 16);
                return (r * 0.299 + g * 0.587 + b * 0.114) > 186
                    ? '#000'
                    : '#FFF';
            };

            //Set the zone index.
            this._ProximityZoneOverlay.prototype.setZoneIndex = function(zoneIndex) {
                this.zoneIndex = zoneIndex;
            };

            this._ProximityZoneOverlay.prototype.setAlertIndex = function(alertIndex) {
                this.alertIndex = alertIndex;
            }
        },

        /**
         * All components need a reference to the the OverlayView class so once the map is set we'll initialize it.
         */
        _mapChanged: function(map) {
            if (map) {
                //Initialize our custom OverlayView class.
                this._initializeProximityZoneOverlayView();
            }
        },

        /**
         * Returns the default JSON structure of a Proximity Zone.
         * @returns {{type: string, geometry: {type: string, coordinates: [*]}, properties: {googleMaps: {shape: string, radius: number, zIndex: number}, Editable: string, Color: string}}}
         * @private
         */
        _getZoneJSON: function() {
            return {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[]]
                },
                "properties": {
                    "googleMaps": {
                        "shape": "circle",
                        "center": [],
                        "radius": 500,
                        "zIndex": 49 //49 for the first zone and -1 for each following zone
                    },
                    "Editable": true,
                    "Color": "000000",
                    "zoneId": "Zone_1",
                    "Opacity": 0.30
                },
                //These properties are used by the view and will be removed before saving the alertTemplate.
                "tmpProperties": this._getZoneTmpProperties()
            };
        },

        /**
         * Returns temporary Alert Template Zone properties used by the view.
         * @returns {{renaming: boolean, newName: string, visible: boolean}}
         * @private
         */
        _getZoneTmpProperties: function() {
            return {
                "renaming": false,
                "newName":'',
                "visible":false
            }
        },

        /**
         * Returns the default properties for building a google maps circle, the entity that represents a Proximity Zone.
         * @returns {{editable: boolean, draggable: boolean, radius: number, fillColor: string, strokeWeight: number, zIndex: number, map: (*|google.maps.Map|null)}}
         * @private
         */
        _getCircleProperties: function() {
            return {
                editable: true, draggable: false,
                radius: 500, fillColor: '#000000',
                fillOpacity: 0.30,
                strokeWeight:0, zIndex: 49,
                map: this._map
            };
        }
    };
</script>