<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../imports/voyent.html">
<link rel="import" href="./voyent-alert-styles.html">
<link rel="import" href="../imports/turf.html">

<script>
    var Voyent = Voyent || {};
    /**
     * Provides common functionality required by all `voyent-alert-*` components.
     *
     * @polymerBehavior AlertBehaviour
     */
    Voyent.AlertBehaviour = {

        properties: {
            /**
             * The google map object that we'll share between components.
             */
            _map: { type: Object, value: null, notify: true, observer: '_mapChanged'}
        },

        ready: function() {
            this._loadedAlert = null;
            //Define some constants.
            //The number of coordinates circular polygons will have.
            this._NUM_CIRCULAR_POLY_SIDES = 100;
            //The number of degrees in which each coordinate will be spaced apart.
            this._CIRCULAR_POLY_DEGREE_STEP = 360 / this._NUM_CIRCULAR_POLY_SIDES;
            //The id of the fallback zone under the properties section.
            this._FALLBACK_ZONE_ID = 'fallback_zone';
            //My Location icons.
            this._MY_LOCATION_ICON_INACTIVE = this.pathtoimages+'/img/green_marker_circle.png';
            this._MY_LOCATION_ICON_ACTIVE = this.pathtoimages+'/img/green_marker_star.png';
            //Messages.
            this._OVERLAP_MSG = 'The zone cannot overlap other zones in the stack';
        },

        observers: ['_zonesUpdated(_loadedAlert.selectedStack.zones.length)'],

        /**
         * Updates the current alert Location
         * @private
         */
        _updateAlertLocation: function() {
            var _this = this;
            var pos;
            //If we have a template with at least two stacks it means we have a template centroid.
            if (this._loadedAlert.template.zoneStacks.length >= 2) {
                pos = this._loadedAlert.template.marker.getPosition();
            } //One stack means we only have a stack centroid.
            else if (this._loadedAlert.template.zoneStacks.length === 1) {
                pos = this._loadedAlert.template.zoneStacks[0].marker.getPosition()
            }
            else { //No stacks means we have no centroid, fallback zone only.
                pos = new google.maps.LatLng(0,0);
            }
            var location = {
                "location": {
                    "geometry": { "type" : "Point", "coordinates" : [pos.lng(),pos.lat()] },
                    "properties": {
                        "alertId": this._loadedAlert.template.id
                    }
                }
            };
            voyent.locate.updateAlertLocation({realm:this.realm,account:this.account,location: location}).then(function() {
                if (_this._showConfirmingAlertPane) {
                    _this._proceedToPropertiesPane();
                    _this.fire('message-info', 'New alert activated!');
                }
            }).catch(function (e) {
                _this.fire('message-error', 'Issue creating ' + _this._loadedAlert.template.name +
                                            ': ' + (e.responseText || e.message || e))
            });
        },

        /**
         * Toggles the zone properties section. This is used to toggle when clicking the accordion pane or the proximity
         * zone. In addition to toggling the panes this will also trigger styling updates to zones overlays.
         * on the map.
         * @param eOrI - The event from the ui or the index from the JS.
         * @private
         */
        _toggleProperties: function(eOrI) {
            if (!this._loadedAlert || !this._loadedAlert.selectedStack) { return; }
            var index = eOrI.model ? eOrI.model.get('index') : eOrI;
            //If they toggle the currently toggled accordion pane then we'll close it.
            if (index > -1 && this._loadedAlert.selectedStack.getZoneAt(index).active) {
                index = -1;
            }
            if (this._fallbackZone && this._fallbackZone.active) {
                this._toggleFallbackZoneProperties(true);
            }
            else {
                this._loadedAlert.selectedStack.deactivateZoneOverlays();
            }
            if (index > -1) {
                var zone = this._loadedAlert.selectedStack.getZoneAt(index);
                this._initializeColourPicker(zone);
                zone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": zone.id,
                    "zone": zone,
                    "isFallbackZone": false
                });
            }
            else {
                this.fire('voyent-alert-zone-selected',{
                    "id": null,
                    "zone": null
                });
            }
        },

        /**
         * Toggles the fallback zone properties section.
         * @param skipEvent
         * @private
         */
        _toggleFallbackZoneProperties: function(skipEvent) {
            if (this._fallbackZone.active) {
                this._fallbackZone.setActive(false);
                if (!skipEvent) {
                    this.fire('voyent-alert-zone-selected',{
                        "id": null,
                        "zone": null
                    });
                }
            }
            else {
                if (this._loadedAlert && this._loadedAlert.selectedStack) {
                    this._loadedAlert.selectedStack.deactivateZoneOverlays();
                }
                this._initializeColourPicker(this._fallbackZone);
                this._fallbackZone.setActive(true);
                this.fire('voyent-alert-zone-selected',{
                    "id": this._fallbackZone.id,
                    "zone": this._fallbackZone,
                    "isFallbackZone": true
                });
            }
        },

        /**
         * Toggles the movement properties section.
         * @private
         */
        _toggleMovement: function() {
            this._showMovement = !this._showMovement;
        },

        /**
         * Initializes the JSColor colour picker for the passed zone.
         * @param zone
         * @private
         */
        _initializeColourPicker: function(zone) {
            var _this = this;
            var jsColorId = '#jsColor-'+ (this._fallbackZone === zone ? 'fallbackZone' : this._loadedAlert.selectedStack.getZoneIndex(zone));
            var colorPicker = _this.querySelector(jsColorId);
            //Wait till we have a reference to the input.
            if (!colorPicker) {
                setTimeout(function(){_this._initializeColourPicker(zone);},50);
                return;
            }
            //Install the jscolor picker on the input and set the colour.
            if (!colorPicker.jscolor) {
                jscolor.installByClassName("jscolor");
            }
            colorPicker.jscolor.fromString(zone.colour);
        },

        /**
         * Creates and configures the styling for the overlay div, used for zone and location name labels.
         * @private
         */
        _buildOverlayDiv: function(type) {
            var div = document.createElement('div');
            if (type === 'zone') {
                div.style.fontSize = '8px';
            }
            else { //location
                div.style.fontSize = '10px';
            }
            div.style.borderStyle = 'none';
            div.style.borderWidth = '0px';
            div.style.position = 'absolute';
            div.style.padding = '5px';
            div.style.zIndex = 10000;
            div.style.opacity = 1.0;
            div.style.borderRadius = '25px';
            div.style.letterSpacing = '1px';
            return div;
        },

        /**
         * Opens the dialog and sets various properties to be used later.
         * @param message
         * @param input
         * @param confirmFunc
         * @param cancelFunc
         * @private
         */
        _openDialog: function(message,input,confirmFunc,cancelFunc) {
            this._dialogMessage = message;
            this._dialogInput = input;
            this._showDialogInput = (typeof input !== 'undefined' && input !== null);
            this._dialogConfirmFunc = confirmFunc;
            this._dialogCancelFunc = cancelFunc;
            var dialog = this.querySelector('#modalDialog');
            if (dialog) {
                dialog.open();
                //If there's no input rendered in the dialog then focus on the dialog so
                //we can capture the user's key presses. The input will focus automatically.
                if (!this._showDialogInput) {
                    setTimeout(function() {
                        dialog.focus();
                    },200);
                }
            }
        },

        /**
         * Handles dialog input validation and calling the confirmation function if available.
         * @private
         */
        _confirmDialog: function() {
            //Validate the input.
            if (this._showDialogInput && (!this._dialogInput ||
                    !this._dialogInput.trim())) {
                return;
            }
            //We allow for passing the confirm function directly or as a string.
            if (this._dialogConfirmFunc) {
                if (typeof this._dialogConfirmFunc === 'string') { this[this._dialogConfirmFunc](); }
                else { this._dialogConfirmFunc(); }
            }
            //Close the dialog after.
            this._closeDialog(true);
        },

        /**
         * Handles closing the dialog and calling the cancel function if available.
         * @param confirmed
         * @private
         */
        _closeDialog: function(confirmed) {
            confirmed = typeof confirmed === 'boolean' ? confirmed : false;
            //Only call the cancel function if this is triggered by a cancel.
            //We allow passing the confirm function directly or as a string.
            if (!confirmed && this._dialogCancelFunc) {
                if (typeof this._dialogCancelFunc === 'string') { this[this._dialogCancelFunc](); }
                else { this._dialogCancelFunc(); }
            }
            this.querySelector('#modalDialog').close();
        },

        /**
         * Handles enter and escape key presses when the dialog is focused.
         * @param e
         * @private
         */
        _dialogKeyUp: function(e) {
            //Prevent the event from bubbling.
            e.stopPropagation();
            if (e.keyCode === 13) { //Enter
                this._confirmDialog();
            }
            else if (e.keyCode === 27) { //Escape
                this._closeDialog();
            }
        },

        /**
         * Fixes an issue with paper-dialog modal stacking context when the dialog is inside an app-drawer.
         * @param e
         * @private
         */
        _fixModalStacking: function (e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },

        /**
         * Sorts the Proximity Zones based on their radius.
         * @private
         */
        _sortZonesBySize: function() {
            var _this = this;
            //Async so the template updates properly.
            setTimeout(function() {
                _this._loadedAlert.selectedStack.zones.sort(_this._sortZones);
                //Force the template-repeat to re-render.
                var repeat = document.querySelector('#zones-repeat');
                if (repeat) { repeat.render(); }
                //The zoneIndex might have changed for the loaded zone so determine the index and re-fire the event.
                var selectedZoneIndex = -1;
                var zones = _this._loadedAlert.selectedStack.zones;
                for (var i=0;i<zones.length; i++) {
                    if (zones[i].active) {
                        selectedZoneIndex = i;
                        break;
                    }
                }
                //Update the z-indexes so we can always click the zones.
                _this._adjustZIndexesAndColourPicker();
            },0)
        },

        /**
         * Template helper for sorting the Proximity Zones by size and managing the z-index of the zones.
         * @param a
         * @param b
         * @private
         */
        _sortZones: function(a,b) {
            if (a.getShape() === 'circle') {
                if (a.shapeOverlay.radius < b.shapeOverlay.radius) { return -1; }
                else if (a.shapeOverlay.radius > b.shapeOverlay.radius) { return 1; }
                return 0;
            }
            else { //'polygon'
                if (google.maps.geometry.spherical.computeArea(a.shapeOverlay.getPath()) <
                    google.maps.geometry.spherical.computeArea(b.shapeOverlay.getPath())) {
                    return -1;
                }
                else if (google.maps.geometry.spherical.computeArea(a.shapeOverlay.getPath()) >
                         google.maps.geometry.spherical.computeArea(b.shapeOverlay.getPath())) {
                    return 1;
                }
                return 0;
            }
        },

        /**
         * Maintains the correct z-index for each proximity zone and updates the colour picker input to match each zone.
         * @private
         */
        _adjustZIndexesAndColourPicker: function() {
            var zIndex=49, zones = this._loadedAlert.selectedStack.zones;
            for (var i=0; i<zones.length; i++) {
                zones[i].setZIndex(zIndex);
                zIndex--;
                this._initializeColourPicker(zones[i]);
            }
        },

        /**
         * Monitors changes to list of zones from the selected stack for sorting purposes.
         * @param length
         * @private
         */
        _zonesUpdated: function(length) {
            if (length) { this._sortZonesBySize(); }
        },

        /**
         * All components need a reference to the classes so once the map is set we'll initialize them.
         */
        _mapChanged: function(map) {
            if (map) {
                this._initializeClasses();
            }
        },

        /**
         * Generates a uid using the current time in ms and a random number
         * in the trillions (each are 13 characters separated by a dash).
         * @returns {string}
         * @private
         */
        _generateUid: function() {
            return new Date().getTime()+'-'+Math.floor(Math.random()*(9000000000000)+1000000000000);
        },

        /**
         * Initialize all our custom "classes" that are required for the various components.
         * @private
         */
        _initializeClasses: function() {
            var _outer = this;
            /**
             * Common code for inheriting a parent's prototype on the child's.
             * @param child
             * @param parent
             * @private
             */
            this._inheritPrototype = function(child,parent) {
                var parentPrototypeClone = Object.create(parent.prototype);
                parentPrototypeClone.constructor = child;
                child.prototype = parentPrototypeClone;
            };
            /**
             * A class that represents an alert template, both the drawn map entity and the json.
             * @param id - The unique identifier.
             * @param parentId - The parent template id, only relevant for child templates.
             * @param name - The user-defined name.
             * @param marker - The associated map marker for the entire template, centered between the various stacks.
             * @param zoneStacks - A list of _AlertZoneStack objects, the list of zone stacks belonging with the template.
             * @param state - The current state of the alert, only relevant for child templates.
             * @param savePosition - Whether the position of the template should be stored in the json.
             * @private
             */
            this._AlertTemplate = function(id,parentId,name,marker,zoneStacks,state,savePosition) {
                this._jsonProperties = {};
                this.setId(id || null);
                this.setParentId(parentId || null);
                this.setName(name || 'Unnamed');
                this.setMarker(marker || null);
                this.setZoneStacks(zoneStacks && zoneStacks.length ? zoneStacks : []);
                this.setState(state || null);
                this.savePosition = !!savePosition;
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed json.
             * @param json - The full template json.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromJSON = function(json) {
                var geometries = json.geo.geometries;
                var coordinates, bounds = new google.maps.LatLngBounds();
                for (var i=0; i<geometries.length; i++) {
                    coordinates = geometries[i].coordinates[0];
                    for (var j=0; j<coordinates.length; j++) {
                        bounds.extend(new google.maps.LatLng(coordinates[j][1],coordinates[j][0]));
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Used to calculate the centroid of the template's zones using the passed paths array.
             * @param paths - An array of arrays of LatLng objects that define the zone.
             * @static
             */
            this._AlertTemplate.calculateCentroidFromPaths = function(paths) {
                var bounds = new google.maps.LatLngBounds();
                for (var i=0; i<paths.length; i++) {
                    for (var j=0; j<paths.getAt(i).length; j++) {
                        bounds.extend(paths.getAt(i).getAt(j));
                    }
                }
                return bounds.getCenter();
            };
            /**
             * Calculate the shape overlay paths using the passed coordinates arrays.
             * @param coordinates
             * @static
             */
            this._AlertTemplate.calculatePathsFromCoordinates = function(coordinates) {
                var latLng, paths = [], path;
                for (var i=0; i<coordinates.length; i++) {
                    path = [];
                    //In GeoJSON we must complete the shape by duplicating the coordinate at index 0 at the last index
                    //but Google Maps API states: "Paths are closed automatically; do not repeat the first vertex of
                    //the path as the last vertex.". So we'll exclude the last coordinate when converting to paths.
                    for (var j=0; j<coordinates[i].length-1; j++) {
                        latLng = new google.maps.LatLng(coordinates[i][j][1],coordinates[i][j][0]);
                        path.push(latLng);
                    }
                    paths.push(path);
                }
                return paths;
            };
            /**
             * Calculate the GeoJSON coordinates using the passed shape overlay paths.
             * @param paths
             * @param func - The function to be executed after the inner path has being modified.
             * @static
             */
            this._AlertTemplate.calculateCoordinatesFromPaths = function(paths,func) {
                var latLng, outer = [], inner;
                for (var i=0; i<paths.length; i++) {
                    inner = [];
                    for (var j=0; j<paths.getAt(i).length; j++) {
                        //Retrieve each coordinate from the shape and save it.
                        latLng = paths.getAt(i).getAt(j);
                        inner.push([latLng.lng(), latLng.lat()]);
                        if (func) {
                            func(latLng)
                        }
                    }
                    //In GeoJSON we must copy the first coordinate to the last one
                    //to complete the shape. Do this for each coordinate array.
                    inner.push(inner[0]);
                    outer.push(inner);
                }
                return outer;
            };
            /**
             * A static function that returns the default JSON structure.
             * @static
             */
            this._AlertTemplate.getJSONStructure = function () {
                return {
                    "name": "Unnamed",
                    "geo": {
                        "type": "GeometryCollection",
                        "geometries": []
                    },
                    "properties": {}
                };
            };
            /**
             * _AlertTemplate prototype (instance) functions.
             */
            this._AlertTemplate.prototype = {
                constructor: _outer._AlertTemplate,
                /**
                 * Sets the id, updates the json and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param id
                 */
                setId: function (id) {
                    this.id = id;
                    if (this.json) {
                        this.json._id = id;
                    }
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.set('_loadedAlert.template.id', id);
                    }
                },
                /**
                 * Sets the parentId, updates the json and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param parentId
                 */
                setParentId: function(parentId) {
                    this.parentId = parentId;
                    if (this.json && this.json.properties) {
                        this.json.properties.parentAlertId = parentId;
                    }
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.set('_loadedAlert.template.parentId', parentId);
                    }
                },
                /**
                 * Sets the name, updates the json and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function (name) {
                    this.name = name;
                    if (this.json) {
                        this.json.name = name;
                    }
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.set('_loadedAlert.template.name', name);
                    }
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    //When we create a new AlertTemplate with only one stack we don't need a marker for
                    //the template since the stack has it's own so always check if we were passed one.
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Sets the zone stacks and triggers required processing.
                 * @param zoneStacks
                 */
                setZoneStacks: function (zoneStacks) {
                    this.zoneStacks = [];
                    for (var i=0; i<zoneStacks.length; i++) {
                        this.addZoneStack(zoneStacks[i]);
                    }
                },
                /**
                 * Sets the alert state.
                 * @param state
                 */
                setState: function(state) {
                    this.state = state;
                },
                /**
                 * Add the passed zone stack.
                 * @param zoneStack
                 */
                addZoneStack: function (zoneStack) {
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.push('_loadedAlert.template.zoneStacks',zoneStack);
                    }
                    else {
                        this.zoneStacks.push(zoneStack);
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Remove the passed zone stack.
                 * @param zoneStack
                 */
                removeZoneStack: function (zoneStack) {
                    zoneStack.removeFromMap();
                    var zoneStackIndex = this.getZoneStackIndex(zoneStack);
                    if (_outer._loadedAlert && _outer._loadedAlert.template === this) {
                        _outer.splice('_loadedAlert.template.zoneStacks',zoneStackIndex,1);
                        if (_outer._loadedAlert.selectedStack === zoneStack) {
                            _outer.set('_loadedAlert.selectedStack',null);
                        }
                    }
                    else {
                        this.zoneStacks.splice(zoneStackIndex,1);
                    }
                    this.updateJSONAndCentroid();
                    if (this.zoneStacks.length === 1) {
                        this.marker.setMap(null);
                        this.setMarker(null);
                    }
                },
                /**
                 * Returns the zone stack at the specified index.
                 * @param index
                 */
                getZoneStackAt: function (index) {
                    return this.zoneStacks[index];
                },
                /**
                 * Returns the index of the passed zone stack.
                 * @param zoneStack
                 */
                getZoneStackIndex: function (zoneStack) {
                    return this.zoneStacks.indexOf(zoneStack);
                },
                /**
                 * Triggers reinitialization of edit listeners for each polygonal zone stack.
                 */
                initializePolygonStackPathListeners: function() {
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        if (this.zoneStacks[i].zones[0].getShape() === 'polygon') {
                            this.zoneStacks[i].initializePolygonPathListeners();
                        }
                    }
                },
                /**
                 * Adds the passed key/value pair to the properties section of the template JSON.
                 * If the key already exists then the property will be updated.
                 * @param key
                 * @param value
                 */
                addJSONProperty: function(key,value) {
                    this._jsonProperties[key] = value;
                },
                /**
                 * Removes the passed key from the properties section of the template JSON.
                 * @param key
                 */
                removeJSONProperty: function(key) {
                    delete this._jsonProperties[key]
                },
                /**
                 * Updates the json to reflect the current state of the template. Since each stack of zones maintains
                 * their own json we update their json and then simply merge the geometries and properties section from
                 * each stack into one.
                 * @param punchOutCircularStacks
                 */
                updateJSON: function (punchOutCircularStacks) {
                    var json = this.constructor.getJSONStructure();
                    //Add template-level properties.
                    json.name = this.name;
                    if (this.parentId) {
                        json.properties.parentAlertId = this.parentId;
                        if (this.state) {
                            json.state = this.state;
                        }
                    }
                    if (Object.keys(this._jsonProperties).length) {
                        for (var key in this._jsonProperties) {
                            if (!this._jsonProperties.hasOwnProperty(key)) { continue; }
                            json.properties[key] = this._jsonProperties[key];
                        }
                    }
                    //Add fallback zone, we'll always add it the properties.
                    json.properties[_outer._FALLBACK_ZONE_ID] = {
                        "enabled": false
                    };
                    if (_outer._fallbackZone) {
                        json.properties[_outer._FALLBACK_ZONE_ID] = {
                            "enabled":_outer._fallbackZone.enabled,
                            "name": _outer._fallbackZone.name,
                            "opacity": _outer._fallbackZone.opacity,
                            "colour": _outer._fallbackZone.colour
                        };
                        if (_outer._fallbackZone.messageTemplate) {
                            json.properties[_outer._FALLBACK_ZONE_ID].messageTemplate = _outer._fallbackZone.messageTemplate;
                        }
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        //First update the json for the stack.
                        this.zoneStacks[i].updateJSON();
                        //Merge the geometries arrays.
                        json.geo.geometries = json.geo.geometries.concat(this.zoneStacks[i].json.geo.geometries);
                        //Merge the properties objects.
                        for (var zoneId in this.zoneStacks[i].json.properties) {
                            if (this.zoneStacks[i].json.properties.hasOwnProperty(zoneId)) {
                                json.properties[zoneId] = this.zoneStacks[i].json.properties[zoneId];
                            }
                        }
                        //If it's a circular template then punch it out.
                        if (punchOutCircularStacks &&
                            this.zoneStacks[i].getZoneAt(0).getShape() === 'circle') {
                            this.zoneStacks[i].punchOutShapes();
                        }
                    }
                    //Check if this is a "fixed location" template and store it.
                    delete json.properties.center;
                    if (!this.parentId && this.savePosition) {
                        if (this.marker) {
                            json.properties.center = this.marker.getPosition();
                        }
                        else if (this.zoneStacks.length && this.zoneStacks[0].marker) {
                            json.properties.center = this.zoneStacks[0].marker.getPosition();
                        }
                    }
                    this.json = json;
                },
                /**
                 * Updates the position of the template marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    if (this.marker) {
                        this.marker.setPosition(
                            this.constructor.calculateCentroidFromJSON(this.json)
                        );
                    }
                },
                /**
                 * Removes the template from the map.
                 */
                removeFromMap: function() {
                    if (this.marker) {
                        this.marker.setMap(null);
                    }
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].removeFromMap();
                    }
                },
                /**
                 * Initializes marker listeners.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the template marker so we'll add a flag to ignore those events.
                    google.maps.event.addListener(this.marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeStackPositions();
                    });
                    google.maps.event.addListener(this.marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        //Re-initialize the polygon path listeners for all stacks of polygonal zones.
                        _this.initializePolygonStackPathListeners();
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(this.marker, 'drag', function () {
                        _this.moveStacksRelativeToPosition();
                        _this.updateJSON();
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(this.marker, 'click', function () {
                        //Toggle all the accordion panes closed and de-select all stacks.
                        _outer._toggleProperties(-1);
                        _outer.set('_loadedAlert.selectedStack',null);
                    });
                },
                /**
                 * Calculates the current zone positions (distance and bearing)
                 * in each stack relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeStackPositions: function(latLng) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].calculateRelativeZonePositions(position);
                    }
                },
                /**
                 * Moves zone stacks from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 */
                moveStacksRelativeToPosition: function (latLng) {
                    var position = latLng || this.marker.getPosition();
                    for (var i=0; i<this.zoneStacks.length; i++) {
                        this.zoneStacks[i].moveZonesRelativeToPosition(position);
                    }
                }
            };
            Object.seal(this._AlertTemplate);

            /**
             * A class that represents an alert template proximity zone stack.
             * @param marker - The associated map marker for the stack.
             * @param zones - A list of _AlertZone objects, the list of zones belonging with the stack.
             * @private
             */
            this._AlertZoneStack = function (marker,zones) {
                this.stackId = _outer._generateUid();
                this.setMarker(marker || null);
                this.setZones(zones && zones.length ? zones : []);
                this.updateJSON();
            };
            /**
             * Returns the colour of the zone at the passed index, assuming
             * a default order of `red`, `yellow`, `blue`, `green`.
             * @param index
             * @static
             */
            this._AlertZoneStack.getZoneColourAtIndex = function(index) {
                if (this._isZoneAtIndexColour(index,'red')) {
                    return 'FF0000'
                }
                else if (this._isZoneAtIndexColour(index,'yellow')) {
                    return 'FFFF00';
                }
                else if (this._isZoneAtIndexColour(index,'blue')) {
                    return '0000FF';
                }
                else if (this._isZoneAtIndexColour(index,'green')) {
                    return '00FF00';
                }
            };
            /**
             * Determines if the zone at the index is the colour.
             * @param index - The index of the zone.
             * @param colour - The colour to check. Valid options are `red`, `yellow`, `blue` and `green`.
             * @static
             * @private
             */
            this._AlertZoneStack._isZoneAtIndexColour = function(index,colour) {
                var zoneNumber = index+1;
                //Only generate the minimum amount of numbers in the sequence that we need to determine a match.
                var count = Math.ceil((zoneNumber)/4);
                //Determine the starting point for our sequence.
                var sequence = [];
                if (colour === 'red') { sequence.push(1); }
                else if (colour === 'yellow') { sequence.push(2); }
                else if (colour === 'blue') { sequence.push(3); }
                else { sequence.push(4); }
                //Generate the sequence and return whether we have a match.
                for (var i=1; i<=count; i++) {
                    sequence.push(sequence[sequence.length-1]+4);
                }
                return sequence.indexOf(zoneNumber) > -1;
            };
            /**
             * _AlertZoneStack prototype (instance) functions.
             */
            this._AlertZoneStack.prototype = {
                constructor: _outer._AlertZoneStack,
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function (marker) {
                    this.marker = marker;
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Adds the passed zones to the stack.
                 * @param zones
                 */
                setZones: function (zones) {
                    this.zones = [];
                    for (var i=0; i<zones.length; i++) {
                        this.addZone(zones[i]);
                    }
                },
                /**
                 * Returns the zone at the specified index.
                 * @param index
                 */
                getZoneAt: function (index) {
                    return this.zones[index];
                },
                /**
                 * Returns the index of the passed zone.
                 * @param zone
                 */
                getZoneIndex: function (zone) {
                    return this.zones.indexOf(zone);
                },
                /**
                 * Returns the largest zone.
                 */
                getLargestZone: function() {
                    return this.getZoneAt(this.zones.length-1);
                },
                /**
                 * Deactivates all zones.
                 */
                deactivateZoneOverlays: function () {
                    for (var i = 0; i < this.zones.length; i++) {
                        this.zones[i].setActive(false);
                    }
                },
                /**
                 * Add the passed zone.
                 * @param zone
                 */
                addZone: function (zone) {
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack === this) {
                        _outer.push('_loadedAlert.selectedStack.zones',zone);
                    }
                    else {
                        this.zones.push(zone);
                    }
                    if (!zone.colour) {
                        zone.setColour(this.constructor.getZoneColourAtIndex(this.zones.length-1));
                    }
                    if (zone.getShape() === 'polygon') {
                        this.updateJSONAndCentroid();
                        this._punchOutShape(this.zones.length-1);
                    }
                    else {
                        this.updateJSON();
                        zone.shapeOverlay.setCenter(this.marker.getPosition());
                    }
                    this._setupZoneListeners(zone);
                },
                /**
                 * Remove the passed zone.
                 * @param zone
                 */
                removeZone: function (zone) {
                    zone.removeFromMap();
                    var zoneIndex = this.getZoneIndex(zone);
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack === this) {
                        _outer.splice('_loadedAlert.selectedStack.zones',zoneIndex,1);
                    }
                    else {
                        this.zones.splice(zoneIndex,1);
                    }
                    this.updateJSON();
                },
                /**
                 * Updates the json to reflect the current state of the stack. Also updates
                 * the northernCoordinate which adjusts the position of the zone name overlays.
                 */
                updateJSON: function () {
                    var zone, northernCoordinate, latLng, overlay,
                        json = _outer._AlertTemplate.getJSONStructure();

                    for (var i=0; i<this.zones.length; i++) {
                        zone = this.zones[i];
                        northernCoordinate = [null, -100];
                        overlay = zone.shapeOverlay;
                        json.properties[zone.id] = {
                            "name": zone.name,
                            "stackId": this.stackId,
                            "shape": zone.getShape(),
                            "opacity": zone.opacity,
                            "colour": zone.colour,
                            "innermost": i===0
                        };
                        if (zone.messageTemplate) {
                            json.properties[zone.id].messageTemplate = zone.messageTemplate;
                        }
                        json.geo.geometries.push({
                            "id": zone.id,
                            "stackId": this.stackId,
                            "type": "Polygon",
                            "coordinates": [[]]
                        });
                        if (zone.getShape() === 'circle') {
                            json.properties[zone.id].radius = overlay.getRadius();
                            var center =  this.marker.getPosition();
                            for (var k=0; k<_outer._NUM_CIRCULAR_POLY_SIDES; k++) {
                                //Calculate and save the next coordinate.
                                latLng = google.maps.geometry.spherical.computeOffset(
                                    center, json.properties[zone.id].radius, _outer._CIRCULAR_POLY_DEGREE_STEP * k
                                );
                                json.geo.geometries[i].coordinates[0].push([latLng.lng(), latLng.lat()]);
                                //Look for the northern most point of the circle so we know
                                //where to render the Proximity Zone overlay label.
                                if (latLng.lat() > northernCoordinate[1]) {
                                    northernCoordinate = [latLng.lng(), latLng.lat()];
                                }
                            }
                            //In GeoJSON we must copy the first coordinate to the last one to complete the shape.
                            json.geo.geometries[i].coordinates[0].push(json.geo.geometries[i].coordinates[0][0]);
                        }
                        else {
                            json.geo.geometries[i].coordinates =
                                _outer._AlertTemplate.calculateCoordinatesFromPaths(overlay.getPaths(),function(latLng) {
                                    //Look for the northern most point of the polygon so we know
                                    //where to render the Proximity Zone overlay label.
                                    if (latLng.lat() > northernCoordinate[1]) {
                                        northernCoordinate = [latLng.lng(), latLng.lat()];
                                    }
                                });
                        }
                        zone.setNorthernCoordinate(northernCoordinate);
                    }
                    this.json = json;
                },
                /**
                 * Updates the position of the stack marker by updating the json and calculating the centroid from that.
                 */
                updateJSONAndCentroid: function() {
                    this.updateJSON();
                    this.marker.setPosition(
                        _outer._AlertTemplate.calculateCentroidFromJSON(this.json)
                    );
                },
                /**
                 * Loops the zone coordinates in the JSON and triggers punching out the smaller
                 * from the larger, starting from the largest and excluding the smallest.
                 */
                punchOutShapes: function() {
                    for (var i=this.json.geo.geometries.length-1; i>0; i--) {
                        this._punchOutShape(i);
                    }
                },
                /**
                 * Punches out the zone at the passed index with it's closest smallest zone.
                 * @param index - The index of the zone to be punched out.
                 * @private
                 */
                _punchOutShape: function(index) {
                    //Don't proceed if the index of the smallest zone (0) is passed.
                    if (!index) { return; }
                    var doughnut = turf.difference({
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index].coordinates[0]]
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [this.json.geo.geometries[index-1].coordinates[0]]
                            }
                        }
                    );
                    var coordinates = doughnut.geometry.coordinates;
                    if (this.zones[index].getShape() === 'polygon') {
                        //Calculate and set the new punched out paths so the changes get reflected on the map immediately.
                        var punchedOutPaths = _outer._AlertTemplate.calculatePathsFromCoordinates(coordinates);
                        this.zones[index].setPaths(punchedOutPaths);
                        //Re-initialize the polygon path listeners for the edited zone.
                        this.initializePolygonPathListeners(this.zones[index]);
                    }
                    //Replace the old json coordinates with our new punched out zone.
                    this.json.geo.geometries[index].coordinates = coordinates;
                },
                /**
                 * Calculates the current zone positions (distance and bearing) relative to the passed location.
                 * @param latLng - A LatLng object representing the position in
                 *                 which the distance and bearing will be calculated.
                 */
                calculateRelativeZonePositions: function(latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions=[];
                        if (this.zones[i].getShape() === 'circle') {
                            //Calculate the distance and bearing from the position to the center of the zone.
                            var zoneCenter = this.zones[i].shapeOverlay.getCenter();
                            positions.push({
                                "distance":google.maps.geometry.spherical.computeDistanceBetween(latLng,zoneCenter),
                                "bearing":google.maps.geometry.spherical.computeHeading(latLng,zoneCenter)
                            });
                        }
                        else { //polygon
                            var paths = this.zones[i].shapeOverlay.getPaths(), innerPositions;
                            for (var j=0; j<paths.length; j++) {
                                innerPositions = [];
                                for (var k=0; k<paths.getAt(j).length; k++) {
                                    //Calculate the distance and bearing from the position to the each vertex.
                                    innerPositions.push({
                                        "distance":google.maps.geometry.spherical.computeDistanceBetween(latLng,paths.getAt(j).getAt(k)),
                                        "bearing":google.maps.geometry.spherical.computeHeading(latLng,paths.getAt(j).getAt(k))
                                    });
                                }
                                positions.push(innerPositions);
                            }
                        }
                        this.zones[i]._relativePositions = positions;
                    }
                },
                /**
                 * Moves zones from their current location to the passed location, maintaining
                 * the distance and bearing calculated by `calculateRelativeZonePositions`.
                 * @param latLng - The LatLng object representing the position
                 *                 in which the zones will be to.
                 */
                moveZonesRelativeToPosition: function (latLng) {
                    for (var i=0; i<this.zones.length; i++) {
                        var positions = this.zones[i]._relativePositions, paths = [], path, newCenter;
                        if (this.zones[i].getShape() === 'circle') {
                            newCenter = google.maps.geometry.spherical.computeOffset(
                                latLng,
                                positions[0].distance,
                                positions[0].bearing
                            );
                            this.zones[i].shapeOverlay.setCenter(newCenter);
                        }
                        else { //polygon
                            for (var j=0; j<positions.length; j++) {
                                path = [];
                                for (var k=0; k<positions[j].length; k++) {
                                    path.push(google.maps.geometry.spherical.computeOffset(
                                        latLng,
                                        positions[j][k].distance,
                                        positions[j][k].bearing)
                                    );
                                }
                                paths.push(path);
                            }
                            this.zones[i].setPaths(paths);
                        }
                        //Update the centroid.
                        this.marker.setPosition((
                            newCenter || _outer._AlertTemplate.calculateCentroidFromPaths(this.zones[i].shapeOverlay.getPaths())
                        ));
                    }
                    //Update the JSON.
                    this.updateJSON();
                },
                /**
                 * Removes the stack of zones from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    for (var i=0; i<this.zones.length; i++) {
                        this.zones[i].removeFromMap();
                    }
                },
                /**
                 * Initializes marker listeners.
                 * @private
                 */
                _setupMarkerListeners: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //The proximity zone center_changed listener will fire continuously when
                    //dragging the stack marker so we'll add a flag to ignore those events.
                    var marker = this.marker;
                    google.maps.event.addListener(marker, 'dragstart', function () {
                        _outer._ignoreZoneCenterChangedEvent = true;
                        _this.calculateRelativeZonePositions(_this.marker.getPosition());
                    });
                    google.maps.event.addListener(marker, 'dragend', function () {
                        _outer._ignoreZoneCenterChangedEvent = false;
                        //Re-initialize the polygon path listeners for all zones.
                        _this.initializePolygonPathListeners();
                    });
                    //Continuously re-draw the overlay as the template is dragged.
                    google.maps.event.addListener(marker, 'drag', function () {
                        _this.moveZonesRelativeToPosition(_this.marker.getPosition());
                        _outer._loadedAlert.template.updateJSONAndCentroid();
                        if (_outer._fallbackZone) {
                            _outer._fallbackZone.punchOutOverlay();
                        }
                    });
                    //Add click listener to marker.
                    google.maps.event.addListener(marker, 'click', function () {
                        //Toggle all the accordion panes closed.
                        _outer._toggleProperties(-1);
                        _outer.set('_loadedAlert.selectedStack',_this);
                    });
                },
                /**
                 * Initializes zone listeners.
                 * @param zone
                 * @private
                 */
                _setupZoneListeners: function (zone) {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    var overlay = zone.shapeOverlay;
                    //Add click listener to shapes.
                    google.maps.event.addListener(overlay, 'click', function () {
                        var zoneIndex = _this.getZoneIndex(zone);
                        //If they click a zone for the currently active stack then toggle the accordion.
                        if (_outer._loadedAlert.selectedStack &&
                            _outer._loadedAlert.selectedStack === _this) {
                            _outer._toggleProperties(zoneIndex);
                        }
                        else {
                            //Toggle the accordion for the previously selected alert template.
                            _outer._toggleProperties(-1);
                            //Load the selected stack and toggle the selected zone.
                            _outer.set('_loadedAlert.selectedStack',_this);
                            _outer._toggleProperties(zoneIndex);
                        }
                    });
                    if (zone.getShape() === 'circle') {
                        /*This listener is used for the special case of dragging by the center editable point of circular
                        zones. When the user drags by this center point we need to be sure to move all the zones and marker
                        to their new position after dragging. However, this listener will fire after modifying the positions
                        of other zones so we will use a flag to ignore these events. Additionally, we use a flag to ignore
                        when dragging by the marker because the event fires continuously then as well.*/
                        google.maps.event.addListener(overlay, 'center_changed', function () {
                            if (_outer._ignoreZoneCenterChangedEvent) {
                                return;
                            }
                            _outer._ignoreZoneCenterChangedEvent = true;
                            _this.marker.setPosition(this.getCenter());
                            for (var i=0; i<_this.zones.length; i++) {
                                //This step will fire this listener again which is why we set the flag previously.
                                _this.zones[i].shapeOverlay.setCenter(this.getCenter());
                            }
                            _this.updateJSON();
                            _outer._ignoreZoneCenterChangedEvent = false;
                            _outer._loadedAlert.template.updateJSONAndCentroid();
                        });
                        //Add resize listener to circle.
                        google.maps.event.addListener(overlay, 'radius_changed', function () {
                            if (_outer._ignoreRadiusChangedEvent) {
                                _outer._ignoreRadiusChangedEvent = false;
                                return;
                            }
                            //Prevent the circle form overlapping the other zones.
                            var thisZoneIndex = _outer._loadedAlert.selectedStack.getZoneIndex(zone);
                            //Check if it overlapped the adjacent outer zone.
                            var outerZone = _outer._loadedAlert.selectedStack.getZoneAt(thisZoneIndex+1);
                            if (outerZone && this.getRadius() >= outerZone.shapeOverlay.getRadius()) {
                                _outer._ignoreRadiusChangedEvent = true;
                                zone.setRadius(zone.radius);
                                _outer.fire('message-error',_outer._OVERLAP_MSG);
                                return;
                            }
                            //Check if it overlapped the adjacent inner zone.
                            var innerZone = _outer._loadedAlert.selectedStack.getZoneAt(thisZoneIndex-1);
                            if (innerZone && this.getRadius() <= innerZone.shapeOverlay.getRadius()) {
                                _outer._ignoreRadiusChangedEvent = true;
                                zone.setRadius(zone.shape);
                                _outer.fire('message-error',_outer._OVERLAP_MSG);
                                return;
                            }
                            _this.updateJSON();
                            _outer._loadedAlert.template.updateJSONAndCentroid();
                            if (_outer._fallbackZone) {
                                //Async so the list sorts first.
                                setTimeout(function() {
                                    _outer._fallbackZone.punchOutOverlay();
                                },0);
                            }
                            //Update the radius stored in the zone.
                            zone.setRadius(this.getRadius(),true);
                        });
                    }
                    else {
                        //Store the previous vertex position when clicking
                        //on an existing vertex in case we need to revert.
                        google.maps.event.addListener(overlay, 'mousedown', function(e) {
                            if (typeof e.vertex !== 'undefined') {
                                _outer._previousVertexPosition = e.latLng;
                            }
                        });
                        //Handle polygon edits.
                        _this.initializePolygonPathListeners(zone);
                    }
                },
                /**
                 * Initializes polygon edit listeners. When that paths of the overlay change significantly, such as when
                 * punching the shapes out, we need to call this function again to re-initialize the listeners.
                 * @param zone - The optional zone for which listeners will be initialized. If this is not provided then
                 *               all zones for the stack will be processed.
                 */
                initializePolygonPathListeners: function(zone) {
                    if (zone) {
                        if (zone.getShape() === 'circle') { return; }
                        this._setupPolygonPathListeners(zone);
                    }
                    else {
                        for (var i=0; i<this.zones.length; i++) {
                            if (this.zones[i].getShape() === 'polygon') {
                                this._setupPolygonPathListeners(this.zones[i]);
                            }
                        }
                    }
                },
                /**
                 * Processes individual zones sent from `initializePolygonPathListeners`.
                 * @param zone
                 * @private
                 */
                _setupPolygonPathListeners: function(zone) {
                    var _this = this;
                    //Just to be sure we don't duplicate listeners we will always clear existing ones first.
                    for (var i=0; i<zone.shapeOverlay.getPaths().length; i++) {
                        (function(pathIndex) {
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'insert_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'insert_at', function (vertexIndex) {
                                //Async so the vertex gets inserted before we operate on it.
                                setTimeout(function() {
                                    _this._polyAtListener('insert_at',zone,pathIndex,vertexIndex);
                                },0);
                            });
                            google.maps.event.clearListeners(zone.shapeOverlay.getPaths().getAt(pathIndex),'set_at');
                            google.maps.event.addListener(zone.shapeOverlay.getPaths().getAt(pathIndex), 'set_at', function (vertexIndex) {
                                if (_outer._revertedVertex) {
                                    _outer._revertedVertex = false;
                                    return;
                                }
                                _this._polyAtListener('set_at',zone,pathIndex,vertexIndex);
                            });
                        })(i);
                    }
                },
                /**
                 * Checks if the vertex change is valid when a polygonal zone is edited.
                 * @param eventName - The name of the event that is calling this function. One of `insert_at` or `set_at`.
                 * @param zone - The zone that the event fired on.
                 * @param pathIndex - The path that the event fired on.
                 * @param vertexIndex - The vertex that the event fired on.
                 * @private
                 */
                _polyAtListener: function (eventName,zone,pathIndex,vertexIndex) {
                    var errorMsg = null;
                    var zoneIndex = _outer._loadedAlert.selectedStack.getZoneIndex(zone);
                    var largestZone = _outer._loadedAlert.selectedStack.getLargestZone();
                    //Check if the polygon intersects itself. To do this we will use the turf library but we
                    //must first extract the new zone coordinates so they can be interpreted by turf as GeoJSON.
                    var newZoneCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(zone.shapeOverlay.getPaths());
                    var kinks = turf.kinks({
                        "type": "Feature",
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": newZoneCoordinates
                        }
                    });
                    if (kinks.features.length) {
                        errorMsg = 'The zone cannot self-intersect';
                    }
                    if (!errorMsg && _outer._loadedAlert.selectedStack.zones.length > 1) {
                        var vertex = zone.shapeOverlay.getPaths().getAt(pathIndex).getAt(vertexIndex);
                        //Check that the vertex is within our zone boundary. This handles the case
                        //where they drag an inner zone vertex past the boundaries of the stack.
                        if (zoneIndex !== _outer._loadedAlert.selectedStack.getZoneIndex(largestZone)) {
                            if (!google.maps.geometry.poly.containsLocation(vertex,new google.maps.Polygon({
                                    paths: [largestZone.shapeOverlay.getPaths().getAt(pathIndex)]}))) {
                                errorMsg = _outer._OVERLAP_MSG;
                            }
                        }
                        else {
                            //Check that the outer-most zone is touching it's closest inner zone. This
                            //handles the case where they drag a vertex on the outer-most zone to the
                            //opposite side of the shape, detaching it from the stack.
                            var outerBoundaryPolygonCoordinates = _outer._AlertTemplate.calculateCoordinatesFromPaths(
                                zone.shapeOverlay.getPaths()
                            );
                            var intersects = turf.intersect({
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    //The zone isn't punched out yet which means the previous inner zone boundary
                                    //will exist as a filled polygon so make sure we only select the edited zone.
                                    "coordinates": [outerBoundaryPolygonCoordinates[0]]
                                }
                            },
                            {
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    "coordinates": _outer._AlertTemplate.calculateCoordinatesFromPaths(
                                        _outer._loadedAlert.selectedStack.getZoneAt(zoneIndex-1).shapeOverlay.getPaths()
                                    )
                                }
                            });
                            if (!intersects.geometry) {
                                errorMsg = 'The zone cannot be detached from the stack';
                            }
                        }
                        //Check if the vertex overlaps zones beyond the adjacent zone on either side. Overlapping the
                        //adjacent zone is OK because we will just adjust the shape of that zone to accommodate.
                        if (!errorMsg && _outer._loadedAlert.selectedStack.zones.length > 2) {
                            var i;
                            //Test zones on the outer side of the edited zone, starting with two zones away.
                            for (i=zoneIndex+2; i<_outer._loadedAlert.selectedStack.zones.length; i++) {
                                if (google.maps.geometry.poly.containsLocation(
                                        vertex, _outer._loadedAlert.selectedStack.getZoneAt(i).shapeOverlay)) {
                                    errorMsg = _outer._OVERLAP_MSG;
                                    break;
                                }
                            }
                            if (!errorMsg) {
                                //Test zones on the inner side of the edited zone, starting with two zones away.
                                for (i=zoneIndex-2; i>=0; i--) {
                                    if (google.maps.geometry.poly.containsLocation(
                                        vertex, _outer._loadedAlert.selectedStack.getZoneAt(i).shapeOverlay)) {
                                        errorMsg = _outer._OVERLAP_MSG;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //Revert the position if there was a problem and display a message to the user.
                    if (errorMsg) {
                        if (eventName === 'set_at') {
                            _outer._revertedVertex = true;
                            zone.shapeOverlay.getPaths().getAt(pathIndex).setAt(vertexIndex, _outer._previousVertexPosition);
                        }
                        else { //insert_at
                            zone.shapeOverlay.getPaths().getAt(pathIndex).removeAt(vertexIndex);
                        }
                        _outer.fire('message-error',errorMsg);
                        return;
                    }
                    if (pathIndex > 0) {
                        //The inner boundary of a zone was pulled inwards or outwards so we must adjust the shape inside
                        //of it to fill the gap. To do this we will take the inner boundary of the adjusted shape and set
                        //it as the outer boundary of the inner shape. We must clone the boundary array so the two overlays
                        //will not be linked by reference.
                        var pathClone = [];
                        for (var j=0; j<zone.shapeOverlay.getPaths().getAt(pathIndex).length; j++) {
                            pathClone.push(zone.shapeOverlay.getPaths().getAt(pathIndex).getAt(j));
                        }
                        var editedZone = _outer._loadedAlert.selectedStack.getZoneAt(zoneIndex-1);
                        editedZone.setPaths(new google.maps.MVCArray(pathClone));
                        //Re-initialize the polygon path listeners for the edited zone.
                        _outer._loadedAlert.selectedStack.initializePolygonPathListeners(editedZone);
                    }
                    //Update the stack JSON and adjust the centroid position.
                    this.updateJSONAndCentroid();
                    //Always re-punch out the shapes. This will handle cases like filling
                    //in gaps when the outer boundary of an inner zone is pulled inwards.
                    this.punchOutShapes();
                    //Update the centroid for the template.
                    _outer._loadedAlert.template.updateJSONAndCentroid();
                    if (_outer._fallbackZone) {
                        _outer._fallbackZone.punchOutOverlay();
                    }
                }
            };
            Object.seal(this._AlertZoneStack);

            /**
             * A class that represents an alert zone, both the drawn map entity and the json.
             * @param name - The user-defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @param messageTemplate - The message template associated with this zone.
             * @private
             */
            this._AlertZone = function (name,opacity,colour,messageTemplate,zIndex) {
                this.id = _outer._generateUid();
                this.setName(name || 'Zone 1');
                this.setOpacity(opacity || 0.30);
                this.setColour(colour || null); //Default to null so the stack can manage the colours based on the number of zones.
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.setRenaming(false);
                this.messageTemplate = messageTemplate || null;
            };
            /**
             * _AlertZone prototype (instance) functions.
             */
            this._AlertZone.prototype = {
                constructor: _outer._AlertZone,
                /**
                 * Sets the name and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function(name) {
                    this.name = name;
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack &&
                        _outer._loadedAlert.selectedStack.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlert.selectedStack.zones.'+_outer._loadedAlert.selectedStack.zones.indexOf(this)+'.name',name);
                    }
                },
                /**
                 * Sets the colour, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param colour
                 */
                setColour: function(colour) {
                    this.colour = colour;
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack &&
                        _outer._loadedAlert.selectedStack.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlert.selectedStack.zones.'+_outer._loadedAlert.selectedStack.zones.indexOf(this)+'.colour',colour);
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillColor':'#'+colour})
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    this.opacity = opacity;
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack &&
                        _outer._loadedAlert.selectedStack.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlert.selectedStack.zones.'+_outer._loadedAlert.selectedStack.zones.indexOf(this)+'.opacity',opacity);
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets active, updates the overlay and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param active
                 */
                setActive: function(active) {
                    this.active = active;
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack &&
                        _outer._loadedAlert.selectedStack.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlert.selectedStack.zones.'+_outer._loadedAlert.selectedStack.zones.indexOf(this)+'.active',active);
                    }
                    active ? this.activateOverlay() : this.deactivateOverlay();
                },
                /**
                 * Sets the northern coordinate and draws the nameOverlay.
                 * @param northernCoordinate
                 */
                setNorthernCoordinate: function(northernCoordinate) {
                    this.northernCoordinate = northernCoordinate;
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        this.nameOverlay = new _outer._ProximityZoneOverlay(this);
                    }
                },
                /**
                 * Sets renaming and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param renaming
                 */
                setRenaming: function(renaming) {
                    this.renaming = renaming;
                    if (_outer._loadedAlert && _outer._loadedAlert.selectedStack &&
                        _outer._loadedAlert.selectedStack.zones.indexOf(this) > -1) {
                        _outer.set('_loadedAlert.selectedStack.zones.'+_outer._loadedAlert.selectedStack.zones.indexOf(this)+'.renaming',renaming);
                    }
                },
                /**
                 * Activates the shape overlay.
                 */
                activateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({"strokeWeight":1.5});
                        this.shapeOverlay.setEditable(true);
                    }
                },
                /**
                 * Deactivates the shape overlay.
                 */
                deactivateOverlay: function() {
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({"strokeWeight":0});
                        this.shapeOverlay.setEditable(false);
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    this.shapeOverlay.setMap(null);
                    this.nameOverlay.setMap(null);
                }
            };
            Object.seal(this._AlertZone);

            /**
             * A class that represents a circular alert zone.
             * @param radius - The circle radius.
             * @param name - The user-defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @extends _AlertZone
             * @private
             */
            this._CircularAlertZone = function(radius,name,opacity,colour,messageTemplate,zIndex) {
                _outer._AlertZone.call(this,name,opacity,colour,messageTemplate,zIndex);
                this.setRadius(radius || 500);
                this.shapeOverlay = (new google.maps.Circle(this._getShapeOverlayOpts()));
            };
            //Inherit the prototype of _AlertZone.
            this._inheritPrototype(this._CircularAlertZone, this._AlertZone);
            /**
             * Returns the shape in string format.
             */
            this._CircularAlertZone.prototype.getShape = function() {
                return 'circle';
            };
            /**
             * Sets the radius and conditionally updates the shape overlay.
             * @param radius
             * @param skipOverlayUpdate
             */
            this._CircularAlertZone.prototype.setRadius = function(radius,skipOverlayUpdate) {
                this.radius = radius;
                if (!skipOverlayUpdate && this.shapeOverlay) {
                    this.shapeOverlay.setRadius(radius);
                }
            };
            /**
             * Returns the options for building a google maps circle.
             * @returns {*}
             * @private
             */
            this._CircularAlertZone.prototype._getShapeOverlayOpts = function() {
                return {
                    draggable: false, editable: false,
                    fillColor: '#'+this.colour, fillOpacity: this.opacity,
                    map: _outer._map, radius: this.radius,
                    strokeWeight:0, zIndex: this.zIndex,
                    suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                };
            };
            Object.seal(this._CircularAlertZone);

            /**
             * A class that represents a circular alert zone.
             * @param paths - The polygon paths, an array of arrays of LatLng objects.
             * @param name - The user-defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @extends _AlertZone
             * @private
             */
            this._PolygonalAlertZone = function(paths,name,opacity,colour,messageTemplate,zIndex) {
                _outer._AlertZone.call(this,name,opacity,colour,messageTemplate,zIndex);
                this.setPaths(paths);
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
            };
            //Inherit the prototype of _AlertZone.
            this._inheritPrototype(this._PolygonalAlertZone, this._AlertZone);
            /**
             * Returns the shape in string format.
             */
            this._PolygonalAlertZone.prototype.getShape = function() {
                return 'polygon';
            };
            /**
             * Sets the paths and updates the shape overlay.
             * @param paths
             */
            this._PolygonalAlertZone.prototype.setPaths = function(paths) {
                this.paths = paths;
                if (this.shapeOverlay) {
                    this.shapeOverlay.setPaths(paths);
                }
            };
            /**
             * Returns the options for building a google maps polygon.
             * @returns {*}
             * @private
             */
            this._PolygonalAlertZone.prototype._getShapeOverlayOpts = function() {
                return {
                    clickable: _outer.nodeName !== 'VOYENT-ALERT-VIEW', draggable: false,
                    editable: false, fillColor: '#'+this.colour,
                    fillOpacity: this.opacity, map: _outer._map,
                    strokeWeight:0, zIndex:this.zIndex, paths:this.paths,
                    suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                };
            };
            Object.seal(this._PolygonalAlertZone);

            /**
             * A class that represents the polygonal fallback alert zone.
             * @param enabled - Indicates whether the zone should be displayed immediately after initializing.
             * @param name - The user defined name.
             * @param opacity - The opacity of the zone, any value from 0 to 1.
             * @param colour - The colour of the zone, any hexadecimal colour without the #.
             * @param messageTemplate - The message template associated with this zone.
             * @param zIndex - The zIndex of the zone, any value between 49 and 0.
             * @private
             */
            this._FallbackAlertZone = function(enabled,name,opacity,colour,messageTemplate,zIndex) {
                this.id = _outer._FALLBACK_ZONE_ID;
                this.setPaths(this._buildWorldPolygon());
                this.shapeOverlay = (new google.maps.Polygon(this._getShapeOverlayOpts()));
                this._setupOverlayClickListener();
                this.setName(name || 'Fallback Zone');
                this.setOpacity(opacity || 0.30);
                this.setColour(colour || '000000');
                this.setZIndex(zIndex || 49);
                this.setActive(false);
                this.setRenaming(false);
                this.messageTemplate = messageTemplate || null;
                this.nameOverlay = new _outer._FallbackZoneOverlay(this);
                this.setEnabled(enabled);
            };

            this._FallbackAlertZone.prototype = {
                /**
                 * Sets the paths and updates the shape overlay.
                 */
                setPaths: function(paths) {
                    this.paths = paths;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setPaths(paths);
                    }
                },
                /**
                 * Sets the name and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function(name) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.name',name);
                    }
                    else {
                        this.name = name;
                    }
                },
                /**
                 * Sets the colour, updates the overlays and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param colour
                 */
                setColour: function(colour) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.colour',colour);
                    }
                    else {
                        this.colour = colour;
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillColor':'#'+colour})
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                },
                /**
                 * Sets the opacity, updates the overlay and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param opacity
                 */
                setOpacity: function(opacity) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.opacity',opacity);
                    }
                    else {
                        this.opacity = opacity;
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'fillOpacity':opacity});
                    }
                },
                /**
                 * Sets the zIndex and updates the overlay.
                 * @param zIndex
                 */
                setZIndex: function(zIndex) {
                    this.zIndex = zIndex;
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'zIndex':zIndex});
                    }
                },
                /**
                 * Sets active, updates the overlay and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param active
                 */
                setActive: function(active) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.active',active);
                    }
                    else {
                        this.active = active;
                    }
                },
                /**
                 * Sets renaming and if the instance is currently loaded
                 * we'll also notify the polymer path via set.
                 * @param renaming
                 */
                setRenaming: function(renaming) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.renaming',renaming);
                    }
                    else {
                        this.renaming = renaming;
                    }
                },
                /**
                 * Sets enabled, updates the overlays and if the instance is
                 * currently loaded we'll also notify the polymer path via set.
                 * @param enabled
                 */
                setEnabled: function(enabled) {
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer.set('_fallbackZone.enabled',enabled);
                    }
                    else {
                        this.enabled = enabled;
                    }
                    if (this.shapeOverlay) {
                        this.shapeOverlay.setOptions({'visible':enabled});
                    }
                    if (enabled) {
                        _outer.fire('voyent-alert-zone-added',{"id":this.id,"zone":this,"isFallbackZone":true});
                        this.punchOutOverlay();
                        if (this.nameOverlay) {
                            this.nameOverlay.draw();
                        }
                    }
                    else {
                        _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                        if (this.nameOverlay) {
                            this.nameOverlay.hide();
                        }
                    }
                },
                /**
                 * Removes the shape overlay from the map.
                 */
                removeFromMap: function() {
                    this.shapeOverlay.setMap(null);
                    this.nameOverlay.hide();
                    if (_outer._fallbackZone && _outer._fallbackZone === this) {
                        _outer._fallbackZone = null;
                    }
                    _outer.fire('voyent-alert-zone-removed',{"id":this.id,"isFallbackZone":true});
                },
                /**
                 * Punches out all of the stacks currently drawn on the map.
                 */
                punchOutOverlay: function() {
                    if (!this.enabled) { return; }
                    var paths = this._buildWorldPolygon();
                    if (_outer._loadedAlert) {
                        for (var i=0; i<_outer._loadedAlert.template.zoneStacks.length; i++) {
                            var largestZone = _outer._loadedAlert.template.zoneStacks[i].getLargestZone();
                            if (largestZone.getShape() === 'polygon') {
                                //Ideally we would just push the paths directly from the drawn polygon but Google expects
                                //a specific "winding order" of the coordinates. Whichever direction the coordinates
                                //are in for the outer zone, the coordinates for the inner "punched out" zones
                                //must be in the opposite direction. Google handles this ordering when using the Data Layer
                                //API, however, this is overly complex for our purposes. Instead we'll use turf to
                                //reorder the zones by punching them out and returning the newly sorted coordinates.

                                //Convert the array of fallback zone coordinates to a proper MVC paths array.
                                var fallbackPaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                    new google.maps.MVCArray([new google.maps.MVCArray(paths[0])])
                                )[0]];
                                //Select only the outer ring of the largest zone in the stack.
                                var largestZonePaths = [_outer._AlertTemplate.calculateCoordinatesFromPaths(
                                    largestZone.shapeOverlay.getPaths()
                                )[0]];
                                //Do the punch out.
                                var doughnut = turf.difference({
                                        "type": "Feature",
                                        "geometry": {
                                            "type": "Polygon",
                                            "coordinates": fallbackPaths
                                        }
                                    }, {
                                        "type": "Feature",
                                        "geometry": {
                                            "type": "Polygon",
                                            "coordinates": largestZonePaths
                                        }
                                    }
                                );
                                //The coordinates will now be in the correct order so we want to convert them back to paths
                                //and then use this to draw the Polygon. In this case, we don't use the punched out
                                //zone at all. This was only for the purposes of correctly ordering the coordinates list.
                                var orderedLargestZonePaths = _outer._AlertTemplate.calculatePathsFromCoordinates(
                                    doughnut.geometry.coordinates
                                )[1];
                                paths.push(orderedLargestZonePaths);
                            }
                            else {
                                //Since we can't punch out the circular zones directly
                                //we'll have to convert it to a many-sided polygon first.
                                //Loop backwards so we have proper ordering (see above).
                                var circularPath = [];
                                for (var k=_outer._NUM_CIRCULAR_POLY_SIDES-1; k>=0; k--) {
                                    circularPath.push(google.maps.geometry.spherical.computeOffset(
                                        largestZone.shapeOverlay.getCenter(),
                                        largestZone.shapeOverlay.getRadius(),
                                        _outer._CIRCULAR_POLY_DEGREE_STEP * k
                                    ));
                                }
                                paths.push(circularPath);
                            }
                        }
                    }
                    //The path at index 0 will be the entire fallback zone and
                    //all of the other paths will be punched out stacks.
                    this.setPaths(paths);
                },
                /**
                 * Returns a rectangular polygon representing the entire world.
                 */
                _buildWorldPolygon: function() {
                    //Since Google Maps uses a special web version of the Mercator projection and it
                    //excludes the polar regions the maximum latitude is closer to 85° instead of 90°.
                    var worldCoords = [
                        new google.maps.LatLng(85.05113, 180), new google.maps.LatLng(0, 180),
                        new google.maps.LatLng(-85.05113, 180), new google.maps.LatLng(-85.05113, 90),
                        new google.maps.LatLng(-85.05113, 0), new google.maps.LatLng(-85.05113, -90),
                        new google.maps.LatLng(-85.05113, -180), new google.maps.LatLng(0, -180),
                        new google.maps.LatLng(85.05113, -180), new google.maps.LatLng(85.05113, -90),
                        new google.maps.LatLng(85.05113, 0),new google.maps.LatLng(85.05113, 90),
                        new google.maps.LatLng(85.05113, 180)
                    ];
                    return [new google.maps.MVCArray(worldCoords).getArray()];
                },
                /**
                 * Initializes click listener for activating the overlay.
                 * @private
                 */
                _setupOverlayClickListener: function () {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    google.maps.event.addListener(this.shapeOverlay, 'click', function () {
                        _outer._toggleFallbackZoneProperties();
                    });
                },
                /**
                 * Returns the options for building a google maps polygon.
                 * @returns {*}
                 * @private
                 */
                _getShapeOverlayOpts: function() {
                    return {
                        clickable: true, draggable: false,
                        editable: false, fillColor: '#'+this.colour,
                        fillOpacity: this.opacity, map: _outer._map,
                        strokeWeight:0.5, zIndex:this.zIndex, paths:this.paths,
                        suppressUndo: true //This is undocumented but it works for now so we'll leverage it.
                    };
                }
            };
            Object.seal(this._FallbackAlertZone);

            /**
             * A class that represents a user's fixed location record, both the drawn map entity and the json.
             * @param id - The system-generated id.
             * @param name - The user-defined name.
             * @param isPrivateResidence - Indicates whether the location is a private residence.
             * @param marker - The associated map marker.
             * @private
             */
            this._MyLocation = function(id,name,isPrivateResidence,marker) {
                this.isPersisted = !!id;
                this.id = id || _outer._generateUid();
                this.setName(name || '');
                this.isPrivateResidence = typeof isPrivateResidence === 'boolean' ? isPrivateResidence : false;
                this.setMarker(marker);
            };
            this._MyLocation.prototype = {
                constructor: _outer._MyLocation,
                /**
                 * Sets the name, draws the nameOverlay and if the instance is currently
                 * loaded we'll also notify the polymer path via set.
                 * @param name
                 */
                setName: function (name) {
                    if (_outer._loadedLocation === this) {
                        _outer.set('_loadedLocation.name',name);
                    }
                    else {
                        this.name = name;
                    }
                    if (this.nameOverlay) {
                        this.nameOverlay.draw();
                    }
                    else {
                        this.nameOverlay = new _outer._LocationOverlay(this);
                    }
                },
                /**
                 * Sets the marker and sets up relevant listeners.
                 * @param marker
                 */
                setMarker: function(marker) {
                    this.marker = marker;
                    if (marker) {
                        this._setupMarkerListeners();
                    }
                },
                /**
                 * Adds the location to the map. Used to reverse `removeFromMap`.
                 */
                addToMap: function() {
                    this.marker.setMap(_outer._map);
                    this.nameOverlay.displayAndDraw();
                },
                /**
                 * Removes the location from the map.
                 */
                removeFromMap: function() {
                    this.marker.setMap(null);
                    this.nameOverlay.hide();
                },
                /**
                 * Updates the JSON to reflect the current state of the template.
                 * @private
                 */
                updateJSON: function() {
                    var markerPosition = this.marker.getPosition();
                    this.json = {
                        "location": {
                            "geometry": {
                                "type": "Point",
                                "coordinates": [markerPosition.lng(),markerPosition.lat()]
                            },
                            "properties": {
                                "vras": {
                                    "id": this.id,
                                    "name": this.name,
                                    "type": this.isPrivateResidence ? 'residential' : 'other'
                                }
                            }
                        }
                    }
                },
                /**
                 * Initializes marker listeners.
                 * @private
                 */
                _setupMarkerListeners: function() {
                    if (_outer.nodeName === 'VOYENT-ALERT-VIEW') { return; }
                    var _this = this;
                    //Continuously re-draw the overlay as the location is dragged.
                    var marker = this.marker;
                    google.maps.event.addListener(marker,'drag',function() {
                        _this.nameOverlay.draw();
                    });
                    //Update the coordinates on the location record and flag the location for updating after it's dragged.
                    google.maps.event.addListener(marker,'dragend',function() {
                        _outer.flagLocationForUpdating(_this);
                    });
                    //Display infoWindow on location marker click.
                    google.maps.event.addListener(marker,'click',function() {
                        _outer._toggleInfoWindow(_this);
                    });
                }
            };
            Object.seal(this._MyLocation);

            /**
             * A class that represents the fallback zone control overlay.
             * @private
             */
            this._FallbackZoneOverlay = function(zone) {
                this.zone = zone;
                this.div = _outer._buildOverlayDiv('zone');
                if (zone.enabled) {
                    this.draw();
                }
            };
            this._FallbackZoneOverlay.prototype = {
                /**
                 * Handles drawing and re-drawing of the fallback zone control overlay on the map.
                 */
                draw: function() {
                    //Set the div content, replacing spaces with non-breaking ones.
                    this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                    //Configure the styling.
                    this.div.style.backgroundColor = '#'+this.zone.colour;
                    this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
                    //Add the overlay.
                    _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].clear();
                    _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].push(this.div);
                },
                /**
                 * Hide the control overlay.
                 */
                hide: function() {
                    _outer._map.controls[google.maps.ControlPosition.TOP_CENTER].clear();
                }
            };
            /**
             * A class that represents a zone name overlay.
             * @param zone - The zone for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._ProximityZoneOverlay = function(zone) {
                this.zone = zone;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv('zone');
            };
            /**
             * A class that represents a location name overlay.
             * @param location - The location for which the overlay will be displayed.
             * @extends google.maps.OverlayView
             * @private
             */
            this._LocationOverlay = function(location) {
                this.loc = location;
                this.setMap(_outer._map);
                this.div = _outer._buildOverlayDiv('location');
            };
            //Inherit the prototype of google.maps.OverlayView.
            this._ProximityZoneOverlay.prototype = new google.maps.OverlayView();
            this._LocationOverlay.prototype = new google.maps.OverlayView();
            /**
             * Called automatically when the map is ready for the overlay to be attached.
             */
            this._ProximityZoneOverlay.prototype.onAdd =
            this._LocationOverlay.prototype.onAdd = function () {
                //Add the div to the floatShadow pane so it renders above the markers.
                this.getPanes().floatShadow.appendChild(this.div);
            };
            /**
             * Handles drawing and re-drawing of the proximity zone overlay on the map.
             */
            this._ProximityZoneOverlay.prototype.draw = function() {
                //This will be called before it's ready when loading Alerts so we'll return if the prototype isn't initialized.
                if (!this.getProjection()) { return; }
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var northernCoordinate = this.zone.northernCoordinate;
                var nc = this.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(northernCoordinate[1],northernCoordinate[0])
                );
                //Set the div content, replacing spaces with non-breaking ones.
                this.div.innerHTML = this.zone.name.split(' ').join('&nbsp;');
                //Center the label above the zone.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-20 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#'+this.zone.colour;
                this.div.style.color = this.returnColourBasedOnBackground(this.zone.colour);
            };
            /**
             * Handles drawing and re-drawing of the location overlay on the map.
             */
            this._LocationOverlay.prototype.draw = function () {
                //Retrieve the north-center coordinates of this overlay and convert them to pixel coordinates.
                var nc = this.getProjection().fromLatLngToDivPixel(this.loc.marker.getPosition());
                //Set the div content.
                this.div.innerHTML = this.loc.name;
                //Center the label above the location.
                this.div.style.left = (nc.x - this.div.offsetWidth/2) + 'px';
                this.div.style.top = nc.y-60 + 'px';
                //Configure the styling.
                this.div.style.backgroundColor = '#64FE86';
                this.div.style.color = '#000000';
            };
            /**
             * Cleans up the overlay whenever the overlays map property is set to null.
             */
            this._ProximityZoneOverlay.prototype.onRemove =
            this._LocationOverlay.prototype.onRemove = function () {
                    this.div.parentNode.removeChild(this.div);
                    this.div = null;
            };
            /**
             * Hide the overlay.
             */
            this._LocationOverlay.prototype.hide = function() {
                this.div.style.display = 'none';
            };
            /**
             * Re-display the overlay.
             */
            this._LocationOverlay.prototype.displayAndDraw = function() {
                this.div.style.display = 'block';
                this.draw();
            };
            /**
             * Returns a font colour of black or white based on the zone colour.
             */
            this._FallbackZoneOverlay.prototype.returnColourBasedOnBackground =
            this._ProximityZoneOverlay.prototype.returnColourBasedOnBackground = function(hex) {
                return (
                    0.213 * parseInt(hex.slice(0, 2), 16) +
                    0.715 * parseInt(hex.slice(2, 4), 16) +
                    0.072 * parseInt(hex.slice(4, 6), 16) >
                    255 / 2
                ) ? '#000' : '#FFF';
            };
            Object.seal(this._FallbackZoneOverlay);
            Object.seal(this._ProximityZoneOverlay);
            Object.seal(this._LocationOverlay);
        }
    };
</script>