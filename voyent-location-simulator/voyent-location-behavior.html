<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../common/imports/voyent-io.html">

<script>
    var Voyent = Voyent || {};
    /**
     Provides common functionality required by `voyent-location-*` components.
     @polymerBehavior
     */
    Voyent.LocationBehavior = {
        properties: {
            _EARTH_RADIUS: {
                type: Number,
                value: 6371000, //earth's mean radius in meters
                readonly: true
            },
            _KPH_TO_MPS: {
                type: Number,
                value: 0.277778,
                readonly: true
            },
            _MPH_TO_MPS: {
                type: Number,
                value: 0.44704,
                readonly: true
            }
        },

        ready: function() {
            var _this = this;
            window.addEventListener('boundsUpdated', function(e) {
                //when the map bounds are updated for a route or vector during a multi-path
                //simulation we need to set the bounds based on all simulation positions
                if (_this._isMultiSim) {
                    _this._bounds.union(e.detail.bounds);
                    _this._map.fitBounds(_this._bounds);
                    _this._map.panToBounds(_this._bounds);

                }
            });
        },

        /**
         * Pause the simulation at it's current location along the path.
         */
        pauseSimulation: function() {
            if (!this._path) {
                return;
            }
            this._paused = true;
        },

        /**
         * Cancel the currently running simulation.
         */
        cancelSimulation: function() {
            if (!this._path) {
                return;
            }
            this._canceled = true;
            //if the simulation is paused before it's cancelled then we must cleanup manually
            if (this._paused) {
                this._cleanupSimulation();
            }
        },

        /**
         * Get the next coordinate in the simulation and send it to the Location Service. Can be used to step forwards when the simulation is paused.
         */
        nextCoordinate: function() {
            var _this = this;
            var i = this._index+1; //get next coordinate
            if (!this._path || !this._marker || !this._location || !this._paused) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            var path = this._path;
            this._location.location.geometry.coordinates = [path[i].lng(),path[i].lat()]; //get the next location
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function() {
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                _this._marker.setPosition({lat:path[i].lat(),lng:path[i].lng()}); //move the marker to the new location
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills-_this._interval); //update the ETA
                }
                if (i+1 == path.length) {
                    _this.updateLocationAtMarker();
                    _this._cleanupSimulation();
                    return;
                }
                _this._index = i;
                _this._previousBtnDisabled=false;
            }).catch(function(error) {
                _this.fire('message-error', 'Issue stepping to next location "' + _this._location.username + '": ' + error);
                console.error('Issue stepping to next location:',_this._location.username,error);
            });
        },


        /**
         * Get the previous coordinate in the simulation and send it to the Location Service. Can be used to step backwards when the simulation is paused.
         */
        previousCoordinate: function() {
            var _this = this;
            var i = this._index-1; //get previous coordinate
            if (!this._path || !this._marker || !this._location || !this._paused || i<0) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            var route = this._path;
            this._location.location.geometry.coordinates = [route[i].lng(),route[i].lat()]; //get the previous location
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function() {
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                _this._marker.setPosition({lat:route[i].lat(),lng:route[i].lng()}); //move the marker to the new location
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills+_this._interval); //update the ETA
                }
                _this._index = i;
                if (i === 0) {
                    _this._previousBtnDisabled=true;
                }
            }).catch(function(error) {
                _this.fire('message-error', 'Issue stepping to previous location "' + _this._location.username + '": ' + error);
                console.error('Issue stepping to previous location:',_this._location.username,error);
            });
        },

        /**
         * Force an update of the location at it's current point in the simulation. This is in addition to the updates already being triggered by the `frequency` attribute.
         */
        updateLocationAtMarker: function() {
            var _this = this;
            if (!this._location) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function(data) {
                if (!_this._location) {
                    return; //the simulation has been cleaned up
                }
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
            }).catch(function(error) {
                _this.fire('message-error', 'Issue updating location:' + error);
                console.error('Issue updating location:',error);
            });
        },

        /**
         * Wrapper for playSimulation. Specifies a special flag for playing multiple simulations simultaneously.
         * @private
         */
        _playSimulationMulti: function() {
            //start the simulation with a clean bounds
            this._bounds = new google.maps.LatLngBounds();
            this._isMultiSim = true;
            this.playSimulation();
        },

        /**
         * Handles continuous playing of the simulation.
         * @private
         */
        _doSimulation: function() {
            var _this = this;
            this._updateOnFrequency();
            this._paused = false;
            var i = this._index+1; //get next coordinate
            this._location.location.geometry.coordinates = [this._path[i].lng(),this._path[i].lat()]; //get the next location
            var updatePosition = setInterval(function() {
                //reset the bounds each time so that previous user/tracker locations are not included in the bounds
                if (!_this._isMultiSim) {
                    //reset the bounds every time movement occurs when running a single simulation
                    _this._bounds = new google.maps.LatLngBounds();
                }
                _this._marker.setPosition({lat:_this._path[i].lat(),lng:_this._path[i].lng()}); //update the marker position
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills-_this._interval); //update the ETA
                }
                //keep the map zoomed on the simulation
                _this._bounds.extend(new google.maps.LatLng(_this._path[i].lat(),_this._path[i].lng()));
                _this._map.fitBounds(_this._bounds);
                _this._map.panToBounds(_this._bounds);
                _this.fire('boundsUpdated',{"bounds":_this._bounds});
                if (_this._paused) {
                    //save the current index and stop recursion
                    _this._index = i;
                    clearInterval(updatePosition);
                    return;
                }
                if (_this._canceled || i+1 == _this._path.length) {
                    //submit last coordinate to the location service
                    if (i+1 == _this._path.length) {
                        _this.updateLocationAtMarker();
                    }
                    //cleanup simulation and stop recursion
                    _this._cleanupSimulation();
                    clearInterval(updatePosition);
                    return;
                }
                i++;
                _this._location.location.geometry.coordinates = [_this._path[i].lng(),_this._path[i].lat()]; //get the next location
            },this._interval);
        },

        /**
         * Handles updating the location in the Location Service during simulation. The `frequency` attribute determines how often the location is updated on the server.
         * @private
         */
        _updateOnFrequency: function() {
            var _this = this;
            var updateLocation = setInterval(function() {
                if (_this._paused || _this._canceled || !_this._location) {
                    clearInterval(updateLocation);
                    return;
                }
                var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
                voyent.io.locate[func]({realm:Polymer.dom(_this).parentNode.realm,location:_this._location}).then(function(data) {
                    if (!_this._location) {
                        return; //the simulation has been cleaned up
                    }
                    _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function(error) {
                    _this.fire('message-error', 'Issue updating location: ' + error);
                    console.error('Issue updating location:',error);
                });
            },this.frequency*1000);
        },

        /**
         * When a user is dragged to a new location on the map update their location in the Location Service.
         * @param marker
         * @param location
         */
        _userLocationChangedListener: function(marker,location) {
            google.maps.event.addListener(marker, "dragend", function () {
                location.location.geometry.coordinates = [marker.getPosition().lng(), marker.getPosition().lat()];
                if (location.username && location.username.length > 0) {
                    location.demoUsername = location.username; //(NTFY-301)
                }
                voyent.io.locate.updateLocation({location: location}).then(function(data) {
                    location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function (error) {
                    console.log('Issue changing location of user "' + location.username + '":', error);
                });
            });
        },

        /**
         * When a tracker is dragged to a new location on the map update it's location in the Location Service.
         * @param marker
         * @param id
         * @param location
         */
        _trackerLocationChangedListener: function(marker,id,location) {
            var _this = this;
            google.maps.event.addListener(marker, "dragend", function () {
                location.location.geometry.coordinates = [marker.getPosition().lng(), marker.getPosition().lat()];
                if (location.username && location.username.length > 0) {
                    location.demoUsername = location.username; //(NTFY-301)
                }
                //move the zones with the tracker
                _this._trackerMoved(id,marker);

                voyent.io.locate.updateTrackerLocation({location: location}).then(function(data) {
                    location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function (error) {
                    console.log('Issue changing location of tracker "' + location.username + '":', error);
                });
            });
        },

        /**
         * Moves zones associated with a tracker to a new location based
         * on the marker's location + update the stored tracker location.
         * @param id
         * @param marker
         */
        _trackerMoved: function(id,marker) {
            //update the center point of associated zones
            var zones = this._trackers[id].zones;
            for (var i=0; i<zones.length; i++) {
                var latLng = new google.maps.LatLng(marker.getPosition().lat(),marker.getPosition().lng());
                zones[i].setCenter(latLng);
                if (this._bounds) {
                    this._bounds.union(zones[i].getBounds());
                }
            }
            //update the tracker so that the tracker
            //location is always the last known location
            this._trackers[id].tracker.anchor.geometry.coordinates = [marker.getPosition().lng(),marker.getPosition().lat()];
            this.fire('trackersRetrieved',{trackers:this._trackers});
        },

        /**
         * Returns the tracker label or the _id.
         * @param tracker
         * @private
         */
        _getZoneNamespace: function(tracker) {
            return tracker.label || tracker._id;
        },

        /**
         * Toggle disabled button state.
         * @param paused
         * @private
         */
        _pausedChanged: function(paused) {
            this._previousBtnDisabled=!paused;
            this._nextBtnDisabled=!paused;
            this._playBtnDisabled = !paused;
            this._pauseBtnDisabled = paused;
        },

        /**
         * Fire `labelChanged` event.
         * @param newVal
         * @param oldVal
         * @private
         */
        _labelChanged: function(newVal,oldVal) {
            this.fire('labelChanged',{child:this,label:newVal});
        },

        /**
         * Validates the `speed` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _speedValidation: function(newVal,oldVal) {
            if (isNaN(newVal) || newVal <= 0) {
                this.speed = oldVal || 50;
            }
        },

        /**
         * Validates the `speedunit` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _speedunitValidation: function(newVal,oldVal) {
            if (newVal !== 'kph' && newVal !== 'mph') {
                this.speedunit = oldVal || 'kph';
            }
        },

        /**
         * Validates the `frequency` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _frequencyValidation: function(newVal,oldVal) {
            if (isNaN(newVal) || newVal <= 0) {
                this.frequency = oldVal || 5;
            }
        },

        /**
         * Convert degrees to radians
         * @param degrees
         * @returns {number}
         */
        _toRadians: function(degrees) {
            return degrees * Math.PI / 180;
        },

        /**
         * Convert radians to degrees
         * @param radians
         * @returns {number}
         */
        _toDegrees: function(radians) {
            return radians * 180 / Math.PI;
        },

        /**
         * Convert trackers mapping to an array.
         * @param trackers
         * @returns {Array}
         * @private
         */
        _toArray: function(trackers) {
            return Object.keys(trackers).map(function (key) {
                return trackers[key].tracker;
            });
        }
    };
</script>