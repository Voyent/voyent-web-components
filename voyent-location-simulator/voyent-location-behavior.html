<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../common/imports/voyent-io.html">

<script>
    var Voyent = Voyent || {};
    /**
     Provides common functionality required by `voyent-location-*` components.
     @polymerBehavior
     */
    Voyent.LocationBehavior = {
        properties: {
            _EARTH_RADIUS: {
                type: Number,
                value: 6371000, //earth's mean radius in meters
                readonly: true
            },
            _KPH_TO_MPS: {
                type: Number,
                value: 0.277778,
                readonly: true
            },
            _MPH_TO_MPS: {
                type: Number,
                value: 0.44704,
                readonly: true
            }
        },

        ready: function() {
            var _this = this;
            window.addEventListener('boundsUpdated', function(e) {
                //when the map bounds are updated for a route or vector during a multi-path
                //simulation we need to set the bounds based on all simulation positions
                if (_this._isMultiSim) {
                    _this._bounds.union(e.detail.bounds);
                    _this._map.fitBounds(_this._bounds);
                    _this._map.panToBounds(_this._bounds);

                }
            });
        },

        /**
         * Pause the simulation at it's current location along the path.
         */
        pauseSimulation: function() {
            if (!this._path) {
                return;
            }
            this._paused = true;
        },

        /**
         * Cancel the currently running simulation.
         */
        cancelSimulation: function() {
            if (!this._path) {
                return;
            }
            this._canceled = true;
            //if the simulation is paused before it's cancelled then we must cleanup manually
            if (this._paused) {
                this._cleanupSimulation();
            }
        },

        /**
         * Get the next coordinate in the simulation and send it to the Location Service. Can be used to step forwards when the simulation is paused.
         */
        nextCoordinate: function() {
            var _this = this;
            var i = this._index+1; //get next coordinate
            if (!this._path || !this._marker || !this._location || !this._paused) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            var path = this._path;
            this._location.location.geometry.coordinates = [path[i].lng(),path[i].lat()]; //get the next location
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function() {
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                _this._marker.setPosition({lat:path[i].lat(),lng:path[i].lng()}); //move the marker to the new location
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker+'.'+_this.zonenamespace,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills-_this._interval); //update the ETA
                }
                if (i+1 == path.length) {
                    _this.updateLocationAtMarker();
                    _this._cleanupSimulation();
                    return;
                }
                _this._index = i;
                _this._previousBtnDisabled=false;
            }).catch(function(error) {
                var locationName = _this.tracker ? _this._location.location.properties.zoneNamespace : _this._location.username;
                _this.fire('message-error', 'Issue stepping to next location "' + locationName + '": ' + error);
                console.error('Issue stepping to next location:',locationName,error);
            });
        },


        /**
         * Get the previous coordinate in the simulation and send it to the Location Service. Can be used to step backwards when the simulation is paused.
         */
        previousCoordinate: function() {
            var _this = this;
            var i = this._index-1; //get previous coordinate
            if (!this._path || !this._marker || !this._location || !this._paused || i<0) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            var route = this._path;
            this._location.location.geometry.coordinates = [route[i].lng(),route[i].lat()]; //get the previous location
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function() {
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                _this._marker.setPosition({lat:route[i].lat(),lng:route[i].lng()}); //move the marker to the new location
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker+'.'+_this.zonenamespace,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills+_this._interval); //update the ETA
                }
                _this._index = i;
                if (i === 0) {
                    _this._previousBtnDisabled=true;
                }
            }).catch(function(error) {
                var locationName = _this.tracker ? _this._location.location.properties.zoneNamespace : _this._location.username;
                _this.fire('message-error', 'Issue stepping to previous location "' + locationName + '": ' + error);
                console.error('Issue stepping to previous location:',locationName,error);
            });
        },

        /**
         * Force an update of the location at it's current point in the simulation. This is in addition to the updates already being triggered by the `frequency` attribute.
         */
        updateLocationAtMarker: function() {
            var _this = this;
            if (!this._location) {
                return;
            }
            var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
            voyent.io.locate[func]({realm:Polymer.dom(this).parentNode.realm,location:this._location}).then(function(data) {
                if (!_this._location) {
                    return; //the simulation has been cleaned up
                }
                _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
            }).catch(function(error) {
                _this.fire('message-error', 'Issue updating location:' + error);
                console.error('Issue updating location:',error);
            });
        },

        /**
         * Wrapper for playSimulation. Specifies a special flag for playing multiple simulations simultaneously.
         * @private
         */
        _playSimulationMulti: function() {
            //start the simulation with a clean bounds
            this._bounds = new google.maps.LatLngBounds();
            this._isMultiSim = true;
            this.playSimulation();
        },

        /**
         * Handles continuous playing of the simulation.
         * @private
         */
        _doSimulation: function() {
            var _this = this;
            this._updateOnFrequency();
            this._paused = false;
            var i = this._index+1; //get next coordinate
            this._location.location.geometry.coordinates = [this._path[i].lng(),this._path[i].lat()];
            //set the max zoom so the map doesn't zoom in too far when panning during the simulation
            this._map.setOptions({ maxZoom: 15 });
            var updatePosition = setInterval(function() {
                //reset the bounds each time so that previous user/tracker locations are not included in the bounds
                if (!_this._isMultiSim) {
                    //reset the bounds every time movement occurs when running a single simulation
                    _this._bounds = new google.maps.LatLngBounds();
                }
                _this._marker.setPosition({lat:_this._path[i].lat(),lng:_this._path[i].lng()}); //update the marker position
                if (_this.tracker) {
                    _this._trackerMoved(_this.tracker+'.'+_this.zonenamespace,_this._marker); //update the zone positions
                }
                else {
                    _this._updateETA(_this._totalMills-_this._interval); //update the ETA
                }
                //keep the map zoomed on the simulation
                _this._bounds.extend(new google.maps.LatLng(_this._path[i].lat(),_this._path[i].lng()));
                _this._map.fitBounds(_this._bounds);
                _this._map.panToBounds(_this._bounds);
                _this.fire('boundsUpdated',{"bounds":_this._bounds});
                if (_this._paused) {
                    _this._map.setOptions({ maxZoom: null });
                    //save the current index and stop recursion
                    _this._index = i;
                    clearInterval(updatePosition);
                    return;
                }
                if (_this._canceled || i+1 == _this._path.length) {
                    //submit last coordinate to the location service
                    if (i+1 == _this._path.length) {
                        _this.updateLocationAtMarker();
                    }
                    //cleanup simulation and stop recursion
                    _this._cleanupSimulation();
                    clearInterval(updatePosition);
                    return;
                }
                i++;
                _this._location.location.geometry.coordinates = [_this._path[i].lng(),_this._path[i].lat()]; //get the next location
            },this._interval);
        },

        /**
         * Handles updating the location in the Location Service during simulation. The `frequency` attribute determines how often the location is updated on the server.
         * @private
         */
        _updateOnFrequency: function() {
            var _this = this;
            var updateLocation = setInterval(function() {
                if (_this._paused || _this._canceled || !_this._location) {
                    clearInterval(updateLocation);
                    return;
                }
                var func = this.tracker ? 'updateTrackerLocation' : 'updateLocation';
                voyent.io.locate[func]({realm:Polymer.dom(_this).parentNode.realm,location:_this._location}).then(function(data) {
                    if (!_this._location) {
                        return; //the simulation has been cleaned up
                    }
                    _this._location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function(error) {
                    _this.fire('message-error', 'Issue updating location: ' + error);
                    console.error('Issue updating location:',error);
                });
            },this.frequency*1000);
        },

        /**
         * When a user is dragged to a new location on the map update their location in the Location Service.
         * @param marker
         * @param location
         */
        _userLocationChangedListener: function(marker,location) {
            var _this = this;
            google.maps.event.addListener(marker, "dragend", function () {
                location.location.geometry.coordinates = [marker.getPosition().lng(), marker.getPosition().lat()];
                if (location.username && location.username.length > 0) {
                    location.demoUsername = location.username; //(NTFY-301)
                }
                voyent.io.locate.updateLocation({location: location}).then(function(data) {
                    location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue changing location of user "' + location.username + '":' + error);
                    console.error('Issue changing location of user "' + location.username + '":', error);
                });
            });
        },

        /**
         * When a tracker is dragged to a new location on the map update it's location in the Location Service.
         * @param marker
         * @param instanceKey
         * @param location
         */
        _trackerLocationChangedListener: function(marker,instanceKey,location) {
            var _this = this;
            //clear the listeners first since we will call this function twice
            //in cases where we need to dynamically create a tracker template
            google.maps.event.clearListeners(marker,'dragend');
            google.maps.event.addListener(marker, "dragend", function () {
                location.location.geometry.coordinates = [marker.getPosition().lng(), marker.getPosition().lat()];
                if (location.username && location.username.length > 0) {
                    location.demoUsername = location.username; //(NTFY-301)
                }
                //move the zones with the tracker
                _this._trackerMoved(instanceKey,marker);

                voyent.io.locate.updateTrackerLocation({location: location}).then(function(data) {
                    location.lastUpdated = new Date().toISOString(); //won't match server value exactly but useful for displaying in infoWindow
                }).catch(function (error) {
                    _this.fire('message-error', 'Issue changing location of tracker "' + location.location.properties.zoneNamespace + '":' + error);
                    console.error('Issue changing location of tracker "' + location.location.properties.zoneNamespace + '":', error);
                });
            });
        },

        /**
         * Update the map bounds and the stored tracker location.
         * @param instanceKey
         * @param marker
         */
        _trackerMoved: function(instanceKey,marker) {
            //update the center point of associated zones
            var zones = this._trackerInstances[instanceKey].zones;
            for (var i=0; i<zones.length; i++) {
                if (this._bounds) {
                    this._bounds.union(zones[i].getBounds());
                }
            }
            //keep the tracker instance updated with the latest coordinates
            this._trackerInstances[instanceKey].tracker.anchor.geometry.coordinates = [marker.getPosition().lng(),marker.getPosition().lat()];
            this.fire('_trackerInstancesRetrieved',{trackerInstances:this._trackerInstances});
        },

        /**
         * Toggles editable/draggable on the passed zones and anchor.
         * @param zones
         * @param marker
         * @param editable - whether or not to allow the zones to be resized
         */
        _toggleEditableTracker: function(zones,marker,editable) {
            for (var i=0; i<zones.length; i++) {
                zones[i].setEditable(!!editable);
            }
            marker.setDraggable(!!editable);
        },

        /**
         * Returns the tracker label or the _id.
         * @param tracker
         * @private
         */
        _getTrackerName: function(tracker) {
            return tracker.label || tracker._id;
        },

        /**
         * Toggle disabled button state.
         * @param paused
         * @private
         */
        _pausedChanged: function(paused) {
            this._previousBtnDisabled=!paused;
            this._nextBtnDisabled=!paused;
            this._playBtnDisabled = !paused;
            this._pauseBtnDisabled = paused;
        },

        /**
         * Validates the `speed` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _speedValidation: function(newVal,oldVal) {
            var val = Number(newVal);
            if (Number.isNaN(val) || val <= 0) {
                this.speed = oldVal || 50;
            }
        },

        /**
         * Validates the `speedunit` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _speedunitValidation: function(newVal,oldVal) {
            if (newVal !== 'kph' && newVal !== 'mph') {
                this.speedunit = oldVal || 'mph';
            }
        },

        /**
         * Validates the `frequency` attribute. If invalid, the old value, or the default will be used.
         * @param newVal
         * @param oldVal
         * @private
         */
        _frequencyValidation: function(newVal,oldVal) {
            var val = Number(newVal);
            if (Number.isNaN(val) || val <= 0) {
                this.frequency = oldVal || 5;
            }
        },

        /**
         * Convert degrees to radians
         * @param degrees
         * @returns {number}
         */
        _toRadians: function(degrees) {
            return degrees * Math.PI / 180;
        },

        /**
         * Convert radians to degrees
         * @param radians
         * @returns {number}
         */
        _toDegrees: function(radians) {
            return radians * 180 / Math.PI;
        }
    };
</script>