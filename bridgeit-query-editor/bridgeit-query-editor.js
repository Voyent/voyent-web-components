var _qEditor;

Polymer({

    is: "bridgeit-query-editor",
    properties: {
        /**
         * Required to authenticate with BridgeIt.
         * @default bridgeit.io.auth.getLastAccessToken()
         */
        accesstoken: { type: String, value: bridgeit.io.auth.getLastAccessToken() },
        /**
         * Defines the BridgeIt realm to build queries for.
         * @default bridgeit.io.auth.getLastKnownRealm()
         */
        realm: { type: String, value: bridgeit.io.auth.getLastKnownRealm() },
        /**
         * Defines the BridgeIt account to build queries for.
         * @default bridgeit.io.auth.getLastKnownAccount()
         */
        account: { type: String, value: bridgeit.io.auth.getLastKnownAccount() },
        /**
         * The service that you would like to build the query for. Currently only `documents` and `location` are supported.
         */
        service: { type: String, value: 'documents' },
        /**
         * The collection that you would like to build the query for. This initial dataset determines the fields available in the editor. If service is `location` then the available collections are `locations`, `regions`, `pois` and `monitors`.
         */
        collection: { type: String, value: 'documents' },
        /**
         * Specify the inclusion or exclusion of fields to return in the result set.
         *
         * Example:
         *
         *      //exclude _id column
         *      {"_id":0}
         */
        fields: { type: Object, value: {} },
        /**
         * Additional query options such as limit and sort.
         *
         * Example:
         *
         *      //sort by _id (descending) + get only 100 records
         *      {"sort":{"_id":-1},"limit":100}
         */
        options: { type: Object, value: {} },
        /**
         * Element ID of where the GET URL of the query will be displayed as the query is built. Supports input and non-input elements.
         */
        queryurltarget: { type: String },
        /**
         * A string representation of the object returned from the `queryExecuted` event. Use when data binding is preferred over event listeners.
         */
        queryresults: { type: String, reflectToAttribute: true, readOnly: true },
        /**
         * A string representation of the results array returned from the `queriesRetrieved` event. Use when data binding is preferred over event listeners.
         */
        querylistresults: { type: String, reflectToAttribute: true, readOnly: true }
    },

    /**
     * Fired after a query is executed, this occurs on the initial load and when calling `runQuery()` or `reloadEditor()`. Contains the query results and the unique fields.
     *
     * @event queryExecuted
     */

    /**
     * Fired after the query list is retrieved, this occurs on the initial load and when calling `fetchQueryList()`, `saveQuery()`, `cloneQuery()`, `deleteQuery()`. Contains the list of saved queries in this realm.
     *
     * @event queriesRetrieved
     */

    /**
     * Fired whenever there is a message for an action that was triggered. Contains the message and the message type (info, error).
     *
     * @event queryMsgUpdated
     */

    created: function() {
        _qEditor = this;
    },

    ready: function() {
        _qEditor.reloadEditor();
        _qEditor.fetchQueryList();
    },

    /**
     * Execute the current query.
     */
    runQuery: function() {
        var query = $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('getMongo');
        if (Object.keys(query).length !== 0) {
            _qEditor._queryService(query);
        }
    },

    /**
     * Creates or updates a query using the provided parameters.
     * If there is an active query in the editor then the ID parameter will be ignored and the query will be updated. Otherwise a new query is created using the provided or server generated ID.
     * @param id - The query ID, ignored if doing an update
     * @param description - Optional query description
     * @param services - Optional services array
     */
    saveQuery: function(id,description,services) {
        var query = _qEditor._buildQuery(id,description,services,false);
        if (query !== null) {
            _qEditor._createQuery(query);
        }
    },

    /**
     * Clones the currently active query using the provided parameters.
     * @param id - The query ID, generated by the service if not provided
     * @param description - Optional query description, if not provided then the existing value, if any, will be cloned
     * @param services - Optional services array, if not provided then the existing value, if any, will be cloned
     */
    cloneQuery: function(id,description,services) {
        if (!_qEditor.activeQuery) {
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'No query to clone.','type':'error'});
            return;
        }
        var query = _qEditor._buildQuery(id,description,services,true);
        if (query !== null) {
            _qEditor._createQuery(query);
        }
    },

    /**
     * Deletes the currently active query.
     */
    deleteQuery: function() {
        if (!_qEditor.activeQuery || !_qEditor.activeQuery._id) {
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'No query to delete.','type':'error'});
            return;
        }
        _qEditor._deleteQuery();
    },

    /**
     * Clears the query editor and restores the `fields` and `options` attributes to their original values.
     */
    resetEditor: function() {
        $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('reset');
        _qEditor.options = JSON.parse(_qEditor.getAttribute('options')) || {};
        _qEditor.fields = JSON.parse(_qEditor.getAttribute('fields')) || {};
        _qEditor.activeQuery = null;
        _qEditor._setQueryHeader(null);
        _qEditor._updateQueryURL();
    },

    /**
     * Retrieves a list of all the queries in the current realm.
     */
    fetchQueryList: function() {
        if (!_qEditor.accesstoken || !_qEditor.realm || !_qEditor.account || !_qEditor.service || !_qEditor.collection) {
            return;
        }
        _qEditor._getAllQueries();
    },

    /**
     * Populate the editor from an existing query.
     * @param query - The query in object form.
     */
    setEditorFromMongo: function(query) {
        _qEditor.skipListeners = true;
        _qEditor.options = query.options || {};
        _qEditor.fields = query.fields || {};
        try {
            $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('setRulesFromMongo',query.query);
            _qEditor.activeQuery = query;
            _qEditor._setQueryHeader(query);
        }
        catch (e) {
            var errorMsg = 'Unable to populate query editor. ';
            if (e.message.indexOf('Undefined filter') !== -1) {
                errorMsg = errorMsg + '"' + e.message.split('Undefined filter: ').join('') + '"' + ' field does not exist in this database.';
            }
            else {
                errorMsg = errorMsg + e.message;
            }
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: errorMsg,'type':'error'});
        }
        _qEditor._updateQueryURL(query.query);
        _qEditor.skipListeners = false;
    },

    /**
     * Completely destroy and reinitialize the editor.
     */
    reloadEditor: function() {
        if (!_qEditor.accesstoken || !_qEditor.realm || !_qEditor.account || !_qEditor.service || !_qEditor.collection) {
            return;
        }
        $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('destroy');
        _qEditor._queryService({});
        _qEditor._updateQueryURL();
    },

    /**
     * Test if the current query is valid.
     * @return {boolean} boolean indicating if the query is valid.
     */
    validateQuery: function() {
        return Object.keys($(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('getMongo')).length > 0;
    },

    /**
     * Get the currently active query.
     * @return {object} object representation of the currently active query or null if the there is no active query.
     */
    getActiveQuery: function() {
        return _qEditor.activeQuery || null;
    },


    //******************PRIVATE API******************

    _createQuery: function(query) {
        bridgeit.io.query.createQuery({
            accessToken: _qEditor.accesstoken,
            account: _qEditor.account,
            realm: _qEditor.realm,
            query: query
        }).then(function(uri) {
            var queryId = uri.split("/").pop();
            query._id = queryId;
            _qEditor.activeQuery = query;
            _qEditor._setQueryHeader(_qEditor.activeQuery);
            _qEditor.fetchQueryList();
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'Query "'+queryId+'" saved','type':'info'});
        }).catch(function(error){
            console.log('createQuery caught an error:', error);
        });
    },
    _deleteQuery: function() {
        var queryId = _qEditor.activeQuery._id;
        bridgeit.io.query.deleteQuery({
            id:queryId,
            accessToken: _qEditor.accesstoken,
            account: _qEditor.account,
            realm: _qEditor.realm
        }).then(function() {
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'Query "'+queryId+'" deleted','type':'info'});
            _qEditor.resetEditor();
            _qEditor.fetchQueryList();
        }).catch(function(error){
            console.log('deleteQuery caught an error:', error);
        });
    },
    _getAllQueries: function() {
        bridgeit.io.query.findQueries({
            accessToken:  _qEditor.accesstoken,
            account:_qEditor.account,
            realm: _qEditor.realm
        }).then(function(results) {
            _qEditor.allQueries = results;
            _qEditor._setQuerylistresults(results);
            _qEditor.fire('queriesRetrieved',{results: results});
        }).catch(function(error){
            console.log('fetchQueryList caught an error:', error);
        });
    },
    _buildQuery: function(id,description,services,isClone) {
        var query = $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('getMongo');
        if (Object.keys(query).length === 0) {
            return null;
        }
        var queryToPost = {
            "query": query,
            "fields": _qEditor.getAttribute('fields') ? _qEditor.getAttribute('fields') : {},
            "options": _qEditor.getAttribute('options') ? _qEditor.getAttribute('options') : {},
            "properties":{}
        };
        if (id && jQuery.type(id) == 'string' && id.toString().length > 0) {
            queryToPost._id = id;
        }
        if ((_qEditor.activeQuery && isClone) || !_qEditor.activeQuery) {
            if (checkQueryName(queryToPost._id)) {
                return null;
            }
        }

        if (_qEditor.activeQuery) {
            if (!isClone) {
                queryToPost._id = _qEditor.activeQuery._id;
            }
            if (_qEditor.activeQuery.properties) {
                queryToPost.properties = _qEditor.activeQuery.properties;
            }
        }
        else {
            _qEditor.activeQuery = queryToPost; //set the activeQuery without the ID, ID wil be added in the save callback
        }

        if (description && jQuery.type(description) == 'string' && description.trim().length > 0) {
            queryToPost.properties.description = description;
        }
        else {
            if (queryToPost.properties && queryToPost.properties.description) {
                delete queryToPost.properties.description;
            }
        }
        if (services && jQuery.type(services) == 'array' && services.length > 0) {
            queryToPost.properties.services = services;
        }
        else {
            if (queryToPost.properties && queryToPost.properties.services) {
                delete queryToPost.properties.services;
            }
        }
        if (Object.keys(queryToPost.properties).length === 0) {
            delete queryToPost.properties;
        }
        return queryToPost;

        function checkQueryName(name) {
            var allQueries = _qEditor.allQueries;
            if (allQueries) {
                var queryExists=false;
                if (!name) {
                    return queryExists;
                }
                for (var i=0; i<allQueries.length; i++) {
                    if (allQueries[i]._id === name) {
                        queryExists=true;
                    }
                }
                if (queryExists) {
                    _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'The query name "'+name+'" already exists in this realm, please choose a different one.','type':'error'});
                }
                return queryExists;
            }
        }
    },
    _refreshQuery: function() {
        var query = $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder('getMongo');
        if (Object.keys(query).length !== 0) {
            _qEditor._updateQueryURL(query);
        }
    },
    _setQueryHeader: function(query) {
        var container = Polymer.dom(this.root).querySelector('#editor_group_0');
        if (!query || !query._id) {
            if (Polymer.dom(this.root).querySelector('#queryTitle')) {
                container.removeChild(Polymer.dom(this.root).querySelector('#queryTitle'));
            }
            return;
        }
        var div;
        if (!Polymer.dom(this.root).querySelector('#queryTitle')) {
            div = document.createElement("div");
            div.id='queryTitle';
            div.className = 'activeQuery';
            div.innerHTML = query._id;
            container.insertBefore(div, container.firstChild);
        }
        else {
            div = Polymer.dom(this.root).querySelector('#queryTitle');
            div.innerHTML = query._id;
        }
        if (query.properties && query.properties.description) {
            div.innerHTML = div.innerHTML+'<br><span>'+query.properties.description+'</span>';
        }
    },
    _updateQueryURL: function(query) {
        var queryURLTarget = _qEditor.queryurltarget;
        if (queryURLTarget && document.getElementById(queryURLTarget)) {
            var q = query ? JSON.stringify(query) : '{}';
            var params = '?access_token='+_qEditor.accesstoken+'&query='+q+'&fields='+JSON.stringify(_qEditor.fields)+'&options='+JSON.stringify(_qEditor.options);
            var queryURL = _qEditor.service_url+params;
            if ($(queryURLTarget).is(':input')) {
                document.getElementById(queryURLTarget).value=queryURL;
            }
            else {
                document.getElementById(queryURLTarget).innerHTML=queryURL;
                if (document.getElementById(queryURLTarget).tagName === 'A') {
                    document.getElementById(queryURLTarget).href=queryURL;
                }
            }
        }
    },
    _queryService: function(query) {
        var params = {
            accessToken: _qEditor.accesstoken,
            account: _qEditor.account,
            realm: _qEditor.realm,
            query: query,
            fields: _qEditor.fields,
            options: _qEditor.options
        };

        if (_qEditor.service.toLowerCase() === 'documents') {
            params.collection = _qEditor.collection;
            _qEditor.service_url = 'http://'+bridgeit.io.documentsURL+'/'+_qEditor.account+'/realms/'+_qEditor.realm+'/'+_qEditor.collection;
            bridgeit.io.documents.findDocuments(params).then(successCallback).catch(function(error){
                console.log('findDocuments caught an error:', error);
            });
        }
        else if (_qEditor.service.toLowerCase() === 'location') {
            switch (_qEditor.collection.toLowerCase()) {
                case 'locations':
                    bridgeit.io.location.findLocations(params).then(successCallback).catch(function(error){
                        console.log('findLocations caught an error:', error);
                    });
                    break;
                case 'regions':
                    bridgeit.io.location.findRegions(params).then(successCallback).catch(function(error){
                        console.log('findRegions caught an error:', error);
                    });
                    break;
                case 'pois':
                    bridgeit.io.location.findPOIs(params).then(successCallback).catch(function(error){
                        console.log('findPOIs caught an error:', error);
                    });
                    break;
                case 'monitors':
                    bridgeit.io.location.findMonitors(params).then(successCallback).catch(function(error){
                        console.log('findMonitors caught an error:', error);
                    });
                    break;
                default:
                    _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'Location Service Collection "' + _qEditor.collection + '" not supported.','type':'error'});
            }
            _qEditor.service_url = 'http://'+bridgeit.io.locateURL+'/'+_qEditor.account+'/realms/'+_qEditor.realm+'/'+_qEditor.collection;
        }
        else {
            _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'Service "' + _qEditor.service + '" not supported.','type':'error'});
            return;
        }
        function successCallback(results) {
            var obj = {};
            if( results && results.length > 0) {
                determineFields(results);
                obj = {results: results, uniqueFields: _qEditor.uniqueFields};
                _qEditor._setQueryresults(obj);
                _qEditor.fire('queryExecuted',obj);
            }
            else {
                obj = {results: [], uniqueFields: []};
                _qEditor._setQueryresults(obj);
                _qEditor.fire('queryExecuted',obj);
                _qEditor.fire('queryMsgUpdated',{id:_qEditor.id ? _qEditor.id : null, message: 'No data in the "' + _qEditor.collection +'" collection.','type':'error'});
            }
        }
        function determineFields(results) {
            var dateRegex = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|1\d|2\d|3[0-1])T(0[1-9]|1\d|2[0-3]):(0\d|1\d|2\d|3\d|4\d|5\d):(0\d|1\d|2\d|3\d|4\d|5\d).\d\d\dZ$/;
            var uniqueFields=[];
            var filters=[];
            for (var i=0; i<results.length; i++) {
                var keys = Object.keys(results[i]);
                for (var j=0; j<keys.length; j++) {
                    if (uniqueFields.indexOf(keys[j]) === -1) {
                        uniqueFields.push(keys[j]);
                        var val = results[i][keys[j]];
                        var type = jQuery.type(val);
                        var operators=[];
                        var input='';
                        var values={};
                        if (type === 'string') {
                            if (!dateRegex.test(val)) {
                                operators=['equal','not_equal','begins_with','not_begins_with','contains','not_contains',
                                    'ends_with','not_ends_with','is_empty','is_not_empty','is_null','is_not_null'];
                            }
                            else {
                                type = 'datetime';
                            }
                        }
                        else if (type === 'number') {
                            if (val%1 === 0) {
                                type = 'integer';
                            }
                            else {
                                type = 'double';
                            }
                        }
                        else if (type === 'boolean') {
                            input='select';
                            values={'true':'true','false':'false'};
                        }
                        else if (type === 'array') {
                            operators=['in', 'not_in', 'is_null', 'is_not_null'];
                        }

                        if (type !== 'string' && type !== 'integer' &&
                            type !== 'double' && type !== 'boolean' &&
                            type !== 'datetime' && type !== 'date' &&
                            type !== 'time') {
                            type = 'string';
                        }
                        var filter = {
                            id: keys[j],
                            type: type,
                            optgroup: _qEditor.service
                        };
                        if (operators.length > 0) {
                            filter.operators=operators;
                        }
                        if (input.length > 0) {
                            filter.input = input;
                        }
                        if (Object.keys(values).length > 0) {
                            filter.values = values;
                        }
                        filters.push(filter);
                    }
                }
            }
            _qEditor.uniqueFields = uniqueFields;
            $(Polymer.dom(_qEditor.root).querySelector('#editor')).queryBuilder({
                filters: filters,
                icons: {
                    add_group: 'fa fa-plus-square',
                    add_rule: 'fa fa-plus-circle',
                    remove_group: 'fa fa-minus-square',
                    remove_rule: 'fa fa-minus-circle',
                    error: 'fa fa-exclamation-triangle'
                }
            });
            _qEditor._setupListeners();
        }
    },
    _setupListeners: function() {
        $(Polymer.dom(_qEditor.root).querySelector('#editor')).on('afterCreateRuleInput.queryBuilder', function(e, rule) {
            var inputs = $(Polymer.dom(_qEditor.root).querySelector('#'+rule.id + ' .rule-value-container')).children();
            if (inputs) {
                $(inputs).bind("change",function() {
                    _qEditor._refreshQuery();
                });
            }
        });

        $(Polymer.dom(_qEditor.root).querySelector('#editor')).on('afterUpdateRuleOperator.queryBuilder', function(e, rule) {
            if (!_qEditor.skipListeners) {
                _qEditor._refreshQuery();
            }
        });
    }
});