Polymer({

    is: "bridgeit-query-editor",
    properties: {
        /**
         * Required to authenticate with BridgeIt.
         * @default bridgeit.io.auth.getLastAccessToken()
         */
        accesstoken: { type: String, value: bridgeit.io.auth.getLastAccessToken() },
        /**
         * Defines the BridgeIt realm to build queries for.
         * @default bridgeit.io.auth.getLastKnownRealm()
         */
        realm: { type: String, value: bridgeit.io.auth.getLastKnownRealm() },
        /**
         * Defines the BridgeIt account to build queries for.
         * @default bridgeit.io.auth.getLastKnownAccount()
         */
        account: { type: String, value: bridgeit.io.auth.getLastKnownAccount() },
        /**
         * The service that you would like to build the query for. Currently `documents`, `location` and `metrics` are supported.
         */
        service: { type: String, value: 'documents' },
        /**
         * The collection that you would like to build the query for. This initial dataset determines the fields available in the editor.
         */
        collection: { type: String, value: 'documents' },
        /**
         * Specify the inclusion or exclusion of fields to return in the result set.
         *
         * Example:
         *
         *      //exclude _id column
         *      {"_id":0}
         */
        fields: { type: Object, value: {} },
        /**
         * Additional query options such as limit and sort.
         *
         * Example:
         *
         *      //sort by _id (descending) + get only 100 records
         *      {"sort":{"_id":-1},"limit":100}
         */
        options: { type: Object, value: {} },
        /**
         * Element ID of where the GET URL of the query will be displayed as the query is built. Supports input and non-input elements.
         */
        queryurltarget: { type: String },
        /**
         * A string representation of the object returned from the `queryExecuted` event. Use when data binding is preferred over event listeners.
         */
        queryresults: { type: String, reflectToAttribute: true, readOnly: true },
        /**
         * A string representation of the results array returned from the `queriesRetrieved` event. Use when data binding is preferred over event listeners.
         */
        querylistresults: { type: String, reflectToAttribute: true, readOnly: true }
    },

    /**
     * Fired after a query is executed, this occurs on the initial load and when calling `runQuery()` or `reloadEditor()`. Contains the query results and the unique fields.
     *
     * @event queryExecuted
     */

    /**
     * Fired after the query list is retrieved, this occurs on the initial load and when calling `fetchQueryList()`, `saveQuery()`, `cloneQuery()`, `deleteQuery()`. Contains the list of saved queries in this realm.
     *
     * @event queriesRetrieved
     */

    /**
     * Fired whenever there is a message for an action that was triggered. Contains the message and the message type (info, error).
     *
     * @event queryMsgUpdated
     */

    ready: function() {
        this.reloadEditor();
        this.fetchQueryList();
    },

    /**
     * Execute the current query.
     */
    runQuery: function() {
        var query = $(this.$.editor).queryBuilder('getMongo');
        if (Object.keys(query).length !== 0) {
            this._queryService(query);
        }
    },

    /**
     * Creates or updates a query using the provided parameters.
     * If there is an active query in the editor then the ID parameter will be ignored and the query will be updated. Otherwise a new query is created using the provided or server generated ID.
     * @param id - The query ID, ignored if doing an update
     * @param description - Optional query description
     * @param services - Optional services array
     */
    saveQuery: function(id,description,services) {
        var query = this._buildQuery(id,description,services,false);
        if (query !== null) {
            this._createQuery(query);
        }
    },

    /**
     * Clones the currently active query using the provided parameters.
     * @param id - The query ID, generated by the service if not provided
     * @param description - Optional query description, if not provided then the existing value, if any, will be cloned
     * @param services - Optional services array, if not provided then the existing value, if any, will be cloned
     */
    cloneQuery: function(id,description,services) {
        if (!this.activeQuery) {
            this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: 'No query to clone.','type':'error'});
            return;
        }
        var query = this._buildQuery(id,description,services,true);
        if (query !== null) {
            this._createQuery(query);
        }
    },

    /**
     * Deletes the currently active query.
     */
    deleteQuery: function() {
        if (!this.activeQuery || !this.activeQuery._id) {
            this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: 'No query to delete.','type':'error'});
            return;
        }
        this._deleteQuery();
    },

    /**
     * Clears the query editor and restores the `fields` and `options` attributes to their original values.
     */
    resetEditor: function() {
        $(this.$.editor).queryBuilder('reset');
        this.options = JSON.parse(this.getAttribute('options')) || {};
        this.fields = JSON.parse(this.getAttribute('fields')) || {};
        this.activeQuery = null;
        this._setQueryHeader(null);
        this._updateQueryURL();
    },

    /**
     * Retrieves a list of all the queries in the current realm.
     */
    fetchQueryList: function() {
        if (!this.accesstoken || !this.realm || !this.account || !this.service || !this.collection) {
            return;
        }
        this._getAllQueries();
    },

    /**
     * Populate the editor from an existing query.
     * @param query - The query in object form.
     */
    setEditorFromMongo: function(query) {
        this.skipListeners = true;
        this.options = query.options || {};
        this.fields = query.fields || {};
        try {
            $(this.$.editor).queryBuilder('setRulesFromMongo',query.query);
            this.activeQuery = query;
            this._setQueryHeader(query);
        }
        catch (e) {
            var errorMsg = 'Unable to populate query editor. ';
            if (e.message.indexOf('Undefined filter') !== -1) {
                errorMsg = errorMsg + '"' + e.message.split('Undefined filter: ').join('') + '"' + ' field does not exist in this database.';
            }
            else {
                errorMsg = errorMsg + e.message;
            }
            this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: errorMsg,'type':'error'});
        }
        this._updateQueryURL(query.query);
        this.skipListeners = false;
    },

    /**
     * Completely destroy and reinitialize the editor.
     */
    reloadEditor: function() {
        if (!this.accesstoken || !this.realm || !this.account || !this.service || !this.collection) {
            return;
        }
        $(this.$.editor).queryBuilder('destroy');
        this._queryService({});
        this._updateQueryURL();
    },

    /**
     * Test if the current query is valid.
     * @return {boolean} Indicates if the query is valid.
     */
    validateQuery: function() {
        return Object.keys($(this.$.editor).queryBuilder('getMongo')).length > 0;
    },

    /**
     * Get the currently active query.
     * @return {object} Represents the currently active query or null if the there is no active query.
     */
    getActiveQuery: function() {
        return this.activeQuery || null;
    },


    //******************PRIVATE API******************

    _createQuery: function(query) {
        var _this = this;
        bridgeit.io.query.createQuery({
            accessToken: this.accesstoken,
            account: this.account,
            realm: this.realm,
            query: query
        }).then(function(uri) {
            var queryId = uri.split("/").pop();
            query._id = queryId;
            _this.activeQuery = query;
            _this._setQueryHeader(_this.activeQuery);
            _this.fetchQueryList();
            _this.fire('queryMsgUpdated',{id:_this.id ? _this.id : null, message: 'Query "'+queryId+'" saved','type':'info'});
        }).catch(function(error){
            console.log('createQuery caught an error:', error);
            _this.fire('bridgeit-error', {error: error});
        });
    },
    _deleteQuery: function() {
        var _this = this;
        var queryId = this.activeQuery._id;
        bridgeit.io.query.deleteQuery({
            id:queryId,
            accessToken: this.accesstoken,
            account: this.account,
            realm: this.realm
        }).then(function() {
            _this.fire('queryMsgUpdated',{id:_this.id ? _this.id : null, message: 'Query "'+queryId+'" deleted','type':'info'});
            _this.resetEditor();
            _this.fetchQueryList();
        }).catch(function(error){
            console.log('deleteQuery caught an error:', error);
            _this.fire('bridgeit-error', {error: error});
        });
    },
    _getAllQueries: function() {
        var _this = this;
        bridgeit.io.query.findQueries({
            accessToken:  this.accesstoken,
            account:this.account,
            realm: this.realm
        }).then(function(results) {
            _this.allQueries = results;
            _this._setQuerylistresults(results);
            _this.fire('queriesRetrieved',{results: results});
        }).catch(function(error){
            console.log('fetchQueryList caught an error:', error);
            _this.fire('bridgeit-error', {error: error});
        });
    },
    _buildQuery: function(id,description,services,isClone) {
        var query = $(this.$.editor).queryBuilder('getMongo');
        if (Object.keys(query).length === 0) {
            return null;
        }
        var queryToPost = {
            "query": query,
            "fields": this.getAttribute('fields') ? this.getAttribute('fields') : {},
            "options": this.getAttribute('options') ? this.getAttribute('options') : {},
            "properties":{}
        };
        if (id && $.type(id) == 'string' && id.toString().length > 0) {
            queryToPost._id = id;
        }
        if ((this.activeQuery && isClone) || !this.activeQuery) {
            if (checkQueryName(queryToPost._id)) {
                return null;
            }
        }

        if (this.activeQuery) {
            if (!isClone) {
                queryToPost._id = this.activeQuery._id;
            }
            if (this.activeQuery.properties) {
                queryToPost.properties = this.activeQuery.properties;
            }
        }
        else {
            this.activeQuery = queryToPost; //set the activeQuery without the ID, ID wil be added in the save callback
        }

        if (description && $.type(description) == 'string' && description.trim().length > 0) {
            queryToPost.properties.description = description;
        }
        else {
            if (queryToPost.properties && queryToPost.properties.description) {
                delete queryToPost.properties.description;
            }
        }
        if (services && $.type(services) == 'array' && services.length > 0) {
            queryToPost.properties.services = services;
        }
        else {
            if (queryToPost.properties && queryToPost.properties.services) {
                delete queryToPost.properties.services;
            }
        }
        if (Object.keys(queryToPost.properties).length === 0) {
            delete queryToPost.properties;
        }
        return queryToPost;

        function checkQueryName(name) {
            var allQueries = this.allQueries;
            if (allQueries) {
                var queryExists=false;
                if (!name) {
                    return queryExists;
                }
                for (var i=0; i<allQueries.length; i++) {
                    if (allQueries[i]._id === name) {
                        queryExists=true;
                    }
                }
                if (queryExists) {
                    this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: 'The query name "'+name+'" already exists in this realm, please choose a different one.','type':'error'});
                }
                return queryExists;
            }
        }
    },
    _refreshQuery: function() {
        var query = $(this.$.editor).queryBuilder('getMongo');
        if (Object.keys(query).length !== 0) {
            this._updateQueryURL(query);
        }
    },
    _setQueryHeader: function(query) {
        var container = Polymer.dom(this.root).querySelector('#editor_group_0');
        if (!query || !query._id) {
            if (Polymer.dom(this.root).querySelector('#queryTitle')) {
                container.removeChild(Polymer.dom(this.root).querySelector('#queryTitle'));
            }
            return;
        }
        var div;
        if (!Polymer.dom(this.root).querySelector('#queryTitle')) {
            div = document.createElement("div");
            div.id='queryTitle';
            div.className = 'activeQuery';
            div.innerHTML = query._id;
            container.insertBefore(div, container.firstChild);
        }
        else {
            div = Polymer.dom(this.root).querySelector('#queryTitle');
            div.innerHTML = query._id;
        }
        if (query.properties && query.properties.description) {
            div.innerHTML = div.innerHTML+'<br><span>'+query.properties.description+'</span>';
        }
    },
    _updateQueryURL: function(query) {
        var queryURLTarget = this.queryurltarget;
        if (queryURLTarget && document.getElementById(queryURLTarget)) {
            var q = query ? JSON.stringify(query) : '{}';
            var params = '?access_token='+this.accesstoken+'&query='+q+'&fields='+JSON.stringify(this.fields)+'&options='+JSON.stringify(this.options);
            var queryURL = this.service_url+params;
            if ($(queryURLTarget).is(':input')) {
                document.getElementById(queryURLTarget).value=queryURL;
            }
            else {
                document.getElementById(queryURLTarget).innerHTML=queryURL;
                if (document.getElementById(queryURLTarget).tagName === 'A') {
                    document.getElementById(queryURLTarget).href=queryURL;
                }
            }
        }
    },
    _queryService: function(query) {
        var _this = this;
        var params = {
            accessToken: this.accesstoken,
            account: this.account,
            realm: this.realm,
            query: query,
            fields: this.fields,
            options: this.options
        };
        var protocol = 'http://';
        var path = '/'+this.account+'/realms/'+this.realm+'/'+this.collection;

        switch(this.service.toLowerCase()) {
            case 'documents':
                params.collection = this.collection;
                this.service_url = protocol+bridgeit.io.documentsURL+path;
                bridgeit.io.documents.findDocuments(params).then(successCallback).catch(function(error){
                    console.log('findDocuments caught an error:', error);
                });
                break;
            case 'location':
                switch (this.collection.toLowerCase()) {
                    case 'locations':
                        bridgeit.io.location.findLocations(params).then(successCallback).catch(function(error){
                            console.log('findLocations caught an error:', error);
                        });
                        break;
                    case 'regions':
                        bridgeit.io.location.findRegions(params).then(successCallback).catch(function(error){
                            console.log('findRegions caught an error:', error);
                        });
                        break;
                    case 'pois':
                        bridgeit.io.location.findPOIs(params).then(successCallback).catch(function(error){
                            console.log('findPOIs caught an error:', error);
                        });
                        break;
                    default:
                        this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: 'Location Service Collection "' + this.collection + '" not supported.','type':'error'});
                }
                this.service_url = protocol+bridgeit.io.locateURL+path;
                break;
            case 'metrics':
                params.collection = this.collection;
                this.service_url = protocol+bridgeit.io.metricsURL+path;
                bridgeit.io.metrics.findEvents(params).then(successCallback).catch(function(error){
                    console.log('findEvents caught an error:', error);
                });
                break;
            default:
                this.fire('queryMsgUpdated',{id:this.id ? this.id : null, message: 'Service "' + this.service + '" not supported.','type':'error'});
        }
        function successCallback(results) {
            var obj = {};
            if( results && results.length > 0) {
                determineFields(results);
                obj = {results: results, uniqueFields: _this.uniqueFields};
                _this._setQueryresults(obj);
                _this.fire('queryExecuted',obj);
            }
            else {
                obj = {results: [], uniqueFields: []};
                _this._setQueryresults(obj);
                _this.fire('queryExecuted',obj);
                _this.fire('queryMsgUpdated',{id:_this.id ? _this.id : null, message: 'No data in the "' + _this.collection +'" collection.','type':'error'});
            }
        }
        function determineFields(results) {
            var dateRegex = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|1\d|2\d|3[0-1])T(0[1-9]|1\d|2[0-3]):(0\d|1\d|2\d|3\d|4\d|5\d):(0\d|1\d|2\d|3\d|4\d|5\d).\d\d\dZ$/;
            var uniqueFields=[];
            var filters=[];
            for (var i=0; i<results.length; i++) {
                var keys = Object.keys(results[i]);
                for (var j=0; j<keys.length; j++) {
                    if (uniqueFields.indexOf(keys[j]) === -1) {
                        uniqueFields.push(keys[j]);
                        var val = results[i][keys[j]];
                        var type = $.type(val);
                        var operators=[];
                        var input='';
                        var values={};
                        if (type === 'string') {
                            if (!dateRegex.test(val)) {
                                operators=['equal','not_equal','begins_with','not_begins_with','contains','not_contains',
                                    'ends_with','not_ends_with','is_empty','is_not_empty','is_null','is_not_null'];
                            }
                            else {
                                type = 'datetime';
                            }
                        }
                        else if (type === 'number') {
                            if (val%1 === 0) {
                                type = 'integer';
                            }
                            else {
                                type = 'double';
                            }
                        }
                        else if (type === 'boolean') {
                            input='select';
                            values={'true':'true','false':'false'};
                        }
                        else if (type === 'array') {
                            operators=['in', 'not_in', 'is_null', 'is_not_null'];
                        }

                        if (type !== 'string' && type !== 'integer' &&
                            type !== 'double' && type !== 'boolean' &&
                            type !== 'datetime' && type !== 'date' &&
                            type !== 'time') {
                            type = 'string';
                        }
                        var filter = {
                            id: keys[j],
                            type: type,
                            optgroup: _this.service
                        };
                        if (operators.length > 0) {
                            filter.operators=operators;
                        }
                        if (input.length > 0) {
                            filter.input = input;
                        }
                        if (Object.keys(values).length > 0) {
                            filter.values = values;
                        }
                        filters.push(filter);
                    }
                }
            }
            _this.uniqueFields = uniqueFields;
            $(_this.$.editor).queryBuilder({
                filters: filters,
                icons: {
                    add_group: 'fa fa-plus-square',
                    add_rule: 'fa fa-plus-circle',
                    remove_group: 'fa fa-minus-square',
                    remove_rule: 'fa fa-minus-circle',
                    error: 'fa fa-exclamation-triangle'
                }
            });
            _this._setupListeners();
        }
    },
    _setupListeners: function() {
        var _this = this;
        $(this.$.editor).on('afterCreateRuleInput.queryBuilder', function(e, rule) {
            var inputs = $(Polymer.dom(_this.root).querySelector('#'+rule.id + ' .rule-value-container')).children();
            if (inputs) {
                $(inputs).bind("change",function() {
                    _this._refreshQuery();
                });
            }
        });

        $(this.$.editor).on('afterUpdateRuleOperator.queryBuilder', function(e, rule) {
            if (!_this.skipListeners) {
                _this._refreshQuery();
            }
        });
    }
});